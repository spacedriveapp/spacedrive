# Job System Macro Implementation Example

This document shows what the `#[derive(Job)]` macro generates under the hood, demonstrating how we achieve minimal boilerplate.

## Example: What You Write

```rust
use spacedrive_jobs::prelude::*;

#[derive(Job, Serialize, Deserialize)]
#[job(name = "file_copy", resumable = true)]
pub struct FileCopyJob {
    sources: Vec<SdPath>,
    destination: SdPath,
    #[job(persist = false)]
    options: CopyOptions,
}

#[job_handler]
impl FileCopyJob {
    async fn run(&mut self, ctx: JobContext) -> JobResult {
        // Your business logic here
        for source in &self.sources {
            ctx.check_interrupt().await?;
            copy_file(source, &self.destination).await?;
            ctx.checkpoint().await?;
        }
        Ok(JobOutput::Success)
    }
}
```

## What Gets Generated

### 1. Job Registration

```rust
// Auto-generated by #[derive(Job)]
impl job_system::JobDefinition for FileCopyJob {
    const NAME: &'static str = "file_copy";
    const RESUMABLE: bool = true;
    
    fn schema() -> JobSchema {
        JobSchema {
            name: Self::NAME,
            resumable: Self::RESUMABLE,
            version: 1,
            description: None,
        }
    }
}

// Auto-registration with inventory
inventory::submit! {
    job_system::JobRegistration {
        name: "file_copy",
        schema_fn: FileCopyJob::schema,
        create_fn: |data| {
            let job: FileCopyJob = serde_json::from_value(data)?;
            Box::new(JobExecutor::new(job))
        },
    }
}
```

### 2. Serialization Support

```rust
// Auto-generated serialization that respects #[job(persist = false)]
impl job_system::SerializableJob for FileCopyJob {
    fn serialize_state(&self) -> Result<Vec<u8>, JobError> {
        // Custom serializer that skips fields marked with persist = false
        let state = FileCopyJobState {
            sources: &self.sources,
            destination: &self.destination,
            // options is skipped due to #[job(persist = false)]
        };
        
        Ok(rmp_serde::to_vec(&state)?)
    }
    
    fn deserialize_state(data: &[u8]) -> Result<Self, JobError> {
        let state: FileCopyJobState = rmp_serde::from_slice(data)?;
        
        Ok(Self {
            sources: state.sources,
            destination: state.destination,
            options: Default::default(), // Use default for non-persisted fields
        })
    }
}

// Generated state struct for serialization
#[derive(Serialize, Deserialize)]
struct FileCopyJobState<'a> {
    sources: &'a Vec<SdPath>,
    destination: &'a SdPath,
}
```

### 3. Job Executor Wrapper

```rust
// Auto-generated executor that wraps your job logic
struct JobExecutor<T: JobHandler> {
    inner: T,
    state: JobExecutorState,
}

impl JobExecutor<FileCopyJob> {
    fn new(job: FileCopyJob) -> Self {
        Self {
            inner: job,
            state: JobExecutorState::default(),
        }
    }
}

// Implements the Task trait for integration with task-system
#[async_trait]
impl Task<JobError> for JobExecutor<FileCopyJob> {
    fn id(&self) -> TaskId {
        self.state.task_id
    }
    
    async fn run(&mut self, interrupter: &Interrupter) -> Result<ExecStatus, JobError> {
        // Create context with all the job system features
        let ctx = JobContext {
            id: self.state.job_id,
            library: self.state.library.clone(),
            interrupter: interrupter.clone(),
            progress_tx: self.state.progress_tx.clone(),
            checkpoint_handler: self.state.checkpoint_handler.clone(),
            metrics: Arc::new(Mutex::new(self.state.metrics.clone())),
        };
        
        // Call your run method
        match self.inner.run(ctx).await {
            Ok(output) => {
                self.state.output = Some(output);
                Ok(ExecStatus::Done(()))
            }
            Err(JobError::Interrupted) => {
                // Save state for resume
                self.save_checkpoint().await?;
                Ok(ExecStatus::Paused)
            }
            Err(e) => Err(e),
        }
    }
}

#[derive(Default)]
struct JobExecutorState {
    job_id: JobId,
    task_id: TaskId,
    library: Arc<Library>,
    progress_tx: mpsc::Sender<JobProgress>,
    checkpoint_handler: Arc<CheckpointHandler>,
    metrics: JobMetrics,
    output: Option<JobOutput>,
}
```

### 4. JobHandler Trait Implementation

```rust
// The #[job_handler] macro generates this trait implementation
#[async_trait]
impl job_system::JobHandler for FileCopyJob {
    type Output = JobOutput;
    
    async fn run(&mut self, ctx: JobContext) -> Result<Self::Output, JobError> {
        // This is your actual implementation
        <original implementation>
    }
    
    // Default implementations for optional methods
    async fn on_pause(&mut self, _ctx: &JobContext) -> Result<(), JobError> {
        Ok(())
    }
    
    async fn on_resume(&mut self, _ctx: &JobContext) -> Result<(), JobError> {
        Ok(())
    }
    
    async fn on_cancel(&mut self, _ctx: &JobContext) -> Result<(), JobError> {
        Ok(())
    }
}
```

## Advanced Macro Features

### 1. Custom Progress Types

```rust
#[derive(Job, Serialize, Deserialize)]
#[job(name = "indexer", progress = IndexerProgress)]
pub struct IndexerJob {
    location: Uuid,
}

#[derive(Serialize, Deserialize, JobProgress)]
pub struct IndexerProgress {
    pub current_path: String,
    pub files_found: usize,
    pub dirs_remaining: usize,
}
```

Generates:

```rust
impl job_system::ProgressReporter for IndexerJob {
    type Progress = IndexerProgress;
    
    fn progress_schema() -> ProgressSchema {
        ProgressSchema {
            type_name: "IndexerProgress",
            fields: vec![
                ProgressField { name: "current_path", type: "string" },
                ProgressField { name: "files_found", type: "number" },
                ProgressField { name: "dirs_remaining", type: "number" },
            ],
        }
    }
}
```

### 2. Job Dependencies

```rust
#[derive(Job)]
#[job(
    name = "thumbnail_gen",
    depends_on = ["indexer"],
    run_after = ["media_processor"]
)]
pub struct ThumbnailJob {
    entry_ids: Vec<Uuid>,
}
```

Generates:

```rust
impl job_system::JobDependencies for ThumbnailJob {
    fn dependencies() -> &'static [&'static str] {
        &["indexer"]
    }
    
    fn run_after() -> &'static [&'static str] {
        &["media_processor"]
    }
    
    fn can_run(&self, completed_jobs: &HashSet<&str>) -> bool {
        self.dependencies().iter().all(|dep| completed_jobs.contains(dep))
    }
}
```

### 3. Resource Requirements

```rust
#[derive(Job)]
#[job(
    name = "video_transcode",
    max_concurrent = 2,
    requires = ["gpu", "disk_space:10GB", "memory:4GB"]
)]
pub struct TranscodeJob {
    input: PathBuf,
    output: PathBuf,
}
```

Generates:

```rust
impl job_system::ResourceRequirements for TranscodeJob {
    fn max_concurrent() -> Option<usize> {
        Some(2)
    }
    
    fn required_resources() -> Vec<ResourceRequirement> {
        vec![
            ResourceRequirement::Named("gpu"),
            ResourceRequirement::DiskSpace(10 * 1024 * 1024 * 1024), // 10GB
            ResourceRequirement::Memory(4 * 1024 * 1024 * 1024),     // 4GB
        ]
    }
}
```

## Macro Implementation Strategy

The macro will be implemented using `syn` and `quote`:

```rust
#[proc_macro_derive(Job, attributes(job))]
pub fn derive_job(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    
    // Parse attributes
    let attrs = JobAttributes::from_derive_input(&input).unwrap();
    
    // Generate implementations
    let job_definition_impl = generate_job_definition(&input, &attrs);
    let serializable_impl = generate_serializable(&input, &attrs);
    let executor_impl = generate_executor(&input, &attrs);
    let registration = generate_registration(&input, &attrs);
    
    TokenStream::from(quote! {
        #job_definition_impl
        #serializable_impl
        #executor_impl
        #registration
    })
}
```

## Benefits of This Approach

1. **Minimal User Code**: Users only write their business logic
2. **Full Feature Set**: All job system features available via attributes
3. **Type Safety**: Compile-time checking of job definitions
4. **Zero Runtime Cost**: All code generated at compile time
5. **Extensible**: Easy to add new attributes and features
6. **Discoverable**: IDEs can provide completion for attributes
7. **Testable**: Generated code can be unit tested

## Comparison with Original System

### Original System (500-1000 lines)
```rust
// 1. Add to enum (central file)
pub enum JobName { FileCopy }

// 2. Implement Job trait (200+ lines)
impl Job for FileCopyJob {
    const NAME: JobName = JobName::FileCopy;
    // ... many required methods
}

// 3. Implement SerializableJob (200+ lines)
impl SerializableJob for FileCopyJob {
    // ... serialization logic
}

// 4. Add to registry macro (central file)
match_deserialize_job!(
    stored_job, report, ctx, 
    [FileCopyJob, /* all other jobs */]
)
```

### New System (50 lines)
```rust
#[derive(Job)]
#[job(name = "file_copy")]
pub struct FileCopyJob {
    sources: Vec<SdPath>,
    destination: SdPath,
}

#[job_handler]
impl FileCopyJob {
    async fn run(&mut self, ctx: JobContext) -> JobResult {
        // Your logic here
    }
}
```

The macro system provides the same functionality with 95% less boilerplate!