//! Content identity entity

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, Eq, DeriveEntityModel, Serialize, Deserialize)]
#[sea_orm(table_name = "content_identities")]
pub struct Model {
	#[sea_orm(primary_key)]
	pub id: i32,
	pub uuid: Option<Uuid>, // DETERMINISTIC from content_hash (assigned during content identification phase)
	pub integrity_hash: Option<String>, // Full hash for file validation (generated by validate job)
	pub content_hash: String, // Fast sampled hash for deduplication (generated during content identification)
	pub mime_type_id: Option<i32>,
	pub kind_id: i32,             // ContentKind foreign key
	pub media_data: Option<Json>, // MediaData as JSON
	pub text_content: Option<String>,
	pub total_size: i64,  // Size of one instance of this content
	pub entry_count: i32, // Entries in THIS library only
	pub first_seen_at: DateTimeUtc,
	pub last_verified_at: DateTimeUtc,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
	#[sea_orm(has_many = "super::entry::Entity")]
	Entries,
	#[sea_orm(
		belongs_to = "super::content_kind::Entity",
		from = "Column::KindId",
		to = "super::content_kind::Column::Id"
	)]
	ContentKind,
	#[sea_orm(
		belongs_to = "super::mime_type::Entity",
		from = "Column::MimeTypeId",
		to = "super::mime_type::Column::Id"
	)]
	MimeType,
}

impl Related<super::entry::Entity> for Entity {
	fn to() -> RelationDef {
		Relation::Entries.def()
	}
}

impl Related<super::content_kind::Entity> for Entity {
	fn to() -> RelationDef {
		Relation::ContentKind.def()
	}
}

impl Related<super::mime_type::Entity> for Entity {
	fn to() -> RelationDef {
		Relation::MimeType.def()
	}
}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
	/// Generate deterministic UUID from content_hash for sync consistency within library
	/// Note: ContentIdentity UUIDs are deterministic from content_hash + library_id
	/// This ensures same content in different libraries has different UUIDs
	/// Maintains library isolation while enabling deterministic sync
	pub fn deterministic_uuid(content_hash: &str, library_id: Uuid) -> Uuid {
		const LIBRARY_NAMESPACE: Uuid = Uuid::from_bytes([
			0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4,
			0x30, 0xc8,
		]);
		let namespace = Uuid::new_v5(&LIBRARY_NAMESPACE, library_id.as_bytes());
		Uuid::new_v5(&namespace, content_hash.as_bytes())
	}

	/// Calculate combined size on-demand (no need to cache entry_count * total_size)
	pub fn combined_size(&self) -> i64 {
		self.entry_count as i64 * self.total_size
	}
}
