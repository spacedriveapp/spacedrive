/* eslint-disable */
// This file was generated by [rspc](https://github.com/spacedriveapp/rspc). Do not edit this file manually.

export type Procedures = {
    queries: 
        { key: "backups.getAll", input: never, result: GetAll } | 
        { key: "buildInfo", input: never, result: BuildInfo } | 
        { key: "cloud.devices.get", input: CloudDevicePubId, result: CloudDevice } | 
        { key: "cloud.devices.get_current_device", input: never, result: CloudDevice } | 
        { key: "cloud.devices.list", input: never, result: CloudDevice[] } | 
        { key: "cloud.hasBootstrapped", input: never, result: boolean } | 
        { key: "cloud.libraries.get", input: CloudGetLibraryArgs, result: CloudLibrary } | 
        { key: "cloud.libraries.list", input: boolean, result: CloudLibrary[] } | 
        { key: "cloud.locations.list", input: CloudListLocationsArgs, result: CloudLocation[] } | 
        { key: "cloud.syncGroups.get", input: CloudGetSyncGroupArgs, result: CloudSyncGroupGetResponseKind } | 
        { key: "cloud.syncGroups.leave", input: CloudSyncGroupPubId, result: null } | 
        { key: "cloud.syncGroups.list", input: never, result: CloudSyncGroupBaseData[] } | 
        { key: "cloud.syncGroups.remove_device", input: CloudSyncGroupsRemoveDeviceArgs, result: null } | 
        { key: "devices.list", input: LibraryArgs<null>, result: Device[] } | 
        { key: "ephemeralFiles.getMediaData", input: string, result: MediaData | null } | 
        { key: "files.get", input: LibraryArgs<number>, result: ObjectWithFilePaths2 | null } | 
        { key: "files.getConvertibleImageExtensions", input: never, result: string[] } | 
        { key: "files.getMediaData", input: LibraryArgs<number>, result: MediaData } | 
        { key: "files.getPath", input: LibraryArgs<number>, result: string | null } | 
        { key: "invalidation.test-invalidate", input: never, result: number } | 
        { key: "jobs.isActive", input: LibraryArgs<null>, result: boolean } | 
        { key: "jobs.reports", input: LibraryArgs<null>, result: JobGroup[] } | 
        { key: "labels.count", input: LibraryArgs<null>, result: number } | 
        { key: "labels.get", input: LibraryArgs<number>, result: Label | null } | 
        { key: "labels.getForObject", input: LibraryArgs<number>, result: Label[] } | 
        { key: "labels.getWithObjects", input: LibraryArgs<number[]>, result: { [key in number]: { date_created: string; object: { id: number } }[] } } | 
        { key: "labels.list", input: LibraryArgs<null>, result: Label[] } | 
        { key: "labels.listWithThumbnails", input: LibraryArgs<string>, result: ExplorerItem[] } | 
        { key: "library.kindStatistics", input: LibraryArgs<null>, result: KindStatistics } | 
        { key: "library.list", input: never, result: LibraryConfigWrapped[] } | 
        { key: "library.statistics", input: LibraryArgs<null>, result: StatisticsResponse } | 
        { key: "locations.get", input: LibraryArgs<number>, result: Location | null } | 
        { key: "locations.getWithRules", input: LibraryArgs<number>, result: LocationWithIndexerRule | null } | 
        { key: "locations.indexer_rules.get", input: LibraryArgs<number>, result: IndexerRule } | 
        { key: "locations.indexer_rules.list", input: LibraryArgs<null>, result: IndexerRule[] } | 
        { key: "locations.indexer_rules.listForLocation", input: LibraryArgs<number>, result: IndexerRule[] } | 
        { key: "locations.list", input: LibraryArgs<null>, result: Location[] } | 
        { key: "locations.systemLocations", input: never, result: SystemLocations } | 
        { key: "models.image_detection.list", input: never, result: string[] } | 
        { key: "nodeState", input: never, result: NodeState } | 
        { key: "nodes.listLocations", input: LibraryArgs<string | null>, result: ExplorerItem[] } | 
        { key: "notifications.dismiss", input: NotificationId, result: null } | 
        { key: "notifications.dismissAll", input: never, result: null } | 
        { key: "notifications.get", input: never, result: Notification[] } | 
        { key: "p2p.listeners", input: never, result: Listeners } | 
        { key: "p2p.state", input: never, result: JsonValue } | 
        { key: "preferences.get", input: LibraryArgs<null>, result: LibraryPreferences } | 
        { key: "search.objects", input: LibraryArgs<ObjectSearchArgs>, result: SearchData<ExplorerItem> } | 
        { key: "search.objectsCount", input: LibraryArgs<{ filters?: SearchFilterArgs[] }>, result: number } | 
        { key: "search.paths", input: LibraryArgs<FilePathSearchArgs>, result: SearchData<ExplorerItem> } | 
        { key: "search.pathsCount", input: LibraryArgs<{ filters?: SearchFilterArgs[] }>, result: number } | 
        { key: "search.saved.get", input: LibraryArgs<number>, result: SavedSearch | null } | 
        { key: "search.saved.list", input: LibraryArgs<null>, result: SavedSearch[] } | 
        { key: "sync.enabled", input: LibraryArgs<null>, result: boolean } | 
        { key: "tags.get", input: LibraryArgs<number>, result: Tag | null } | 
        { key: "tags.getForObject", input: LibraryArgs<number>, result: Tag[] } | 
        { key: "tags.getWithObjects", input: LibraryArgs<number[]>, result: { [key in number]: ({ object: { id: number }; date_created: string | null })[] } } | 
        { key: "tags.list", input: LibraryArgs<null>, result: Tag[] } | 
        { key: "volumes.list", input: LibraryArgs<null>, result: Volume[] } | 
        { key: "volumes.listForLibrary", input: LibraryArgs<null>, result: Volume[] },
    mutations: 
        { key: "api.sendFeedback", input: Feedback, result: null } | 
        { key: "backups.backup", input: LibraryArgs<null>, result: string } | 
        { key: "backups.delete", input: string, result: null } | 
        { key: "backups.restore", input: string, result: null } | 
        { key: "cloud.bootstrap", input: [AccessToken, RefreshToken], result: null } | 
        { key: "cloud.devices.delete", input: CloudDevicePubId, result: null } | 
        { key: "cloud.devices.update", input: CloudUpdateDeviceArgs, result: null } | 
        { key: "cloud.libraries.create", input: LibraryArgs<null>, result: null } | 
        { key: "cloud.libraries.delete", input: LibraryArgs<null>, result: null } | 
        { key: "cloud.libraries.update", input: LibraryArgs<string>, result: null } | 
        { key: "cloud.locations.create", input: CloudCreateLocationArgs, result: null } | 
        { key: "cloud.locations.delete", input: CloudLocationPubId, result: null } | 
        { key: "cloud.syncGroups.create", input: LibraryArgs<null>, result: null } | 
        { key: "cloud.syncGroups.delete", input: CloudSyncGroupPubId, result: null } | 
        { key: "cloud.syncGroups.request_join", input: SyncGroupsRequestJoinArgs, result: null } | 
        { key: "cloud.userResponse", input: CloudP2PUserResponse, result: null } | 
        { key: "ephemeralFiles.copyFiles", input: LibraryArgs<EphemeralFileSystemOps>, result: null } | 
        { key: "ephemeralFiles.createFile", input: LibraryArgs<CreateEphemeralFileArgs>, result: string } | 
        { key: "ephemeralFiles.createFolder", input: LibraryArgs<CreateEphemeralFolderArgs>, result: string } | 
        { key: "ephemeralFiles.cutFiles", input: LibraryArgs<EphemeralFileSystemOps>, result: null } | 
        { key: "ephemeralFiles.deleteFiles", input: LibraryArgs<string[]>, result: null } | 
        { key: "ephemeralFiles.moveToTrash", input: LibraryArgs<string[]>, result: null } | 
        { key: "ephemeralFiles.renameFile", input: LibraryArgs<EphemeralRenameFileArgs>, result: null } | 
        { key: "files.convertImage", input: LibraryArgs<ConvertImageArgs>, result: null } | 
        { key: "files.copyFiles", input: LibraryArgs<OldFileCopierJobInit>, result: null } | 
        { key: "files.createFile", input: LibraryArgs<CreateFileArgs>, result: string } | 
        { key: "files.createFolder", input: LibraryArgs<CreateFolderArgs>, result: string } | 
        { key: "files.cutFiles", input: LibraryArgs<OldFileCutterJobInit>, result: null } | 
        { key: "files.deleteFiles", input: LibraryArgs<OldFileDeleterJobInit>, result: null } | 
        { key: "files.eraseFiles", input: LibraryArgs<OldFileEraserJobInit>, result: null } | 
        { key: "files.moveToTrash", input: LibraryArgs<OldFileDeleterJobInit>, result: null } | 
        { key: "files.removeAccessTime", input: LibraryArgs<number[]>, result: null } | 
        { key: "files.renameFile", input: LibraryArgs<RenameFileArgs>, result: null } | 
        { key: "files.setFavorite", input: LibraryArgs<SetFavoriteArgs>, result: null } | 
        { key: "files.setNote", input: LibraryArgs<SetNoteArgs>, result: null } | 
        { key: "files.updateAccessTime", input: LibraryArgs<number[]>, result: null } | 
        { key: "invalidation.test-invalidate-mutation", input: LibraryArgs<null>, result: null } | 
        { key: "jobs.cancel", input: LibraryArgs<string>, result: null } | 
        { key: "jobs.clear", input: LibraryArgs<string>, result: null } | 
        { key: "jobs.clearAll", input: LibraryArgs<null>, result: null } | 
        { key: "jobs.generateThumbsForLocation", input: LibraryArgs<GenerateThumbsForLocationArgs>, result: string } | 
        { key: "jobs.identifyUniqueFiles", input: LibraryArgs<IdentifyUniqueFilesArgs>, result: string } | 
        { key: "jobs.objectValidator", input: LibraryArgs<ObjectValidatorArgs>, result: null } | 
        { key: "jobs.pause", input: LibraryArgs<string>, result: null } | 
        { key: "jobs.resume", input: LibraryArgs<string>, result: null } | 
        { key: "labels.delete", input: LibraryArgs<number>, result: null } | 
        { key: "library.create", input: CreateLibraryArgs, result: LibraryConfigWrapped } | 
        { key: "library.delete", input: string, result: null } | 
        { key: "library.edit", input: EditLibraryArgs, result: null } | 
        { key: "library.vacuumDb", input: LibraryArgs<null>, result: null } | 
        { key: "locations.addLibrary", input: LibraryArgs<LocationCreateArgs>, result: number | null } | 
        { key: "locations.create", input: LibraryArgs<LocationCreateArgs>, result: number | null } | 
        { key: "locations.delete", input: LibraryArgs<number>, result: null } | 
        { key: "locations.fullRescan", input: LibraryArgs<FullRescanArgs>, result: string | null } | 
        { key: "locations.indexer_rules.create", input: LibraryArgs<IndexerRuleCreateArgs>, result: null } | 
        { key: "locations.indexer_rules.delete", input: LibraryArgs<number>, result: null } | 
        { key: "locations.relink", input: LibraryArgs<string>, result: number } | 
        { key: "locations.subPathRescan", input: LibraryArgs<RescanArgs>, result: string | null } | 
        { key: "locations.update", input: LibraryArgs<LocationUpdateArgs>, result: null } | 
        { key: "nodes.edit", input: ChangeNodeNameArgs, result: null } | 
        { key: "nodes.updateThumbnailerPreferences", input: UpdateThumbnailerPreferences, result: null } | 
        { key: "p2p.acceptSpacedrop", input: [string, string | null], result: null } | 
        { key: "p2p.cancelSpacedrop", input: string, result: null } | 
        { key: "p2p.debugConnect", input: RemoteIdentity, result: string } | 
        { key: "p2p.spacedrop", input: SpacedropArgs, result: string } | 
        { key: "preferences.update", input: LibraryArgs<LibraryPreferences>, result: null } | 
        { key: "search.saved.create", input: LibraryArgs<{ name: string; target?: SearchTarget; search?: string | null; filters?: string | null; description?: string | null; icon?: string | null }>, result: null } | 
        { key: "search.saved.delete", input: LibraryArgs<number>, result: null } | 
        { key: "search.saved.update", input: LibraryArgs<[number, Args]>, result: null } | 
        { key: "sync.backfill", input: LibraryArgs<null>, result: null } | 
        { key: "tags.assign", input: LibraryArgs<{ targets: Target[]; tag_id: number; unassign: boolean }>, result: null } | 
        { key: "tags.create", input: LibraryArgs<TagCreateArgs>, result: Tag } | 
        { key: "tags.delete", input: LibraryArgs<number>, result: null } | 
        { key: "tags.update", input: LibraryArgs<TagUpdateArgs>, result: null } | 
        { key: "toggleFeatureFlag", input: BackendFeature, result: null } | 
        { key: "volumes.track", input: LibraryArgs<VolumeFingerprint>, result: null } | 
        { key: "volumes.unmount", input: LibraryArgs<number[]>, result: null },
    subscriptions: 
        { key: "cloud.listenCloudServicesNotifications", input: never, result: CloudP2PNotifyUser } | 
        { key: "invalidation.listen", input: never, result: InvalidateOperationEvent[] } | 
        { key: "jobs.newFilePathIdentified", input: LibraryArgs<null>, result: number[] } | 
        { key: "jobs.newThumbnail", input: LibraryArgs<null>, result: ThumbKey } | 
        { key: "jobs.progress", input: LibraryArgs<null>, result: JobProgressEvent } | 
        { key: "library.actors", input: LibraryArgs<null>, result: ([string, boolean])[] } | 
        { key: "library.updatedKindStatistic", input: LibraryArgs<null>, result: KindStatistic } | 
        { key: "locations.online", input: never, result: number[][] } | 
        { key: "locations.quickRescan", input: LibraryArgs<LightScanArgs>, result: null } | 
        { key: "notifications.listen", input: never, result: Notification } | 
        { key: "p2p.events", input: never, result: P2PEvent } | 
        { key: "search.ephemeralPaths", input: LibraryArgs<EphemeralPathSearchArgs>, result: { entries: ExplorerItem[]; errors: Error[] } } | 
        { key: "sync.active", input: LibraryArgs<null>, result: SyncStatus } | 
        { key: "volumes.events", input: LibraryArgs<null>, result: VolumeEvent }
};

/**
 * Newtype wrapper for the access token
 */
export type AccessToken = string

export type Args = { search?: string | null; filters?: string | null; name?: string | null; icon?: string | null; description?: string | null }

export type AudioProps = { delay: number; padding: number; sample_rate: number | null; sample_format: string | null; bit_per_sample: number | null; channel_layout: string | null }

/**
 * All of the feature flags provided by the core itself. The frontend has it's own set of feature flags!
 * 
 * If you want a variant of this to show up on the frontend it must be added to `backendFeatures` in `useFeatureFlag.tsx`
 */
export type BackendFeature = never

export type Backup = ({ id: string; timestamp: string; library_id: string; library_name: string }) & { path: string }

export type BasicLibraryCreationArgs = { id: CloudLibraryPubId; name: string; description: string | null }

export type BuildInfo = { version: string; commit: string }

export type CameraData = { device_make: string | null; device_model: string | null; color_space: string | null; color_profile: ColorProfile | null; focal_length: number | null; shutter_speed: number | null; flash: Flash | null; orientation: Orientation; lens_make: string | null; lens_model: string | null; bit_depth: number | null; zoom: number | null; iso: number | null; software: string | null; serial_number: string | null; lens_serial_number: string | null; contrast: number | null; saturation: number | null; sharpness: number | null; composite: Composite | null }

export type CasId = string

export type ChangeNodeNameArgs = { name: string | null; p2p_port: Port | null; p2p_disabled: boolean | null; p2p_ipv6_disabled: boolean | null; p2p_relay_disabled: boolean | null; p2p_discovery: P2PDiscoveryState | null; p2p_remote_access: boolean | null; p2p_manual_peers: string[] | null }

export type Chapter = { id: number; start: [number, number]; end: [number, number]; time_base_den: number; time_base_num: number; metadata: Metadata }

export type CloudCreateLocationArgs = { pub_id: CloudLocationPubId; name: string; library_pub_id: CloudLibraryPubId; device_pub_id: CloudDevicePubId }

export type CloudDevice = { pub_id: CloudDevicePubId; name: string; os: DeviceOS; hardware_model: HardwareModel; connection_id: string; created_at: string; updated_at: string }

export type CloudDevicePubId = string

export type CloudGetLibraryArgs = { pub_id: CloudLibraryPubId; with_device: boolean }

export type CloudGetSyncGroupArgs = { pub_id: CloudSyncGroupPubId; kind: CloudSyncGroupGetRequestKind }

export type CloudLibrary = { pub_id: CloudLibraryPubId; name: string; original_device: CloudDevice | null; created_at: string; updated_at: string }

export type CloudLibraryPubId = string

export type CloudListLocationsArgs = { library_pub_id: CloudLibraryPubId; with_library: boolean; with_device: boolean }

export type CloudLocation = { pub_id: CloudLocationPubId; name: string; device: CloudDevice | null; library: CloudLibrary | null; created_at: string; updated_at: string }

export type CloudLocationPubId = string

export type CloudP2PError = "Rejected" | "UnableToConnect" | "TimedOut"

export type CloudP2PNotifyUser = { kind: "ReceivedJoinSyncGroupRequest"; data: { ticket: CloudP2PTicket; asking_device: CloudDevice; sync_group: CloudSyncGroupWithDevices } } | { kind: "ReceivedJoinSyncGroupResponse"; data: { response: JoinSyncGroupResponse; sync_group: CloudSyncGroupWithDevices } } | { kind: "SendingJoinSyncGroupResponseError"; data: { error: JoinSyncGroupError; sync_group: CloudSyncGroupWithDevices } } | { kind: "TimedOutJoinRequest"; data: { device: CloudDevice; succeeded: boolean } }

export type CloudP2PTicket = bigint

export type CloudP2PUserResponse = { kind: "AcceptDeviceInSyncGroup"; data: { ticket: CloudP2PTicket; accepted: BasicLibraryCreationArgs | null } }

/**
 * Represents the cloud storage provider
 */
export type CloudProvider = "SpacedriveCloud" | "GoogleDrive" | "Dropbox" | "OneDrive" | "ICloud" | "AmazonS3" | "Mega" | "Box" | "pCloud" | "Proton" | "Sync" | "Backblaze" | "Wasabi" | "DigitalOcean" | "Azure" | "OwnCloud" | "NextCloud" | "WebDAV"

export type CloudSyncGroup = { pub_id: CloudSyncGroupPubId; latest_key_hash: CloudSyncKeyHash; library: CloudLibrary; devices: CloudDevice[]; total_sync_messages_bytes: bigint; total_space_files_bytes: bigint; created_at: string; updated_at: string }

export type CloudSyncGroupBaseData = { pub_id: CloudSyncGroupPubId; latest_key_hash: CloudSyncKeyHash; library: CloudLibrary; created_at: string; updated_at: string }

export type CloudSyncGroupGetRequestKind = "WithDevices" | "DevicesConnectionIds" | "FullData"

export type CloudSyncGroupGetResponseKind = { kind: "WithDevices"; data: CloudSyncGroupWithDevices } | { kind: "FullData"; data: CloudSyncGroup }

export type CloudSyncGroupPubId = string

export type CloudSyncGroupWithDevices = { pub_id: CloudSyncGroupPubId; latest_key_hash: CloudSyncKeyHash; library: CloudLibrary; devices: CloudDevice[]; created_at: string; updated_at: string }

export type CloudSyncGroupsRemoveDeviceArgs = { group_pub_id: CloudSyncGroupPubId; to_remove_device_pub_id: CloudDevicePubId }

export type CloudSyncKeyHash = string

export type CloudUpdateDeviceArgs = { pub_id: CloudDevicePubId; name: string }

export type Codec = { kind: string | null; sub_kind: string | null; tag: string | null; name: string | null; profile: string | null; bit_rate: number; props: Props | null }

export type ColorProfile = "Normal" | "Custom" | "HDRNoOriginal" | "HDRWithOriginal" | "OriginalForHDR" | "Panorama" | "PortraitHDR" | "Portrait"

export type Composite = 
/**
 * The data is present, but we're unable to determine what they mean
 */
"Unknown" | 
/**
 * Not a composite image
 */
"False" | 
/**
 * A general composite image
 */
"General" | 
/**
 * The composite image was captured while shooting
 */
"Live"

/**
 * The method used for the connection with this peer.
 * *Technically* you can have multiple under the hood but this simplifies things for the UX.
 */
export type ConnectionMethod = "Relay" | "Local" | "Disconnected"

export type ConvertImageArgs = { location_id: number; file_path_id: number; delete_src: boolean; desired_extension: ConvertibleExtension; quality_percentage: number | null }

export type ConvertibleExtension = "bmp" | "dib" | "ff" | "gif" | "ico" | "jpg" | "jpeg" | "png" | "pnm" | "qoi" | "tga" | "icb" | "vda" | "vst" | "tiff" | "tif" | "hif" | "heif" | "heifs" | "heic" | "heics" | "avif" | "avci" | "avcs" | "svg" | "svgz" | "pdf" | "webp"

export type CoreDevicePubId = CorePubId

export type CoreHardwareModel = "Other" | "MacStudio" | "MacBookAir" | "MacBookPro" | "MacBook" | "MacMini" | "MacPro" | "IMac" | "IMacPro" | "IPad" | "IPhone" | "Simulator" | "Android"

export type CorePubId = { Uuid: string } | { Vec: number[] }

export type CreateEphemeralFileArgs = { path: string; context: EphemeralFileCreateContextTypes; name: string | null }

export type CreateEphemeralFolderArgs = { path: string; name: string | null }

export type CreateFileArgs = { location_id: number; sub_path: string | null; name: string | null; context: FileCreateContextTypes }

export type CreateFolderArgs = { location_id: number; sub_path: string | null; name: string | null }

export type CreateLibraryArgs = { name: LibraryName; default_locations: DefaultLocations | null }

export type CursorOrderItem<T> = { order: SortOrder; data: T }

export type DefaultLocations = { desktop: boolean; documents: boolean; downloads: boolean; pictures: boolean; music: boolean; videos: boolean }

export type Device = { id: number; pub_id: number[]; name: string | null; os: number | null; hardware_model: number | null; timestamp: bigint | null; date_created: string | null; date_deleted: string | null }

export type DeviceOS = "Linux" | "Windows" | "MacOS" | "iOS" | "Android"

/**
 * The method used for the discovery of this peer.
 * *Technically* you can have multiple under the hood but this simplifies things for the UX.
 */
export type DiscoveryMethod = "Relay" | "Local" | "Manual"

/**
 * Represents the type of physical storage device
 */
export type DiskType = 
/**
 * Solid State Drive
 */
"SSD" | 
/**
 * Hard Disk Drive
 */
"HDD" | 
/**
 * Virtual disk type
 */
"Virtual" | 
/**
 * Unknown or virtual disk type
 */
"Unknown"

export type DoubleClickAction = "openFile" | "quickPreview"

export type EditLibraryArgs = { id: string; name: LibraryName | null; description: MaybeUndefined<string> }

export type EphemeralFileCreateContextTypes = "empty" | "text"

export type EphemeralFileSystemOps = { sources: string[]; target_dir: string }

export type EphemeralPathOrder = { field: "name"; value: SortOrder } | { field: "sizeInBytes"; value: SortOrder } | { field: "dateCreated"; value: SortOrder } | { field: "dateModified"; value: SortOrder }

export type EphemeralPathSearchArgs = { path: string; withHiddenFiles: boolean; order?: EphemeralPathOrder | null }

export type EphemeralRenameFileArgs = { kind: EphemeralRenameKind }

export type EphemeralRenameKind = { One: EphemeralRenameOne } | { Many: EphemeralRenameMany }

export type EphemeralRenameMany = { from_pattern: FromPattern; to_pattern: string; from_paths: string[] }

export type EphemeralRenameOne = { from_path: string; to: string }

export type Error = { code: ErrorCode; message: string }

/**
 * TODO
 */
export type ErrorCode = "BadRequest" | "Unauthorized" | "Forbidden" | "NotFound" | "Timeout" | "Conflict" | "PreconditionFailed" | "PayloadTooLarge" | "MethodNotSupported" | "ClientClosedRequest" | "InternalServerError"

export type ExifDataOrder = { field: "epochTime"; value: SortOrder }

export type ExifMetadata = { resolution: Resolution; date_taken: MediaDate | null; location: MediaLocation | null; camera_data: CameraData; artist: string | null; description: string | null; copyright: string | null; exif_version: string | null }

export type ExplorerItem = { type: "Path"; thumbnail: ThumbKey | null; has_created_thumbnail: boolean; item: FilePathForFrontend } | { type: "Object"; thumbnail: ThumbKey | null; has_created_thumbnail: boolean; item: ObjectWithFilePaths } | { type: "NonIndexedPath"; thumbnail: ThumbKey | null; has_created_thumbnail: boolean; item: NonIndexedPathItem } | { type: "Location"; item: Location } | { type: "SpacedropPeer"; item: PeerMetadata } | { type: "Label"; thumbnails: ThumbKey[]; item: LabelWithObjects }

export type ExplorerLayout = "grid" | "list" | "media"

export type ExplorerSettings<TOrder> = { layoutMode: ExplorerLayout | null; gridItemSize: number | null; gridGap: number | null; mediaColumns: number | null; mediaAspectSquare: boolean | null; mediaViewWithDescendants: boolean | null; openOnDoubleClick: DoubleClickAction | null; showBytesInGridView: boolean | null; colVisibility: { [key in string]: boolean } | null; colSizes: { [key in string]: number } | null; listViewIconSize: string | null; listViewTextSize: string | null; order?: TOrder | null; showHiddenFiles?: boolean }

export type FFmpegMetadata = { formats: string[]; duration: [number, number] | null; start_time: [number, number] | null; bit_rate: [number, number]; chapters: Chapter[]; programs: Program[]; metadata: Metadata }

export type Feedback = { message: string; emoji: number }

export type FfmpegMediaAudioProps = { id: number; delay: number; padding: number; sample_rate: number | null; sample_format: string | null; bit_per_sample: number | null; channel_layout: string | null; codec_id: number }

export type FfmpegMediaChapter = { chapter_id: number; start: number[]; end: number[]; time_base_den: number; time_base_num: number; title: string | null; metadata: number[] | null; ffmpeg_data_id: number }

export type FfmpegMediaVideoProps = { id: number; pixel_format: string | null; color_range: string | null; bits_per_channel: number | null; color_space: string | null; color_primaries: string | null; color_transfer: string | null; field_order: string | null; chroma_location: string | null; width: number; height: number; aspect_ratio_num: number | null; aspect_ratio_Den: number | null; properties: string | null; codec_id: number }

export type FileCreateContextTypes = "empty" | "text"

export type FilePath = { id: number; pub_id: number[]; is_dir: boolean | null; cas_id: string | null; integrity_checksum: string | null; location_id: number | null; materialized_path: string | null; name: string | null; extension: string | null; hidden: boolean | null; size_in_bytes: string | null; size_in_bytes_bytes: number[] | null; inode: number[] | null; object_id: number | null; key_id: number | null; date_created: string | null; date_modified: string | null; date_indexed: string | null; device_id: number | null }

export type FilePathCursor = { isDir: boolean; variant: FilePathCursorVariant }

export type FilePathCursorVariant = "none" | { name: CursorOrderItem<string> } | { sizeInBytes: SortOrder } | { dateCreated: CursorOrderItem<string> } | { dateModified: CursorOrderItem<string> } | { dateIndexed: CursorOrderItem<string> } | { object: FilePathObjectCursor }

export type FilePathFilterArgs = { locations: InOrNotIn<number> } | { path: { location_id: number; path: string; include_descendants: boolean } } | { name: TextMatch } | { extension: InOrNotIn<string> } | { createdAt: Range<string> } | { modifiedAt: Range<string> } | { indexedAt: Range<string> } | { hidden: boolean }

export type FilePathForFrontend = { id: number; pub_id: number[]; is_dir: boolean | null; cas_id: string | null; integrity_checksum: string | null; location_id: number | null; materialized_path: string | null; name: string | null; extension: string | null; hidden: boolean | null; size_in_bytes: string | null; size_in_bytes_bytes: number[] | null; inode: number[] | null; object_id: number | null; object: { id: number; pub_id: number[]; kind: number | null; key_id: number | null; hidden: boolean | null; favorite: boolean | null; important: boolean | null; note: string | null; date_created: string | null; date_accessed: string | null; tags: ({ object_id: number; tag_id: number; tag: Tag; date_created: string | null; device_id: number | null })[]; exif_data: { resolution: number[] | null; media_date: number[] | null; media_location: number[] | null; camera_data: number[] | null; artist: string | null; description: string | null; copyright: string | null; exif_version: string | null } | null; device_id: number | null } | null; key_id: number | null; date_created: string | null; date_modified: string | null; date_indexed: string | null; device_id: number | null }

export type FilePathObjectCursor = { dateAccessed: CursorOrderItem<string> } | { kind: CursorOrderItem<number> }

export type FilePathOrder = { field: "name"; value: SortOrder } | { field: "sizeInBytes"; value: SortOrder } | { field: "dateCreated"; value: SortOrder } | { field: "dateModified"; value: SortOrder } | { field: "dateIndexed"; value: SortOrder } | { field: "object"; value: ObjectOrder }

export type FilePathSearchArgs = { take?: number | null; orderAndPagination?: OrderAndPagination<number, FilePathOrder, FilePathCursor> | null; filters?: SearchFilterArgs[]; groupDirectories?: boolean }

/**
 * Represents the filesystem type of the volume
 */
export type FileSystem = 
/**
 * Windows NTFS filesystem
 */
"NTFS" | 
/**
 * FAT32 filesystem
 */
"FAT32" | 
/**
 * Linux EXT4 filesystem
 */
"EXT4" | 
/**
 * Apple APFS filesystem
 */
"APFS" | 
/**
 * ExFAT filesystem
 */
"ExFAT" | 
/**
 * Other/unknown filesystem type
 */
{ Other: string }

export type Flash = { 
/**
 * Specifies how flash was used (on, auto, off, forced, onvalid)
 * 
 * [`FlashMode::Unknown`] isn't a valid EXIF state, but it's included as the default,
 * just in case we're unable to correctly match it to a known (valid) state.
 * 
 * This type should only ever be evaluated if flash EXIF data is present, so having this as a non-option shouldn't be an issue.
 */
mode: FlashMode; 
/**
 * Did the flash actually fire?
 */
fired: boolean | null; 
/**
 * Did flash return to the camera? (Unsure of the meaning)
 */
returned: boolean | null; 
/**
 * Was red eye reduction used?
 */
red_eye_reduction: boolean | null }

export type FlashMode = 
/**
 * The data is present, but we're unable to determine what they mean
 */
"Unknown" | 
/**
 * `FLash` was on
 */
"On" | 
/**
 * Flash was off
 */
"Off" | 
/**
 * Flash was set to automatically fire in certain conditions
 */
"Auto" | 
/**
 * Flash was forcefully fired
 */
"Forced"

export type FromPattern = { pattern: string; replace_all: boolean }

export type FullRescanArgs = { location_id: number; reidentify_objects: boolean }

export type GenerateThumbsForLocationArgs = { id: number; path: string; regenerate?: boolean }

export type GetAll = { backups: Backup[]; directory: string }

export type HardwareModel = "Other" | "MacStudio" | "MacBookAir" | "MacBookPro" | "MacBook" | "MacMini" | "MacPro" | "IMac" | "IMacPro" | "IPad" | "IPhone" | "Simulator" | "Android"

export type IdentifyUniqueFilesArgs = { id: number; path: string }

export type InOrNotIn<T> = { in: T[] } | { notIn: T[] }

export type IndexerRule = { id: number; pub_id: number[]; name: string | null; default: boolean | null; rules_per_kind: number[] | null; date_created: string | null; date_modified: string | null }

/**
 * `IndexerRuleCreateArgs` is the argument received from the client using rspc to create a new indexer rule.
 * Note that `rules` field is a vector of tuples of `RuleKind` and `parameters`.
 * 
 * In case of  `RuleKind::AcceptFilesByGlob` or `RuleKind::RejectFilesByGlob`, it will be a
 * vector of strings containing a glob patterns.
 * 
 * In case of `RuleKind::AcceptIfChildrenDirectoriesArePresent` or `RuleKind::RejectIfChildrenDirectoriesArePresent` the
 * `parameters` field must be a vector of strings containing the names of the directories.
 */
export type IndexerRuleCreateArgs = { name: string; dry_run: boolean; rules: ([RuleKind, string[]])[] }

export type InvalidateOperationEvent = { type: "single"; data: SingleInvalidateOperationEvent } | { type: "all" }

export type JobGroup = { id: string; running_job_id: string | null; action: string | null; status: Status; created_at: string; jobs: Report[] }

export type JobName = "Indexer" | "FileIdentifier" | "MediaProcessor" | "Copy" | "Move" | "Delete" | "Erase" | "FileValidator"

export type JobProgressEvent = { id: string; library_id: string; task_count: number; completed_task_count: number; phase: string; message: string; info: string; estimated_completion: string }

export type JoinSyncGroupError = "Communication" | "InternalServer" | "Auth"

export type JoinSyncGroupResponse = { Accepted: { authorizor_device: CloudDevice } } | { Failed: CloudP2PError } | "CriticalError"

export type JsonValue = null | boolean | number | string | JsonValue[] | { [key in string]: JsonValue }

export type KindStatistic = { kind: number; name: string; count: [number, number]; total_bytes: [number, number] }

export type KindStatistics = { statistics: { [key in number]: KindStatistic }; total_identified_files: number; total_unidentified_files: number }

export type Label = { id: number; name: string; date_created: string | null; date_modified: string | null }

export type LabelWithObjects = { id: number; name: string; date_created: string | null; date_modified: string | null; label_objects: { object: { id: number; file_paths: FilePath[] } }[] }

/**
 * Can wrap a query argument to require it to contain a `library_id` and provide helpers for working with libraries.
 */
export type LibraryArgs<T> = { library_id: string; arg: T }

/**
 * LibraryConfig holds the configuration for a specific library. This is stored as a '{uuid}.sdlibrary' file.
 */
export type LibraryConfig = { 
/**
 * name is the display name of the library. This is used in the UI and is set by the user.
 */
name: LibraryName; 
/**
 * description is a user set description of the library. This is used in the UI and is set by the user.
 */
description: string | null; 
/**
 * id of the current instance so we know who this `.db` is. This can be looked up within the `Instance` table.
 */
instance_id: number; 
/**
 * cloud_id is the ID of the cloud library this library is linked to.
 * If this is set we can assume the library is synced with the Cloud.
 */
cloud_id?: string | null; generate_sync_operations?: boolean; version: LibraryConfigVersion }

export type LibraryConfigVersion = "V0" | "V1" | "V2" | "V3" | "V4" | "V5" | "V6" | "V7" | "V8" | "V9" | "V10" | "V11"

export type LibraryConfigWrapped = { uuid: string; instance_id: string; instance_public_key: RemoteIdentity; config: LibraryConfig }

export type LibraryName = string

export type LibraryPreferences = { location?: { [key in string]: LocationSettings }; tag?: { [key in string]: TagSettings } }

export type LightScanArgs = { location_id: number; sub_path: string }

export type ListenerState = { type: "Listening" } | { type: "Error"; error: string } | { type: "NotListening" }

export type Listeners = { ipv4: ListenerState; ipv6: ListenerState; relay: ListenerState }

export type Location = { id: number; pub_id: number[]; name: string | null; path: string | null; total_capacity: number | null; available_capacity: number | null; size_in_bytes: number[] | null; is_archived: boolean | null; generate_preview_media: boolean | null; sync_preview_media: boolean | null; hidden: boolean | null; date_created: string | null; scan_state: number; device_id: number | null; instance_id: number | null }

/**
 * `LocationCreateArgs` is the argument received from the client using `rspc` to create a new location.
 * It has the actual path and a vector of indexer rules ids, to create many-to-many relationships
 * between the location and indexer rules.
 */
export type LocationCreateArgs = { path: string; dry_run: boolean; indexer_rules_ids: number[] }

export type LocationSettings = { explorer: ExplorerSettings<FilePathOrder> }

/**
 * `LocationUpdateArgs` is the argument received from the client using `rspc` to update a location.
 * It contains the id of the location to be updated, possible a name to change the current location's name
 * and a vector of indexer rules ids to add or remove from the location.
 * 
 * It is important to note that only the indexer rule ids in this vector will be used from now on.
 * Old rules that aren't in this vector will be purged.
 */
export type LocationUpdateArgs = { id: number; name: string | null; generate_preview_media: boolean | null; sync_preview_media: boolean | null; hidden: boolean | null; indexer_rules_ids: number[]; path: string | null }

export type LocationWithIndexerRule = { id: number; pub_id: number[]; name: string | null; path: string | null; total_capacity: number | null; available_capacity: number | null; size_in_bytes: number[] | null; is_archived: boolean | null; generate_preview_media: boolean | null; sync_preview_media: boolean | null; hidden: boolean | null; date_created: string | null; instance_id: number | null; indexer_rules: IndexerRule[] }

export type MaybeUndefined<T> = null | T

export type MediaData = { Exif: ExifMetadata } | { FFmpeg: FFmpegMetadata }

/**
 * This can be either naive with no TZ (`YYYY-MM-DD HH-MM-SS`) or UTC (`YYYY-MM-DD HH-MM-SS ±HHMM`),
 * where `±HHMM` is the timezone data. It may be negative if West of the Prime Meridian, or positive if East.
 */
export type MediaDate = string

export type MediaLocation = { latitude: number; longitude: number; pluscode: PlusCode; altitude: number | null; direction: number | null }

export type Metadata = { album: string | null; album_artist: string | null; artist: string | null; comment: string | null; composer: string | null; copyright: string | null; creation_time: string | null; date: string | null; disc: number | null; encoder: string | null; encoded_by: string | null; filename: string | null; genre: string | null; language: string | null; performer: string | null; publisher: string | null; service_name: string | null; service_provider: string | null; title: string | null; track: number | null; variant_bit_rate: number | null; custom: { [key in string]: string } }

/**
 * Represents how the volume is mounted in the system
 */
export type MountType = 
/**
 * System/boot volume
 */
"System" | 
/**
 * External/removable volume
 */
"External" | 
/**
 * Network-attached volume
 */
"Network" | 
/**
 * Virtual/container volume
 */
"Virtual" | { Cloud: CloudProvider }

export type NodeConfigP2P = { discovery?: P2PDiscoveryState; port: Port; disabled: boolean; disable_ipv6: boolean; disable_relay: boolean; enable_remote_access: boolean; 
/**
 * A list of peer addresses to try and manually connect to, instead of relying on discovery.
 * 
 * All of these are valid values:
 * - `localhost`
 * - `spacedrive.com` or `spacedrive.com:3000`
 * - `127.0.0.1` or `127.0.0.1:300`
 * - `[::1]` or `[::1]:3000`
 * 
 * which is why we use `String` not `SocketAddr`
 */
manual_peers?: string[] }

export type NodePreferences = Record<string, never>

export type NodeState = ({ 
/**
 * id is a unique identifier for the current node. Each node has a public identifier (this one) and is given a local id for each library (done within the library code).
 */
id: CoreDevicePubId; 
/**
 * name is the display name of the current node. This is set by the user and is shown in the UI. // TODO: Length validation so it can fit in DNS record
 */
name: string; identity: RemoteIdentity; p2p: NodeConfigP2P; features: BackendFeature[]; preferences: NodePreferences; os: DeviceOS; hardware_model: CoreHardwareModel }) & { data_path: string; device_model: string | null; is_in_docker: boolean }

export type NonCriticalError = { indexer: NonCriticalIndexerError } | { file_identifier: NonCriticalFileIdentifierError } | { media_processor: NonCriticalMediaProcessorError }

export type NonCriticalFileIdentifierError = { failed_to_extract_file_metadata: string } | { failed_to_extract_isolated_file_path_data: { file_path_pub_id: string; error: string } } | { file_path_without_is_dir_field: number }

export type NonCriticalIndexerError = { failed_directory_entry: string } | { metadata: string } | { indexer_rule: string } | { file_path_metadata: string } | { fetch_already_existing_file_path_ids: string } | { fetch_file_paths_to_remove: string } | { iso_file_path: string } | { dispatch_keep_walking: string } | { missing_file_path_data: string }

export type NonCriticalMediaDataExtractorError = { FailedToExtractImageMediaData: [string, string] } | { FilePathMissingObjectId: number } | { FailedToConstructIsolatedFilePathData: [number, string] }

export type NonCriticalMediaProcessorError = { media_data_extractor: NonCriticalMediaDataExtractorError } | { thumbnailer: NonCriticalThumbnailerError }

export type NonCriticalThumbnailerError = { MissingCasId: number } | { FailedToExtractIsolatedFilePathData: [number, string] } | { VideoThumbnailGenerationFailed: [string, string] } | { FormatImage: [string, string] } | { WebPEncoding: [string, string] } | { PanicWhileGeneratingThumbnail: [string, string] } | { CreateShardDirectory: string } | { SaveThumbnail: [string, string] } | { TaskTimeout: string }

export type NonIndexedPathItem = { path: string; name: string; extension: string; kind: number; is_dir: boolean; date_created: string; date_modified: string; size_in_bytes_bytes: number[]; hidden: boolean }

/**
 * Represents a single notification.
 */
export type Notification = ({ type: "library"; id: [string, number] } | { type: "node"; id: number }) & { data: NotificationData; read: boolean; expires: string | null }

/**
 * Represents the data of a single notification.
 * This data is used by the frontend to properly display the notification.
 */
export type NotificationData = { title: string; content: string; kind: NotificationKind }

export type NotificationId = { type: "library"; id: [string, number] } | { type: "node"; id: number }

export type NotificationKind = "info" | "success" | "error" | "warning"

export type Object = { id: number; pub_id: number[]; kind: number | null; key_id: number | null; hidden: boolean | null; favorite: boolean | null; important: boolean | null; note: string | null; date_created: string | null; date_accessed: string | null; device_id: number | null }

export type ObjectCursor = "none" | { dateAccessed: CursorOrderItem<string> } | { kind: CursorOrderItem<number> }

export type ObjectFilterArgs = { favorite: boolean } | { hidden: ObjectHiddenFilter } | { kind: InOrNotIn<number> } | { tags: InOrNotIn<number> } | { labels: InOrNotIn<number> } | { dateAccessed: Range<string> }

export type ObjectHiddenFilter = "exclude" | "include"

export type ObjectOrder = { field: "dateAccessed"; value: SortOrder } | { field: "kind"; value: SortOrder } | { field: "mediaData"; value: ExifDataOrder }

export type ObjectSearchArgs = { take: number; orderAndPagination?: OrderAndPagination<number, ObjectOrder, ObjectCursor> | null; filters?: SearchFilterArgs[] }

export type ObjectValidatorArgs = { id: number; path: string }

export type ObjectWithFilePaths = { id: number; pub_id: number[]; kind: number | null; key_id: number | null; hidden: boolean | null; favorite: boolean | null; important: boolean | null; note: string | null; date_created: string | null; date_accessed: string | null; file_paths: ({ id: number; pub_id: number[]; is_dir: boolean | null; cas_id: string | null; integrity_checksum: string | null; location_id: number | null; materialized_path: string | null; name: string | null; extension: string | null; hidden: boolean | null; size_in_bytes: string | null; size_in_bytes_bytes: number[] | null; inode: number[] | null; object_id: number | null; object: { id: number; pub_id: number[]; kind: number | null; key_id: number | null; hidden: boolean | null; favorite: boolean | null; important: boolean | null; note: string | null; date_created: string | null; date_accessed: string | null; exif_data: { resolution: number[] | null; media_date: number[] | null; media_location: number[] | null; camera_data: number[] | null; artist: string | null; description: string | null; copyright: string | null; exif_version: string | null } | null; ffmpeg_data: { id: number; formats: string; bit_rate: number[]; duration: number[] | null; start_time: number[] | null; chapters: FfmpegMediaChapter[]; programs: ({ program_id: number; streams: ({ stream_id: number; name: string | null; codec: { id: number; kind: string | null; sub_kind: string | null; tag: string | null; name: string | null; profile: string | null; bit_rate: number; video_props: FfmpegMediaVideoProps | null; audio_props: FfmpegMediaAudioProps | null; stream_id: number; program_id: number; ffmpeg_data_id: number } | null; aspect_ratio_num: number; aspect_ratio_den: number; frames_per_second_num: number; frames_per_second_den: number; time_base_real_den: number; time_base_real_num: number; dispositions: string | null; title: string | null; encoder: string | null; language: string | null; duration: number[] | null; metadata: number[] | null; program_id: number; ffmpeg_data_id: number })[]; name: string | null; metadata: number[] | null; ffmpeg_data_id: number })[]; title: string | null; creation_time: string | null; date: string | null; album_artist: string | null; disc: string | null; track: string | null; album: string | null; artist: string | null; metadata: number[] | null; object_id: number } | null; device_id: number | null } | null; key_id: number | null; date_created: string | null; date_modified: string | null; date_indexed: string | null; device_id: number | null })[]; device_id: number | null }

export type ObjectWithFilePaths2 = { id: number; pub_id: number[]; kind: number | null; key_id: number | null; hidden: boolean | null; favorite: boolean | null; important: boolean | null; note: string | null; date_created: string | null; date_accessed: string | null; file_paths: ({ id: number; pub_id: number[]; is_dir: boolean | null; cas_id: string | null; integrity_checksum: string | null; location_id: number | null; materialized_path: string | null; name: string | null; extension: string | null; hidden: boolean | null; size_in_bytes: string | null; size_in_bytes_bytes: number[] | null; inode: number[] | null; object_id: number | null; object: { id: number; pub_id: number[]; kind: number | null; key_id: number | null; hidden: boolean | null; favorite: boolean | null; important: boolean | null; note: string | null; date_created: string | null; date_accessed: string | null; exif_data: { resolution: number[] | null; media_date: number[] | null; media_location: number[] | null; camera_data: number[] | null; artist: string | null; description: string | null; copyright: string | null; exif_version: string | null } | null; ffmpeg_data: { id: number; formats: string; bit_rate: number[]; duration: number[] | null; start_time: number[] | null; chapters: FfmpegMediaChapter[]; programs: ({ program_id: number; streams: ({ stream_id: number; name: string | null; codec: { id: number; kind: string | null; sub_kind: string | null; tag: string | null; name: string | null; profile: string | null; bit_rate: number; video_props: FfmpegMediaVideoProps | null; audio_props: FfmpegMediaAudioProps | null; stream_id: number; program_id: number; ffmpeg_data_id: number } | null; aspect_ratio_num: number; aspect_ratio_den: number; frames_per_second_num: number; frames_per_second_den: number; time_base_real_den: number; time_base_real_num: number; dispositions: string | null; title: string | null; encoder: string | null; language: string | null; duration: number[] | null; metadata: number[] | null; program_id: number; ffmpeg_data_id: number })[]; name: string | null; metadata: number[] | null; ffmpeg_data_id: number })[]; title: string | null; creation_time: string | null; date: string | null; album_artist: string | null; disc: string | null; track: string | null; album: string | null; artist: string | null; metadata: number[] | null; object_id: number } | null; device_id: number | null } | null; key_id: number | null; date_created: string | null; date_modified: string | null; date_indexed: string | null; device_id: number | null })[] }

export type OldFileCopierJobInit = { source_location_id: number; target_location_id: number; sources_file_path_ids: number[]; target_location_relative_directory_path: string }

export type OldFileCutterJobInit = { source_location_id: number; target_location_id: number; sources_file_path_ids: number[]; target_location_relative_directory_path: string }

export type OldFileDeleterJobInit = { location_id: number; file_path_ids: number[] }

export type OldFileEraserJobInit = { location_id: number; file_path_ids: number[]; passes: string }

/**
 * Represents the operating system which the remote peer is running.
 * This is not used internally and predominantly is designed to be used for display purposes by the embedding application.
 */
export type OperatingSystem = "Windows" | "Linux" | "MacOS" | "Ios" | "Android" | { Other: string }

export type OrderAndPagination<TId, TOrder, TCursor> = { orderOnly: TOrder } | { offset: { offset: number; order: TOrder | null } } | { cursor: { id: TId; cursor: TCursor } }

export type Orientation = "Normal" | "CW90" | "CW180" | "CW270" | "MirroredVertical" | "MirroredHorizontal" | "MirroredHorizontalAnd90CW" | "MirroredHorizontalAnd270CW"

export type P2PDiscoveryState = "Everyone" | "ContactsOnly" | "Disabled"

export type P2PEvent = { type: "PeerChange"; identity: RemoteIdentity; connection: ConnectionMethod; discovery: DiscoveryMethod; metadata: PeerMetadata; addrs: string[] } | { type: "PeerDelete"; identity: RemoteIdentity } | { type: "SpacedropRequest"; id: string; identity: RemoteIdentity; peer_name: string; files: string[] } | { type: "SpacedropProgress"; id: string; percent: number } | { type: "SpacedropTimedOut"; id: string } | { type: "SpacedropRejected"; id: string }

export type PeerMetadata = { name: string; operating_system: OperatingSystem | null; device_model: CoreHardwareModel | null; version: string | null }

export type PlusCode = string

export type Port = { type: "random" } | { type: "discrete"; value: number }

export type Program = { id: number; name: string | null; streams: Stream[]; metadata: Metadata }

export type Props = { Video: VideoProps } | { Audio: AudioProps } | { Subtitle: SubtitleProps }

export type Range<T> = { from: T } | { to: T }

/**
 * Newtype wrapper for the refresh token
 */
export type RefreshToken = string

export type RemoteIdentity = string

export type RenameFileArgs = { location_id: number; kind: RenameKind }

export type RenameKind = { One: RenameOne } | { Many: RenameMany }

export type RenameMany = { from_pattern: FromPattern; to_pattern: string; from_file_path_ids: number[] }

export type RenameOne = { from_file_path_id: number; to: string }

export type Report = { id: string; name: JobName; action: string | null; metadata: ReportMetadata[]; critical_error: string | null; non_critical_errors: NonCriticalError[]; created_at: string | null; started_at: string | null; completed_at: string | null; parent_id: string | null; status: Status; task_count: number; completed_task_count: number; info: string; phase: string; message: string; estimated_completion: string }

export type ReportInputMetadata = { type: "location"; data: Location } | { type: "sub_path"; data: string }

export type ReportMetadata = { type: "input"; metadata: ReportInputMetadata } | { type: "output"; metadata: ReportOutputMetadata }

export type ReportOutputMetadata = { type: "metrics"; data: { [key in string]: JsonValue } } | { type: "indexer"; data: { total_paths: [number, number] } } | { type: "file_identifier"; data: { total_orphan_paths: [number, number]; total_objects_created: [number, number]; total_objects_linked: [number, number] } } | { type: "media_processor"; data: { media_data_extracted: [number, number]; media_data_skipped: [number, number]; thumbnails_generated: [number, number]; thumbnails_skipped: [number, number] } } | { type: "copier"; data: { source_location_id: number; target_location_id: number; sources_file_path_ids: number[]; target_location_relative_directory_path: string } } | { type: "mover"; data: { source_location_id: number; target_location_id: number; sources_file_path_ids: number[]; target_location_relative_directory_path: string } } | { type: "deleter"; data: { location_id: number; file_path_ids: number[] } } | { type: "eraser"; data: { location_id: number; file_path_ids: number[]; passes: number } } | { type: "file_validator"; data: { location_id: number; sub_path: string | null } }

export type RescanArgs = { location_id: number; sub_path: string }

export type Resolution = { width: number; height: number }

export type RuleKind = "AcceptFilesByGlob" | "RejectFilesByGlob" | "AcceptIfChildrenDirectoriesArePresent" | "RejectIfChildrenDirectoriesArePresent" | "IgnoredByGit"

export type SavedSearch = { id: number; pub_id: number[]; target: string | null; search: string | null; filters: string | null; name: string | null; icon: string | null; description: string | null; date_created: string | null; date_modified: string | null }

export type SearchData<T> = { cursor: number[] | null; items: T[] }

export type SearchFilterArgs = { filePath: FilePathFilterArgs } | { object: ObjectFilterArgs }

export type SearchTarget = "paths" | "objects"

export type SetFavoriteArgs = { id: number; favorite: boolean }

export type SetNoteArgs = { id: number; note: string | null }

export type SingleInvalidateOperationEvent = { 
/**
 * This fields are intentionally private.
 */
key: string; arg: JsonValue; result: JsonValue | null }

export type SortOrder = "Asc" | "Desc"

export type SpacedropArgs = { identity: RemoteIdentity; file_path: string[] }

export type Statistics = { id: number; date_captured: string; total_object_count: number; library_db_size: string; total_local_bytes_used: string; total_local_bytes_capacity: string; total_local_bytes_free: string; total_library_bytes: string; total_library_unique_bytes: string; total_library_preview_media_bytes: string }

export type StatisticsResponse = { statistics: Statistics | null }

export type Status = "Queued" | "Running" | "Completed" | "Canceled" | "Failed" | "Paused" | "CompletedWithErrors"

export type Stream = { id: number; name: string | null; codec: Codec | null; aspect_ratio_num: number; aspect_ratio_den: number; frames_per_second_num: number; frames_per_second_den: number; time_base_real_den: number; time_base_real_num: number; dispositions: string[]; metadata: Metadata }

export type SubtitleProps = { width: number; height: number }

export type SyncGroupsRequestJoinArgs = { sync_group: CloudSyncGroupWithDevices; asking_device: CloudDevice }

export type SyncStatus = { ingest: boolean; cloud_send: boolean; cloud_receive: boolean; cloud_ingest: boolean }

export type SystemLocations = { desktop: string | null; documents: string | null; downloads: string | null; pictures: string | null; music: string | null; videos: string | null }

export type Tag = { id: number; pub_id: number[]; name: string | null; color: string | null; is_hidden: boolean | null; date_created: string | null; date_modified: string | null }

export type TagCreateArgs = { name: string; color: string }

export type TagSettings = { explorer: ExplorerSettings<ObjectOrder> }

export type TagUpdateArgs = { id: number; name: string | null; color: string | null }

export type Target = { Object: number } | { FilePath: number }

export type TextMatch = { contains: string } | { startsWith: string } | { endsWith: string } | { equals: string }

/**
 * This type is used to pass the relevant data to the frontend so it can request the thumbnail.
 * Tt supports extending the shard hex to support deeper directory structures in the future
 */
export type ThumbKey = { shard_hex: string; cas_id: CasId; base_directory_str: string }

export type UpdateThumbnailerPreferences = Record<string, never>

export type VideoProps = { pixel_format: string | null; color_range: string | null; bits_per_channel: number | null; color_space: string | null; color_primaries: string | null; color_transfer: string | null; field_order: string | null; chroma_location: string | null; width: number; height: number; aspect_ratio_num: number | null; aspect_ratio_den: number | null; properties: string[] }

/**
 * Represents a physical or virtual storage volume in the system
 */
export type Volume = { 
/**
 * Fingerprint of the volume as a hash of its properties, not persisted to the database
 * Used as the unique identifier for a volume in this module
 */
fingerprint: VolumeFingerprint | null; 
/**
 * Database ID (None if not yet committed to database)
 */
id: number | null; 
/**
 * Unique public identifier
 */
pub_id: number[] | null; 
/**
 * Database ID of the device this volume is attached to, if any
 */
device_id: number | null; 
/**
 * Human-readable volume name
 */
name: string; 
/**
 * Type of mount (system, external, etc)
 */
mount_type: MountType; 
/**
 * Path where the volume is mounted
 */
mount_point: string[]; 
/**
 * for APFS volumes like Macintosh HD, additional mount points are returned
 */
mount_points: string[]; 
/**
 * Whether the volume is currently mounted
 */
is_mounted: boolean; 
/**
 * Type of storage device (SSD, HDD, etc)
 */
disk_type: DiskType; 
/**
 * Filesystem type (NTFS, EXT4, etc)
 */
file_system: FileSystem; 
/**
 * Whether the volume is mounted read-only
 */
read_only: boolean; 
/**
 * Current error status if any
 */
error_status: string | null; 
/**
 * Read speed in megabytes per second
 */
read_speed_mbps: bigint | null; 
/**
 * Write speed in megabytes per second
 */
write_speed_mbps: bigint | null; 
/**
 * Total storage capacity in bytes
 */
total_bytes_capacity: string; 
/**
 * Available storage space in bytes
 */
total_bytes_available: string }

/**
 * Events emitted by the Volume Manager when volume state changes
 */
export type VolumeEvent = 
/**
 * Emitted when a new volume is discovered and added
 */
{ VolumeAdded: Volume } | 
/**
 * Emitted when a volume is removed from the system
 */
{ VolumeRemoved: Volume } | 
/**
 * Emitted when a volume's properties are updated
 */
{ VolumeUpdated: { old: Volume; new: Volume } } | 
/**
 * Emitted when a volume's speed test completes
 */
{ VolumeSpeedTested: { fingerprint: VolumeFingerprint; read_speed: bigint; write_speed: bigint } } | 
/**
 * Emitted when a volume's mount status changes
 */
{ VolumeMountChanged: { fingerprint: VolumeFingerprint; is_mounted: boolean } } | 
/**
 * Emitted when a volume encounters an error
 */
{ VolumeError: { fingerprint: VolumeFingerprint; error: string } }

/**
 * A fingerprint of a volume, used to identify it when it is not persisted in the database
 */
export type VolumeFingerprint = number[]
