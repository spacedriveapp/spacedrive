// Generated by Spacedrive using Specta + rspc-inspired type extraction - DO NOT EDIT
// This file is auto-generated. See core/src/bin/generate_typescript_types.rs

// This file has been generated by Specta. DO NOT EDIT.

export type ActionContextInfo = { action_type: string; initiated_at: string; initiated_by: string | null; action_input: JsonValue; context: JsonValue };

/**
 * Represents an APFS container (physical storage with multiple volumes)
 */
export type ApfsContainer = { container_id: string; uuid: string; physical_store: string; total_capacity: number; capacity_in_use: number; capacity_free: number; volumes: ApfsVolumeInfo[] };

/**
 * APFS volume information within a container
 */
export type ApfsVolumeInfo = { disk_id: string; uuid: string; role: ApfsVolumeRole; name: string; mount_point: string | null; capacity_consumed: number; sealed: boolean; filevault: boolean };

/**
 * APFS volume roles in the container
 */
export type ApfsVolumeRole = "System" | "Data" | "Preboot" | "Recovery" | "VM" | { Other: string };

export type ApplyTagsInput = { 
/**
 * Entry IDs to apply tags to
 */
entry_ids: number[]; 
/**
 * Tag IDs to apply
 */
tag_ids: string[]; 
/**
 * Source of the tag application
 */
source: TagSource | null; 
/**
 * Confidence score (for AI-applied tags)
 */
confidence: number | null; 
/**
 * Context when applying (e.g., "image_analysis", "user_input")
 */
applied_context: string | null; 
/**
 * Instance-specific attributes for this application
 */
instance_attributes: { [key in string]: JsonValue } | null };

export type ApplyTagsOutput = { 
/**
 * Number of entries that had tags applied
 */
entries_affected: number; 
/**
 * Number of tags that were applied
 */
tags_applied: number; 
/**
 * Tag IDs that were successfully applied
 */
applied_tag_ids: string[]; 
/**
 * Entry IDs that were successfully tagged
 */
tagged_entry_ids: number[]; 
/**
 * Any warnings or notes about the operation
 */
warnings: string[]; 
/**
 * Success message
 */
message: string };

/**
 * Cloud service type identifier
 */
export type CloudServiceType = "s3" | "gdrive" | "dropbox" | "onedrive" | "gcs" | "azblob" | "b2" | "wasabi" | "spaces" | "cloud";

export type CloudStorageConfig = { type: "S3"; bucket: string; region: string; access_key_id: string; secret_access_key: string; endpoint: string | null } | { type: "GoogleDrive"; root: string | null; access_token: string; refresh_token: string; client_id: string; client_secret: string } | { type: "OneDrive"; root: string | null; access_token: string; refresh_token: string; client_id: string; client_secret: string } | { type: "Dropbox"; root: string | null; access_token: string; refresh_token: string; client_id: string; client_secret: string } | { type: "AzureBlob"; container: string; endpoint: string | null; account_name: string; account_key: string } | { type: "GoogleCloudStorage"; bucket: string; root: string | null; endpoint: string | null; credential: string };

/**
 * Operators for combining tag attributes
 */
export type CompositionOperator = 
/**
 * All conditions must be true
 */
"And" | 
/**
 * Any condition must be true
 */
"Or" | 
/**
 * Must have this property
 */
"With" | 
/**
 * Must not have this property
 */
"Without";

/**
 * Rules for composing attributes from multiple tags
 */
export type CompositionRule = { operator: CompositionOperator; operands: string[]; result_attribute: string };

/**
 * Domain representation of content identity
 */
export type ContentIdentity = { uuid: string; kind: ContentKind; content_hash: string; integrity_hash: string | null; mime_type_id: number | null; text_content: string | null; total_size: number; entry_count: number; first_seen_at: string; last_verified_at: string };

/**
 * Type of content
 */
export type ContentKind = "unknown" | "image" | "video" | "audio" | "document" | "archive" | "code" | "text" | "database" | "book" | "font" | "mesh" | "config" | "encrypted" | "key" | "executable" | "binary" | "spreadsheet" | "presentation" | "email" | "calendar" | "contact" | "web" | "shortcut" | "package" | "model_entry";

/**
 * Copy method preference for file operations
 */
export type CopyMethod = 
/**
 * Automatically select the best method based on source and destination
 */
"Auto" | 
/**
 * Use atomic operations (rename for moves, APFS clone for copies, etc.)
 */
"Atomic" | 
/**
 * Use streaming copy/move (works across all scenarios)
 */
"Streaming";

export type CoreStatus = { version: string; built_at: string; library_count: number; device_info: DeviceInfo; libraries: LibraryInfo[]; services: ServiceStatus; network: NetworkStatus; system: SystemInfo };

export type CreateTagInput = { 
/**
 * The canonical name for this tag
 */
canonical_name: string; 
/**
 * Optional display name (if different from canonical)
 */
display_name: string | null; 
/**
 * Semantic variants
 */
formal_name: string | null; abbreviation: string | null; aliases: string[]; 
/**
 * Context and categorization
 */
namespace: string | null; tag_type: TagType | null; 
/**
 * Visual properties
 */
color: string | null; icon: string | null; description: string | null; 
/**
 * Advanced capabilities
 */
is_organizational_anchor: boolean | null; privacy_level: PrivacyLevel | null; search_weight: number | null; 
/**
 * Initial attributes
 */
attributes: { [key in string]: JsonValue } | null };

export type CreateTagOutput = { 
/**
 * The created tag's UUID
 */
tag_id: string; 
/**
 * The canonical name of the created tag
 */
canonical_name: string; 
/**
 * The namespace if specified
 */
namespace: string | null; 
/**
 * Success message
 */
message: string };

/**
 * Data volume metrics snapshot
 */
export type DataVolumeSnapshot = { entries_synced: { [key in string]: number }; entries_by_device: { [key in string]: DeviceMetricsSnapshot }; bytes_sent: number; bytes_received: number; last_sync_per_peer: { [key in string]: string }; last_sync_per_model: { [key in string]: string } };

/**
 * Time-based fields that can be filtered
 */
export type DateField = "CreatedAt" | "ModifiedAt" | "AccessedAt";

/**
 * Filter for a time-based field
 */
export type DateRangeFilter = { field: DateField; start: string | null; end: string | null };

export type DeviceInfo = { id: string; name: string; os: string; hardware_model: string | null; created_at: string };

/**
 * Device metrics snapshot
 */
export type DeviceMetricsSnapshot = { device_id: string; device_name: string; entries_received: number; last_seen: string; is_online: boolean };

export type DeviceRevokeInput = { device_id: string };

export type DeviceRevokeOutput = { revoked: boolean };

/**
 * Device sync state for state machine
 */
export type DeviceSyncState = 
/**
 * Not yet synced, no backfill started
 */
"Uninitialized" | 
/**
 * Currently backfilling from peer(s)
 * Buffers all live updates during this phase
 */
{ Backfilling: { peer: string; progress: number } } | 
/**
 * Backfill complete, processing buffered updates
 * Still buffers new updates while catching up
 */
{ CatchingUp: { buffered_count: number } } | 
/**
 * Fully synced, applying live updates immediately
 */
"Ready" | 
/**
 * Sync paused (offline or user disabled)
 */
"Paused";

/**
 * Input for directory listing
 */
export type DirectoryListingInput = { 
/**
 * The directory path to list contents for
 */
path: SdPath; 
/**
 * Optional limit on number of results (default: 1000)
 */
limit: number | null; 
/**
 * Whether to include hidden files (default: false)
 */
include_hidden: boolean | null; 
/**
 * Sort order for results
 */
sort_by: DirectorySortBy };

/**
 * Output containing directory contents
 */
export type DirectoryListingOutput = { 
/**
 * Direct children of the directory as File objects
 */
files: File[]; 
/**
 * Total count of direct children
 */
total_count: number; 
/**
 * Whether this directory has more children than returned
 */
has_more: boolean };

/**
 * Sort options for directory listing
 */
export type DirectorySortBy = 
/**
 * Sort by name (alphabetical)
 */
"name" | 
/**
 * Sort by modification date (newest first)
 */
"modified" | 
/**
 * Sort by size (largest first)
 */
"size" | 
/**
 * Sort by type (directories first, then files)
 */
"type";

export type DiscoverRemoteLibrariesInput = { 
/**
 * Device ID to query for libraries
 */
deviceId: string };

/**
 * Output from discovering remote libraries
 */
export type DiscoverRemoteLibrariesOutput = { 
/**
 * Remote device ID that was queried
 */
deviceId: string; 
/**
 * Remote device name
 */
deviceName: string; 
/**
 * List of libraries available on the remote device
 */
libraries: RemoteLibraryInfo[]; 
/**
 * Whether the device is currently online
 */
isOnline: boolean };

/**
 * Disk type classification
 */
export type DiskType = 
/**
 * Solid State Drive
 */
"SSD" | 
/**
 * Hard Disk Drive
 */
"HDD" | 
/**
 * Network storage
 */
"Network" | 
/**
 * Virtual/RAM disk
 */
"Virtual" | 
/**
 * Unknown type
 */
"Unknown";

/**
 * Type of filesystem entry
 */
export type EntryKind = 
/**
 * Regular file
 */
{ File: { 
/**
 * File extension (without dot)
 */
extension: string | null } } | 
/**
 * Directory
 */
"Directory" | 
/**
 * Symbolic link
 */
{ Symlink: { 
/**
 * Target path
 */
target: string } };

/**
 * Error event for tracking recent errors
 */
export type ErrorEvent = { timestamp: string; error_type: string; message: string; model_type: string | null; device_id: string | null };

/**
 * Error metrics snapshot
 */
export type ErrorSnapshot = { total_errors: number; network_errors: number; database_errors: number; apply_errors: number; validation_errors: number; recent_errors: ErrorEvent[]; conflicts_detected: number; conflicts_resolved_by_hlc: number };

/**
 * A central event type that represents all events that can be emitted throughout the system
 */
export type Event = "CoreStarted" | "CoreShutdown" | { LibraryCreated: { id: string; name: string; path: string } } | { LibraryOpened: { id: string; name: string; path: string } } | { LibraryClosed: { id: string; name: string } } | { LibraryDeleted: { id: string; name: string; deleted_data: boolean } } | { LibraryStatisticsUpdated: { library_id: string; statistics: LibraryStatistics } } | { EntryCreated: { library_id: string; entry_id: string } } | { EntryModified: { library_id: string; entry_id: string } } | { EntryDeleted: { library_id: string; entry_id: string } } | { EntryMoved: { library_id: string; entry_id: string; old_path: string; new_path: string } } | { FsRawChange: { library_id: string; kind: FsRawEventKind } } | { VolumeAdded: Volume } | { VolumeRemoved: { fingerprint: VolumeFingerprint } } | { VolumeUpdated: { fingerprint: VolumeFingerprint; old_info: VolumeInfo; new_info: VolumeInfo } } | { VolumeSpeedTested: { fingerprint: VolumeFingerprint; read_speed_mbps: number; write_speed_mbps: number } } | { VolumeMountChanged: { fingerprint: VolumeFingerprint; is_mounted: boolean } } | { VolumeError: { fingerprint: VolumeFingerprint; error: string } } | { JobQueued: { job_id: string; job_type: string } } | { JobStarted: { job_id: string; job_type: string } } | { JobProgress: { job_id: string; job_type: string; progress: number; message: string | null; generic_progress: GenericProgress | null } } | { JobCompleted: { job_id: string; job_type: string; output: JobOutput } } | { JobFailed: { job_id: string; job_type: string; error: string } } | { JobCancelled: { job_id: string; job_type: string } } | { JobPaused: { job_id: string } } | { JobResumed: { job_id: string } } | { IndexingStarted: { location_id: string } } | { IndexingProgress: { location_id: string; processed: number; total: number | null } } | { IndexingCompleted: { location_id: string; total_files: number; total_dirs: number } } | { IndexingFailed: { location_id: string; error: string } } | { DeviceConnected: { device_id: string; device_name: string } } | { DeviceDisconnected: { device_id: string } } | { ResourceChanged: { 
/**
 * Resource type identifier (e.g., "location", "tag", "album")
 */
resource_type: string; 
/**
 * The full resource data as JSON
 */
resource: JsonValue } } | { ResourceChangedBatch: { 
/**
 * Resource type identifier (e.g., "file")
 */
resource_type: string; 
/**
 * Array of full resource data as JSON
 * Used for batch updates during indexing to reduce event overhead
 */
resources: JsonValue } } | { ResourceDeleted: { 
/**
 * Resource type identifier
 */
resource_type: string; 
/**
 * The deleted resource's ID
 */
resource_id: string } } | { LocationAdded: { library_id: string; location_id: string; path: string } } | { LocationRemoved: { library_id: string; location_id: string } } | { FilesIndexed: { library_id: string; location_id: string; count: number } } | { ThumbnailsGenerated: { library_id: string; count: number } } | { FileOperationCompleted: { library_id: string; operation: FileOperation; affected_files: number } } | { FilesModified: { library_id: string; paths: string[] } } | { LogMessage: { timestamp: string; level: string; target: string; message: string; job_id: string | null; library_id: string | null } } | { Custom: { event_type: string } };

export type EventInfo = { 
/**
 * The event variant name (e.g., "JobProgress", "LibraryCreated")
 */
variant: string; 
/**
 * Whether this event is considered "noisy" (high frequency, should be excluded by default)
 */
is_noisy: boolean; 
/**
 * Human-readable description
 */
description: string };

/**
 * Represents a file within the Spacedrive VDFS.
 * 
 * This is a computed domain model that aggregates data from Entry, ContentIdentity,
 * Tags, and Sidecars. It provides a rich, developer-friendly interface without
 * duplicating data in the database.
 */
export type File = { 
/**
 * The unique identifier of the file entry
 */
id: string; 
/**
 * The universal path to the file in Spacedrive's VDFS
 */
sd_path: SdPath; 
/**
 * The name of the file, including the extension
 */
name: string; 
/**
 * The size of the file in bytes
 */
size: number; 
/**
 * Information about the file's content, including its content hash
 */
content_identity: ContentIdentity | null; 
/**
 * A list of other paths that share the same content identity
 */
alternate_paths: SdPath[]; 
/**
 * The semantic tags associated with this file
 */
tags: Tag[]; 
/**
 * A list of sidecars associated with this file
 */
sidecars: Sidecar[]; 
/**
 * Timestamps for creation, modification, and access
 */
created_at: string; modified_at: string; accessed_at: string | null; 
/**
 * Additional computed fields
 */
content_kind: ContentKind; extension: string | null; kind: EntryKind; is_local: boolean };

/**
 * Query to get a file by its ID with all related data
 */
export type FileByIdQuery = { file_id: string };

/**
 * Query to get a file by its local path with all related data
 */
export type FileByPathQuery = { path: string };

/**
 * Internal enum for file conflict resolution strategies
 */
export type FileConflictResolution = "Overwrite" | "AutoModifyName" | "Abort";

/**
 * Core input structure for file copy operations
 * This is the canonical interface that all external APIs (CLI, REST) convert to
 */
export type FileCopyInput = { 
/**
 * Source files or directories to copy (domain addressing)
 */
sources: SdPathBatch; 
/**
 * Destination path (domain addressing)
 */
destination: SdPath; 
/**
 * Whether to overwrite existing files
 */
overwrite: boolean; 
/**
 * Whether to verify checksums during copy
 */
verify_checksum: boolean; 
/**
 * Whether to preserve file timestamps
 */
preserve_timestamps: boolean; 
/**
 * Whether to delete source files after copying (move operation)
 */
move_files: boolean; 
/**
 * Preferred copy method to use
 */
copy_method: CopyMethod; 
/**
 * How to handle file conflicts (set by CLI confirmation)
 */
on_conflict: FileConflictResolution | null };

/**
 * Input for deleting files
 */
export type FileDeleteInput = { 
/**
 * Files or directories to delete
 */
targets: SdPathBatch; 
/**
 * Whether to permanently delete (true) or move to trash (false)
 */
permanent: boolean; 
/**
 * Whether to delete directories recursively
 */
recursive: boolean };

/**
 * Types of file operations
 */
export type FileOperation = "Copy" | "Move" | "Delete" | "Rename";

/**
 * Main input structure for file search operations
 */
export type FileSearchInput = { 
/**
 * Primary search query (filename, content, or natural language)
 */
query: string; 
/**
 * Search scope (library, location, or specific path)
 */
scope: SearchScope; 
/**
 * Search mode (fast, normal, full)
 */
mode: SearchMode; 
/**
 * Filters to narrow results
 */
filters: SearchFilters; 
/**
 * Sorting options
 */
sort: SortOptions; 
/**
 * Pagination
 */
pagination: PaginationOptions };

/**
 * Main output structure for file search operations
 */
export type FileSearchOutput = { results: FileSearchResult[]; total_found: number; search_id: string; facets: SearchFacets; suggestions: string[]; pagination: PaginationInfo; execution_time_ms: number };

/**
 * Individual search result
 */
export type FileSearchResult = { file: File; score: number; score_breakdown: ScoreBreakdown; highlights: TextHighlight[]; matched_content: string | null };

/**
 * Filesystem type
 */
export type FileSystem = 
/**
 * Apple File System
 */
"APFS" | 
/**
 * NT File System (Windows)
 */
"NTFS" | 
/**
 * Fourth Extended Filesystem (Linux)
 */
"Ext4" | 
/**
 * B-tree Filesystem (Linux)
 */
"Btrfs" | 
/**
 * ZFS
 */
"ZFS" | 
/**
 * Resilient File System (Windows)
 */
"ReFS" | 
/**
 * File Allocation Table 32
 */
"FAT32" | 
/**
 * Extended File Allocation Table
 */
"ExFAT" | 
/**
 * Hierarchical File System Plus (macOS legacy)
 */
"HFSPlus" | 
/**
 * Network File System
 */
"NFS" | 
/**
 * Server Message Block
 */
"SMB" | 
/**
 * Other filesystem
 */
{ Other: string };

/**
 * Raw filesystem event kinds emitted by the watcher without DB resolution
 */
export type FsRawEventKind = { Create: { path: string } } | { Modify: { path: string } } | { Remove: { path: string } } | { Rename: { from: string; to: string } };

/**
 * Generic progress information that all job types can convert into
 */
export type GenericProgress = { 
/**
 * Current progress as a percentage (0.0 to 1.0)
 */
percentage: number; 
/**
 * Current phase or stage name (e.g., "Discovery", "Processing", "Finalizing")
 */
phase: string; 
/**
 * Current path being processed (if applicable)
 */
current_path: SdPath | null; 
/**
 * Human-readable message describing current activity
 */
message: string; 
/**
 * Completion metrics
 */
completion: ProgressCompletion; 
/**
 * Performance metrics
 */
performance: PerformanceMetrics };

export type GetSyncMetricsInput = { 
/**
 * Filter metrics since this time
 */
since: string | null; 
/**
 * Filter metrics for specific peer device
 */
peer_id: string | null; 
/**
 * Filter metrics for specific model type
 */
model_type: string | null; 
/**
 * Show only state metrics
 */
state_only: boolean | null; 
/**
 * Show only operation metrics
 */
operations_only: boolean | null; 
/**
 * Show only error metrics
 */
errors_only: boolean | null };

export type GetSyncMetricsOutput = { 
/**
 * The metrics snapshot
 */
metrics: SyncMetricsSnapshot };

/**
 * Canonical input for indexing requests from any interface (CLI, API, etc.)
 */
export type IndexInput = { 
/**
 * The library within which the operation runs
 */
library_id: string; 
/**
 * One or more filesystem paths to index
 */
paths: string[]; 
/**
 * Indexing scope (current directory only vs recursive)
 */
scope: IndexScope; 
/**
 * Indexing mode (shallow/content/deep)
 */
mode: IndexMode; 
/**
 * Whether to include hidden files/directories
 */
include_hidden: boolean; 
/**
 * Where results are stored (ephemeral vs persistent)
 */
persistence: IndexPersistence };

/**
 * Indexing mode determines the depth of indexing
 */
export type IndexMode = 
/**
 * Just filesystem metadata (fastest)
 */
"Shallow" | 
/**
 * Generate content identities (moderate)
 */
"Content" | 
/**
 * Full indexing with thumbnails and text extraction (slowest)
 */
"Deep";

/**
 * Determines whether indexing results are persisted to database or kept in memory
 */
export type IndexPersistence = 
/**
 * Write all results to database (normal operation)
 */
"Persistent" | 
/**
 * Keep results in memory only (for unmanaged paths)
 */
"Ephemeral";

/**
 * Indexing scope determines how much of the directory tree to process
 */
export type IndexScope = 
/**
 * Index only the current directory (single level)
 */
"Current" | 
/**
 * Index recursively through all subdirectories
 */
"Recursive";

export type IndexVerifyInput = { 
/**
 * Path to verify (can be a location root or subdirectory)
 */
path: string; 
/**
 * Whether to check content hashes (slower but more thorough)
 */
verify_content?: boolean; 
/**
 * Whether to include detailed file-by-file comparison
 */
detailed_report?: boolean; 
/**
 * Whether to fix issues automatically (future feature)
 */
auto_fix?: boolean };

/**
 * Result of index integrity verification
 */
export type IndexVerifyOutput = { 
/**
 * Overall integrity status
 */
is_valid: boolean; 
/**
 * Integrity report with detailed findings
 */
report: IntegrityReport; 
/**
 * Path that was verified
 */
path: string; 
/**
 * Time taken to verify (seconds)
 */
duration_secs: number };

/**
 * Comprehensive metrics for indexing operations
 */
export type IndexerMetrics = { total_duration: { secs: number; nanos: number }; discovery_duration: { secs: number; nanos: number }; processing_duration: { secs: number; nanos: number }; content_duration: { secs: number; nanos: number }; files_per_second: number; bytes_per_second: number; dirs_per_second: number; db_writes: number; db_reads: number; batch_count: number; avg_batch_size: number; total_errors: number; critical_errors: number; non_critical_errors: number; skipped_paths: number; peak_memory_bytes: number | null; avg_memory_bytes: number | null };

/**
 * Indexer settings controlling rule toggles
 */
export type IndexerSettings = { no_system_files?: boolean; no_git?: boolean; no_dev_dirs?: boolean; no_hidden?: boolean; gitignore?: boolean; only_images?: boolean };

/**
 * Statistics collected during indexing
 */
export type IndexerStats = { files: number; dirs: number; bytes: number; symlinks: number; skipped: number; errors: number };

/**
 * Represents a single integrity difference
 */
export type IntegrityDifference = { 
/**
 * Path relative to verification root
 */
path: string; 
/**
 * Type of issue
 */
issue_type: IssueType; 
/**
 * Expected value (from filesystem or correct state)
 */
expected: string | null; 
/**
 * Actual value (from database)
 */
actual: string | null; 
/**
 * Human-readable description
 */
description: string; 
/**
 * Debug: database entry ID for investigation
 */
db_entry_id?: number | null; 
/**
 * Debug: database entry name
 */
db_entry_name?: string | null };

/**
 * Detailed integrity report
 */
export type IntegrityReport = { 
/**
 * Total files found on filesystem
 */
filesystem_file_count: number; 
/**
 * Total files in database index
 */
database_file_count: number; 
/**
 * Total directories found on filesystem
 */
filesystem_dir_count: number; 
/**
 * Total directories in database index
 */
database_dir_count: number; 
/**
 * Files missing from index (on filesystem but not in DB)
 */
missing_from_index: IntegrityDifference[]; 
/**
 * Stale entries in index (in DB but not on filesystem)
 */
stale_in_index: IntegrityDifference[]; 
/**
 * Entries with incorrect metadata
 */
metadata_mismatches: IntegrityDifference[]; 
/**
 * Entries with incorrect parent relationships
 */
hierarchy_errors: IntegrityDifference[]; 
/**
 * Summary statistics
 */
summary: string };

export type IssueType = { type: "MissingFromIndex" } | { type: "StaleInIndex" } | { type: "SizeMismatch" } | { type: "ModifiedTimeMismatch" } | { type: "InodeMismatch" } | { type: "ExtensionMismatch" } | { type: "ParentMismatch" } | { type: "KindMismatch" };

export type JobCancelInput = { job_id: string };

export type JobCancelOutput = { job_id: string; success: boolean };

/**
 * Unique identifier for a job
 */
export type JobId = string;

export type JobInfoOutput = { id: string; name: string; status: JobStatus; progress: number; started_at: string; completed_at: string | null; error_message: string | null };

export type JobInfoQueryInput = { job_id: string };

export type JobListInput = { status: JobStatus | null };

export type JobListItem = { id: string; name: string; status: JobStatus; progress: number; action_type: string | null; action_context: ActionContextInfo | null };

export type JobListOutput = { jobs: JobListItem[] };

/**
 * Output from a completed job
 */
export type JobOutput = 
/**
 * Job completed successfully with no specific output
 */
{ type: "Success" } | 
/**
 * File copy job output
 */
{ type: "FileCopy"; data: { copied_count: number; total_bytes: number } } | 
/**
 * Indexer job output
 */
{ type: "Indexed"; data: { stats: IndexerStats; metrics: IndexerMetrics } } | 
/**
 * Thumbnail generation output
 */
{ type: "ThumbnailsGenerated"; data: { generated_count: number; failed_count: number } } | 
/**
 * Thumbnail generation output (detailed)
 */
{ type: "ThumbnailGeneration"; data: { generated_count: number; skipped_count: number; error_count: number; total_size_bytes: number } } | 
/**
 * File move/rename operation output
 */
{ type: "FileMove"; data: { moved_count: number; failed_count: number; total_bytes: number } } | 
/**
 * File delete operation output
 */
{ type: "FileDelete"; data: { deleted_count: number; failed_count: number; total_bytes: number } } | 
/**
 * Duplicate detection output
 */
{ type: "DuplicateDetection"; data: { duplicate_groups: number; total_duplicates: number; potential_savings: number } } | 
/**
 * File validation output
 */
{ type: "FileValidation"; data: { validated_count: number; issues_found: number; total_bytes_validated: number } };

export type JobPauseInput = { job_id: string };

export type JobPauseOutput = { job_id: string; success: boolean };

export type JobReceipt = { id: JobId; job_name: string };

export type JobResumeInput = { job_id: string };

export type JobResumeOutput = { job_id: string; success: boolean };

/**
 * Current status of a job
 */
export type JobStatus = 
/**
 * Job is waiting to be executed
 */
"queued" | 
/**
 * Job is currently running
 */
"running" | 
/**
 * Job has been paused
 */
"paused" | 
/**
 * Job completed successfully
 */
"completed" | 
/**
 * Job failed with an error
 */
"failed" | 
/**
 * Job was cancelled
 */
"cancelled";

export type JsonValue = null | boolean | number | string | JsonValue[] | { [key in string]: JsonValue };

/**
 * Latency metrics snapshot
 */
export type LatencySnapshot = { count: number; avg_ms: number; min_ms: number; max_ms: number };

/**
 * Input for creating a new library
 */
export type LibraryCreateInput = { 
/**
 * Name of the library
 */
name: string; 
/**
 * Optional path for the library (if not provided, will use default location)
 */
path: string | null };

/**
 * Output from library create action dispatch
 */
export type LibraryCreateOutput = { library_id: string; name: string; path: string };

/**
 * Input for deleting a library
 */
export type LibraryDeleteInput = { 
/**
 * ID of the library to delete
 */
library_id: string; 
/**
 * Whether to also delete the library's data directory
 */
delete_data: boolean };

/**
 * Output from library delete action dispatch
 */
export type LibraryDeleteOutput = { library_id: string; name: string };

/**
 * Device information from the library database
 */
export type LibraryDeviceInfo = { 
/**
 * Unique device identifier
 */
id: string; 
/**
 * Device name
 */
name: string; 
/**
 * Operating system
 */
os: string; 
/**
 * Operating system version (if available)
 */
os_version: string | null; 
/**
 * Hardware model (if available)
 */
hardware_model: string | null; 
/**
 * Whether this device is currently online
 */
is_online: boolean; 
/**
 * Last time this device was seen
 */
last_seen_at: string; 
/**
 * When this device was first registered in the library
 */
created_at: string; 
/**
 * When this device info was last updated
 */
updated_at: string; 
/**
 * Whether this is the current device
 */
is_current: boolean; 
/**
 * Network addresses for P2P connections (if available)
 */
network_addresses: string[]; 
/**
 * Device capabilities (if available)
 */
capabilities: JsonValue | null };

/**
 * Input for exporting a library
 */
export type LibraryExportInput = { library_id: string; export_path: string; include_thumbnails: boolean; include_previews: boolean };

export type LibraryExportOutput = { library_id: string; library_name: string; export_path: string; exported_files: string[] };

/**
 * Information about a library for listing purposes
 */
export type LibraryInfo = { 
/**
 * Library unique identifier
 */
id: string; 
/**
 * Human-readable library name
 */
name: string; 
/**
 * Path to the library directory
 */
path: string; 
/**
 * Optional statistics if requested
 */
stats: LibraryStatistics | null };

/**
 * Detailed information about a library
 */
export type LibraryInfoOutput = { 
/**
 * Library unique identifier
 */
id: string; 
/**
 * Human-readable library name
 */
name: string; 
/**
 * Optional description
 */
description: string | null; 
/**
 * Path to the library directory
 */
path: string; 
/**
 * When the library was created
 */
created_at: string; 
/**
 * When the library was last modified
 */
updated_at: string; 
/**
 * Library-specific settings
 */
settings: LibrarySettings; 
/**
 * Library statistics
 */
statistics: LibraryStatistics };

/**
 * Input for library info query
 */
export type LibraryInfoQueryInput = null;

export type LibraryRenameInput = { library_id: string; new_name: string };

export type LibraryRenameOutput = { library_id: string; old_name: string; new_name: string };

/**
 * Library-specific settings
 */
export type LibrarySettings = { 
/**
 * Whether to generate thumbnails for media files
 */
generate_thumbnails: boolean; 
/**
 * Thumbnail quality (0-100)
 */
thumbnail_quality: number; 
/**
 * Whether to enable AI-powered tagging
 */
enable_ai_tagging: boolean; 
/**
 * Whether sync is enabled for this library
 */
sync_enabled: boolean; 
/**
 * Whether the library is encrypted at rest
 */
encryption_enabled: boolean; 
/**
 * Custom thumbnail sizes to generate
 */
thumbnail_sizes: number[]; 
/**
 * File extensions to ignore during indexing
 */
ignored_extensions: string[]; 
/**
 * TODO: ai slop config pls remove this
 */
max_file_size: number | null; 
/**
 * Whether to automatically track system volumes
 */
auto_track_system_volumes: boolean; 
/**
 * Whether to automatically track external volumes when connected
 */
auto_track_external_volumes: boolean; 
/**
 * Indexer settings (rule toggles and related)
 */
indexer?: IndexerSettings };

/**
 * Library statistics
 */
export type LibraryStatistics = { 
/**
 * Total number of files indexed
 */
total_files: number; 
/**
 * Total size of all files in bytes
 */
total_size: number; 
/**
 * Number of locations in this library
 */
location_count: number; 
/**
 * Number of tags created
 */
tag_count: number; 
/**
 * Number of thumbnails generated
 */
thumbnail_count: number; 
/**
 * Database file size in bytes
 */
database_size: number; 
/**
 * Last time the library was fully indexed
 */
last_indexed: string | null; 
/**
 * When these statistics were last updated
 */
updated_at: string };

/**
 * Action to take when setting up library sync
 */
export type LibrarySyncAction = 
/**
 * Share local library to remote device (creates same library with same UUID on remote)
 * This is the primary way to create a shared library
 */
{ type: "shareLocalLibrary"; libraryName: string } | 
/**
 * Join an existing remote library (creates same library with same UUID locally)
 * Use this when the other device has already shared their library
 */
{ type: "joinRemoteLibrary"; remoteLibraryId: string; remoteLibraryName: string } | 
/**
 * Future: Merge two different libraries into one (combines data from both)
 * Not yet implemented - requires full sync system
 */
{ type: "mergeLibraries"; localLibraryId: string; remoteLibraryId: string; mergedName: string };

/**
 * Input for setting up library sync between paired devices
 */
export type LibrarySyncSetupInput = { 
/**
 * Local device ID (should be current device)
 */
localDeviceId: string; 
/**
 * Remote paired device ID
 */
remoteDeviceId: string; 
/**
 * Local library to set up sync for
 */
localLibraryId: string; 
/**
 * Remote library to sync with (optional for RegisterOnly)
 */
remoteLibraryId: string | null; 
/**
 * Sync action to perform
 */
action: LibrarySyncAction; 
/**
 * DEPRICATED: Which device should be the sync leader (for future sync implementation)
 */
leaderDeviceId: string };

/**
 * Result of library sync setup operation
 */
export type LibrarySyncSetupOutput = { 
/**
 * Whether setup was successful
 */
success: boolean; 
/**
 * Local library ID that was configured
 */
localLibraryId: string; 
/**
 * Remote library ID that was linked (if applicable)
 */
remoteLibraryId: string | null; 
/**
 * Whether devices were successfully registered in each other's libraries
 */
devicesRegistered: boolean; 
/**
 * Message describing the result
 */
message: string };

export type ListEventsInput = Record<string, never>;

export type ListEventsOutput = { 
/**
 * All available event types
 */
all_events: string[]; 
/**
 * Events that are high-frequency and should be excluded by default
 */
noisy_events: string[]; 
/**
 * Detailed information about each event
 */
event_info: EventInfo[] };

export type ListLibrariesInput = { 
/**
 * Whether to include detailed statistics for each library
 */
include_stats: boolean };

/**
 * Input for listing devices from library database
 */
export type ListLibraryDevicesInput = { 
/**
 * Whether to include offline devices (default: true)
 */
include_offline: boolean; 
/**
 * Whether to include detailed capabilities and sync leadership info (default: false)
 */
include_details: boolean };

export type ListPairedDevicesInput = { 
/**
 * Whether to include only connected devices
 */
connectedOnly?: boolean };

/**
 * Output from listing paired devices
 */
export type ListPairedDevicesOutput = { 
/**
 * List of paired devices
 */
devices: PairedDeviceInfo[]; 
/**
 * Total number of paired devices
 */
total: number; 
/**
 * Number of currently connected devices
 */
connected: number };

export type LocationAddInput = { path: SdPath; name: string | null; mode: IndexMode };

/**
 * Output from location add action dispatch
 */
export type LocationAddOutput = { location_id: string; path: SdPath; name: string | null; job_id: string | null };

export type LocationInfo = { id: string; path: string; name: string | null; sd_path: SdPath };

export type LocationRemoveInput = { location_id: string };

/**
 * Output from location remove action dispatch
 */
export type LocationRemoveOutput = { location_id: string; path: string | null };

export type LocationRescanInput = { location_id: string; full_rescan: boolean };

export type LocationRescanOutput = { location_id: string; location_path: string; job_id: string; full_rescan: boolean };

export type LocationsListOutput = { locations: LocationInfo[] };

export type LocationsListQueryInput = null;

/**
 * Mount type classification
 */
export type MountType = 
/**
 * System mount (root, boot, etc.)
 */
"System" | 
/**
 * External device mount
 */
"External" | 
/**
 * Network mount
 */
"Network" | 
/**
 * User mount
 */
"User";

export type NetworkStartInput = Record<string, never>;

export type NetworkStartOutput = { started: boolean };

export type NetworkStatus = { running: boolean; node_id: string | null; addresses: string[]; paired_devices: number; connected_devices: number; version: string; relay_url: string | null };

export type NetworkStatusQueryInput = null;

export type NetworkStopInput = Record<string, never>;

export type NetworkStopOutput = { stopped: boolean };

/**
 * Operation metrics snapshot
 */
export type OperationSnapshot = { broadcasts_sent: number; state_changes_broadcast: number; shared_changes_broadcast: number; broadcast_batches_sent: number; failed_broadcasts: number; changes_received: number; changes_applied: number; changes_rejected: number; buffer_queue_depth: number; active_backfill_sessions: number; backfill_sessions_completed: number; backfill_pagination_rounds: number; retry_queue_depth: number; retry_attempts: number; retry_successes: number };

/**
 * Pagination information
 */
export type PaginationInfo = { current_page: number; total_pages: number; has_next: boolean; has_previous: boolean; limit: number; offset: number };

/**
 * Pagination options
 */
export type PaginationOptions = { limit: number; offset: number };

export type PairCancelInput = { session_id: string };

export type PairCancelOutput = { cancelled: boolean };

export type PairGenerateInput = { auto_accept: boolean };

export type PairGenerateOutput = { code: string; session_id: string; expires_at: string; 
/**
 * QR code JSON format (includes NodeId and relay URL for remote pairing)
 */
qr_json: string };

export type PairJoinInput = { code: string };

export type PairJoinOutput = { paired_device_id: string; device_name: string };

export type PairStatusOutput = { sessions: PairingSessionSummary[] };

export type PairStatusQueryInput = null;

/**
 * Information about a paired device
 */
export type PairedDeviceInfo = { 
/**
 * Device ID
 */
id: string; 
/**
 * Device name
 */
name: string; 
/**
 * Device type
 */
deviceType: string; 
/**
 * OS version
 */
osVersion: string; 
/**
 * App version
 */
appVersion: string; 
/**
 * Whether the device is currently connected
 */
isConnected: boolean; 
/**
 * When the device was last seen
 */
lastSeen: string };

export type PairingSessionSummary = { id: string; state: SerializablePairingState; remote_device_id: string | null; expires_at: string | null };

/**
 * Path mapping for resolving virtual paths to actual storage locations
 */
export type PathMapping = { virtual_path: string; actual_path: string };

/**
 * Performance and timing metrics
 */
export type PerformanceMetrics = { 
/**
 * Processing rate (items per second)
 */
rate: number; 
/**
 * Estimated time remaining
 */
estimated_remaining: { secs: number; nanos: number } | null; 
/**
 * Time elapsed since start
 */
elapsed: { secs: number; nanos: number } | null; 
/**
 * Number of errors encountered
 */
error_count: number; 
/**
 * Number of warnings
 */
warning_count: number };

/**
 * Performance metrics snapshot
 */
export type PerformanceSnapshot = { broadcast_latency: LatencySnapshot; apply_latency: LatencySnapshot; backfill_request_latency: LatencySnapshot; state_watermark: string; shared_watermark: string; watermark_lag_ms: { [key in string]: number }; hlc_physical_drift_ms: number; hlc_counter_max: number; db_query_duration: LatencySnapshot; db_query_count: number };

export type PingInput = { message: string; count?: number | null };

export type PingOutput = { echo: string; count: number; extension_works: boolean };

/**
 * Privacy levels for tag visibility control
 */
export type PrivacyLevel = 
/**
 * Standard visibility in all contexts
 */
"Normal" | 
/**
 * Hidden from normal searches but accessible via direct query
 */
"Archive" | 
/**
 * Completely hidden from standard UI
 */
"Hidden";

/**
 * Progress completion information
 */
export type ProgressCompletion = { 
/**
 * Items completed (files, entries, operations, etc.)
 */
completed: number; 
/**
 * Total items to complete
 */
total: number; 
/**
 * Bytes processed (if applicable)
 */
bytes_completed: number | null; 
/**
 * Total bytes to process (if applicable)
 */
total_bytes: number | null };

/**
 * Information about a library discovered on a remote device
 */
export type RemoteLibraryInfo = { 
/**
 * Library ID
 */
id: string; 
/**
 * Library name
 */
name: string; 
/**
 * Library description (if any)
 */
description: string | null; 
/**
 * When the library was created
 */
createdAt: string; 
/**
 * Statistics about the library
 */
statistics: LibraryStatistics };

/**
 * Detailed breakdown of how the score was calculated
 */
export type ScoreBreakdown = { temporal_score: number; semantic_score: number | null; metadata_score: number; recency_boost: number; user_preference_boost: number; final_score: number };

/**
 * A path within the Spacedrive Virtual Distributed File System
 * 
 * This is the core abstraction that enables cross-device operations.
 * An SdPath can represent:
 * - A physical file at a specific path on a specific device
 * - A content-addressed file that can be sourced from any device
 * - A sidecar (derivative data) attached to content
 * 
 * This enum-based approach enables resilient file operations by allowing
 * content-based paths to be resolved to optimal physical locations at runtime.
 */
export type SdPath = 
/**
 * A direct pointer to a file at a specific path on a specific device
 */
{ Physical: { 
/**
 * The device slug (e.g., "jamies-macbook")
 */
device_slug: string; 
/**
 * The local path on that device
 */
path: string } } | 
/**
 * A cloud storage path within a cloud volume
 */
{ Cloud: { 
/**
 * The cloud service type (S3, GoogleDrive, etc.)
 */
service: CloudServiceType; 
/**
 * The cloud identifier (bucket name, drive name, etc.)
 */
identifier: string; 
/**
 * The cloud-native path (e.g., "bucket/key" for S3)
 */
path: string } } | 
/**
 * An abstract, location-independent handle that refers to file content
 */
{ Content: { 
/**
 * The unique content identifier
 */
content_id: string } } | 
/**
 * A derivative data file (thumbnail, OCR text, embedding, etc.)
 * Sidecars are content-scoped and addressed by content + kind + variant
 */
{ Sidecar: { 
/**
 * The content this sidecar is derived from
 */
content_id: string; 
/**
 * The type of sidecar (thumb, ocr, embeddings, etc.)
 */
kind: SidecarKind; 
/**
 * The specific variant (e.g., "grid@2x", "1080p", "all-MiniLM-L6-v2")
 */
variant: SidecarVariant; 
/**
 * The storage format (webp, json, msgpack, etc.)
 */
format: SidecarFormat } };

/**
 * A batch of SdPaths, useful for operations on multiple files
 */
export type SdPathBatch = { paths: SdPath[] };

/**
 * Search facets for filtering UI
 */
export type SearchFacets = { file_types: { [key in string]: number }; tags: { [key in string]: number }; locations: { [key in string]: number }; date_ranges: { [key in string]: number }; size_ranges: { [key in string]: number } };

/**
 * Container for all structured filters
 */
export type SearchFilters = { file_types: string[] | null; tags: TagFilter | null; date_range: DateRangeFilter | null; size_range: SizeRangeFilter | null; locations: string[] | null; content_types: ContentKind[] | null; include_hidden: boolean | null; include_archived: boolean | null };

/**
 * Defines the search mode and performance characteristics
 */
export type SearchMode = 
/**
 * Fast, metadata-only search (<10ms)
 */
"Fast" | 
/**
 * Normal search with semantic ranking (<100ms)
 */
"Normal" | 
/**
 * Full search with content analysis (<500ms)
 */
"Full";

/**
 * Defines the scope of the filesystem to search within
 */
export type SearchScope = 
/**
 * Search the entire library (default)
 */
"Library" | 
/**
 * Restrict search to a specific location by its ID
 */
{ Location: { location_id: string } } | 
/**
 * Restrict search to a specific directory path and all its descendants
 */
{ Path: { path: SdPath } };

export type SearchTagsInput = { 
/**
 * Search query (searches across all name variants)
 */
query: string; 
/**
 * Optional namespace filter
 */
namespace: string | null; 
/**
 * Optional tag type filter
 */
tag_type: TagType | null; 
/**
 * Whether to include archived/hidden tags
 */
include_archived: boolean | null; 
/**
 * Maximum number of results to return
 */
limit: number | null; 
/**
 * Whether to resolve ambiguous results using context
 */
resolve_ambiguous: boolean | null; 
/**
 * Context tags for disambiguation (UUIDs)
 */
context_tag_ids: string[] | null };

export type SearchTagsOutput = { 
/**
 * Tags found by the search
 */
tags: TagSearchResult[]; 
/**
 * Total number of results found (may be more than returned if limited)
 */
total_found: number; 
/**
 * Whether results were disambiguated using context
 */
disambiguated: boolean; 
/**
 * Search query that was executed
 */
query: string; 
/**
 * Applied filters
 */
filters: TagSearchFilters };

export type SerializablePairingState = "Idle" | "GeneratingCode" | "Broadcasting" | "Scanning" | "WaitingForConnection" | "Connecting" | "Authenticating" | "ExchangingKeys" | "AwaitingConfirmation" | "EstablishingSession" | "ChallengeReceived" | "ResponsePending" | "ResponseSent" | "Completed" | { Failed: { reason: string } };

export type ServiceState = { running: boolean; details: string | null };

export type ServiceStatus = { location_watcher: ServiceState; networking: ServiceState; volume_monitor: ServiceState; file_sharing: ServiceState };

/**
 * Domain representation of a sidecar
 */
export type Sidecar = { id: number; content_uuid: string; kind: string; variant: string; format: string; status: string; size: number; created_at: string; updated_at: string };

/**
 * Format for storing sidecar files
 * 
 * Format selection guidelines:
 * - Webp: Thumbnails and image derivatives (compressed images)
 * - Mp4: Video/audio proxies (standard media format)
 * - Json: Text-based structured data (OCR, transcripts)
 * - MessagePack: Binary structured data (embeddings, vectors)
 * - Text: Plain text extractions
 * 
 * MessagePack is preferred for embeddings because:
 * - 6x smaller than JSON (1.7KB vs 10KB per 384-dim vector)
 * - 10x faster to parse
 * - Already used in Spacedrive (job serialization)
 * - Enables sub-30ms semantic search on 1M+ files
 */
export type SidecarFormat = "webp" | "mp_4" | "json" | "message_pack" | "text";

export type SidecarKind = "thumb" | "proxy" | "embeddings" | "ocr" | "transcript";

export type SidecarVariant = string;

/**
 * Filter for file size in bytes
 */
export type SizeRangeFilter = { min: number | null; max: number | null };

/**
 * Sort direction
 */
export type SortDirection = "Asc" | "Desc";

/**
 * Fields that can be used for sorting
 */
export type SortField = "Relevance" | "Name" | "Size" | "ModifiedAt" | "CreatedAt";

/**
 * Sorting options for search results
 */
export type SortOptions = { field: SortField; direction: SortDirection };

export type SpacedropSendInput = { device_id: string; paths: SdPath[]; sender: string | null };

export type SpacedropSendOutput = { job_id: string | null; session_id: string | null };

/**
 * State transition event
 */
export type StateTransition = { from: DeviceSyncState; to: DeviceSyncState; timestamp: string; reason: string | null };

/**
 * Point-in-time snapshot of all sync metrics
 */
export type SyncMetricsSnapshot = { 
/**
 * When this snapshot was taken
 */
timestamp: string; 
/**
 * State metrics
 */
state: SyncStateSnapshot; 
/**
 * Operation metrics
 */
operations: OperationSnapshot; 
/**
 * Data volume metrics
 */
data_volume: DataVolumeSnapshot; 
/**
 * Performance metrics
 */
performance: PerformanceSnapshot; 
/**
 * Error metrics
 */
errors: ErrorSnapshot };

/**
 * State metrics snapshot
 */
export type SyncStateSnapshot = { current_state: DeviceSyncState; state_entered_at: string; uptime_seconds: number; state_history: StateTransition[]; total_time_in_state: ([DeviceSyncState, number])[]; transition_count: ([[DeviceSyncState, DeviceSyncState], number])[] };

export type SystemInfo = { uptime: number | null; data_directory: string; instance_name: string | null; current_library: string | null };

/**
 * A tag with advanced capabilities for contextual organization
 */
export type Tag = { 
/**
 * Unique identifier
 */
id: string; 
/**
 * Core identity
 */
canonical_name: string; display_name: string | null; 
/**
 * Semantic variants for flexible access
 */
formal_name: string | null; abbreviation: string | null; aliases: string[]; 
/**
 * Context and categorization
 */
namespace: string | null; tag_type: TagType; 
/**
 * Visual and behavioral properties
 */
color: string | null; icon: string | null; description: string | null; 
/**
 * Advanced capabilities
 */
is_organizational_anchor: boolean; privacy_level: PrivacyLevel; search_weight: number; 
/**
 * Compositional attributes
 */
attributes: { [key in string]: JsonValue }; composition_rules: CompositionRule[]; 
/**
 * Metadata
 */
created_at: string; updated_at: string; created_by_device: string };

/**
 * Filter for tags, supporting complex boolean logic
 */
export type TagFilter = { 
/**
 * Must have all of these tag IDs
 */
include: string[]; 
/**
 * Must not have any of these tag IDs
 */
exclude: string[] };

export type TagSearchFilters = { namespace: string | null; tag_type: string | null; include_archived: boolean; limit: number | null };

export type TagSearchResult = { 
/**
 * The semantic tag
 */
tag: Tag; 
/**
 * Relevance score (0.0-1.0)
 */
relevance: number; 
/**
 * Which name variant matched the search
 */
matched_variant: string | null; 
/**
 * Context score if disambiguation was used
 */
context_score: number | null };

/**
 * Source of tag application
 */
export type TagSource = 
/**
 * Manually applied by user
 */
"User" | 
/**
 * Applied by AI analysis
 */
"AI" | 
/**
 * Imported from external source
 */
"Import" | 
/**
 * Synchronized from another device
 */
"Sync";

/**
 * Types of semantic tags with different behaviors
 */
export type TagType = 
/**
 * Standard user-created tag
 */
"Standard" | 
/**
 * Creates visual hierarchies in the interface
 */
"Organizational" | 
/**
 * Controls search and display visibility
 */
"Privacy" | 
/**
 * System-generated tag (AI, import, etc.)
 */
"System";

/**
 * Text highlighting information
 */
export type TextHighlight = { field: string; text: string; start: number; end: number };

export type ThumbnailInput = { paths: string[]; size: number; quality: number };

/**
 * Input for finding files unique to a location
 */
export type UniqueToLocationInput = { 
/**
 * The location ID to find unique files for
 */
location_id: string; 
/**
 * Optional limit on number of results
 */
limit: number | null };

/**
 * Output containing files that are unique to the specified location
 */
export type UniqueToLocationOutput = { 
/**
 * Files that exist only in the specified location
 */
unique_files: File[]; 
/**
 * Total count of unique files
 */
total_count: number; 
/**
 * Total size of unique files in bytes
 */
total_size: number };

/**
 * A volume in Spacedrive - unified model for runtime and database
 */
export type Volume = { 
/**
 * Unique identifier (used in SdPath addressing)
 */
id: string; 
/**
 * Volume fingerprint for identification
 */
fingerprint: VolumeFingerprint; 
/**
 * Device this volume is attached to
 */
device_id: string; 
/**
 * Human-readable name
 */
name: string; 
/**
 * Library this volume belongs to (None for untracked volumes)
 */
library_id: string | null; 
/**
 * Whether this volume is being tracked by Spacedrive
 */
is_tracked: boolean; 
/**
 * Primary mount point
 */
mount_point: string; 
/**
 * Additional mount points for the same volume
 */
mount_points: string[]; 
/**
 * Volume type/category
 */
volume_type: VolumeType; 
/**
 * Mount type classification
 */
mount_type: MountType; 
/**
 * Disk type (SSD, HDD, etc.)
 */
disk_type: DiskType; 
/**
 * Filesystem type
 */
file_system: FileSystem; 
/**
 * Total capacity in bytes
 */
total_capacity: number; 
/**
 * Currently available space in bytes
 */
available_space: number; 
/**
 * Whether volume is read-only
 */
is_read_only: boolean; 
/**
 * Whether volume is currently mounted/available
 */
is_mounted: boolean; 
/**
 * Hardware identifier (device path, UUID, etc.)
 */
hardware_id: string | null; 
/**
 * Cloud identifier (bucket/drive/container name) for cloud volumes
 * This is separate from mount_point to allow display names with suffixes
 * while maintaining the correct cloud resource identifier for backend operations
 */
cloud_identifier: string | null; 
/**
 * APFS container information (macOS only)
 */
apfs_container: ApfsContainer | null; 
/**
 * Container-relative volume ID for same-container detection
 */
container_volume_id: string | null; 
/**
 * Path resolution mappings (for firmlinks/symlinks)
 */
path_mappings: PathMapping[]; 
/**
 * Whether this volume should be visible in default views
 */
is_user_visible: boolean; 
/**
 * Whether this volume should be auto-tracked
 */
auto_track_eligible: boolean; 
/**
 * Performance metrics
 */
read_speed_mbps: number | null; write_speed_mbps: number | null; 
/**
 * Timestamps
 */
created_at: string; updated_at: string; last_seen_at: string; 
/**
 * Statistics
 */
total_files: number | null; total_directories: number | null; last_stats_update: string | null; 
/**
 * User preferences
 */
display_name: string | null; is_favorite: boolean; color: string | null; icon: string | null; 
/**
 * Error state
 */
error_message: string | null };

export type VolumeAddCloudInput = { service: CloudServiceType; display_name: string; config: CloudStorageConfig };

export type VolumeAddCloudOutput = { fingerprint: VolumeFingerprint; volume_name: string; service: CloudServiceType };

/**
 * Unique fingerprint for a storage volume
 */
export type VolumeFingerprint = string;

/**
 * Summary information about a volume (for updates and caching)
 */
export type VolumeInfo = { is_mounted: boolean; total_bytes_available: number; read_speed_mbps: number | null; write_speed_mbps: number | null; error_status: string | null };

export type VolumeItem = { uuid: string; name: string; fingerprint: VolumeFingerprint; volume_type: string; mount_point: string | null };

export type VolumeListOutput = { volumes: VolumeItem[] };

export type VolumeListQueryInput = Record<string, never>;

export type VolumeRemoveCloudInput = { fingerprint: VolumeFingerprint };

export type VolumeRemoveCloudOutput = { fingerprint: VolumeFingerprint };

export type VolumeSpeedTestInput = { fingerprint: VolumeFingerprint };

/**
 * Output from volume speed test operation
 */
export type VolumeSpeedTestOutput = { 
/**
 * The fingerprint of the tested volume
 */
fingerprint: VolumeFingerprint; 
/**
 * Read speed in MB/s (if measured)
 */
read_speed_mbps: number | null; 
/**
 * Write speed in MB/s (if measured)
 */
write_speed_mbps: number | null };

export type VolumeTrackInput = { fingerprint: VolumeFingerprint; name: string | null };

/**
 * Output from volume track operation
 */
export type VolumeTrackOutput = { 
/**
 * The fingerprint of the tracked volume
 */
fingerprint: VolumeFingerprint; 
/**
 * The display name of the tracked volume
 */
volume_name: string };

/**
 * Volume type classification
 */
export type VolumeType = 
/**
 * Primary system drive containing OS and user data
 */
"Primary" | 
/**
 * Dedicated user data volumes (separate from OS)
 */
"UserData" | 
/**
 * External or removable storage devices
 */
"External" | 
/**
 * Secondary internal storage (additional drives/partitions)
 */
"Secondary" | 
/**
 * System/OS internal volumes (hidden from normal view)
 */
"System" | 
/**
 * Network attached storage
 */
"Network" | 
/**
 * Cloud storage mounts
 */
"Cloud" | 
/**
 * Virtual/temporary storage
 */
"Virtual" | 
/**
 * Unknown or unclassified volumes
 */
"Unknown";

export type VolumeUntrackInput = { fingerprint: VolumeFingerprint };

/**
 * Output from volume untrack operation
 */
export type VolumeUntrackOutput = { 
/**
 * The fingerprint of the untracked volume
 */
fingerprint: VolumeFingerprint };
// ===== API Type Unions =====

export type CoreAction =
     { type: 'network.pair.cancel'; input: PairCancelInput; output: PairCancelOutput }
  |  { type: 'network.device.revoke'; input: DeviceRevokeInput; output: DeviceRevokeOutput }
  |  { type: 'libraries.create'; input: LibraryCreateInput; output: LibraryCreateOutput }
  |  { type: 'network.start'; input: NetworkStartInput; output: NetworkStartOutput }
  |  { type: 'network.pair.generate'; input: PairGenerateInput; output: PairGenerateOutput }
  |  { type: 'libraries.delete'; input: LibraryDeleteInput; output: LibraryDeleteOutput }
  |  { type: 'network.spacedrop.send'; input: SpacedropSendInput; output: SpacedropSendOutput }
  |  { type: 'network.sync_setup'; input: LibrarySyncSetupInput; output: LibrarySyncSetupOutput }
  |  { type: 'network.stop'; input: NetworkStopInput; output: NetworkStopOutput }
  |  { type: 'network.pair.join'; input: PairJoinInput; output: PairJoinOutput }
;

export type LibraryAction =
     { type: 'locations.rescan'; input: LocationRescanInput; output: LocationRescanOutput }
  |  { type: 'jobs.resume'; input: JobResumeInput; output: JobResumeOutput }
  |  { type: 'files.delete'; input: FileDeleteInput; output: JobReceipt }
  |  { type: 'tags.create'; input: CreateTagInput; output: CreateTagOutput }
  |  { type: 'media.thumbnail'; input: ThumbnailInput; output: JobReceipt }
  |  { type: 'tags.apply'; input: ApplyTagsInput; output: ApplyTagsOutput }
  |  { type: 'locations.remove'; input: LocationRemoveInput; output: LocationRemoveOutput }
  |  { type: 'files.copy'; input: FileCopyInput; output: JobReceipt }
  |  { type: 'volumes.untrack'; input: VolumeUntrackInput; output: VolumeUntrackOutput }
  |  { type: 'libraries.export'; input: LibraryExportInput; output: LibraryExportOutput }
  |  { type: 'volumes.track'; input: VolumeTrackInput; output: VolumeTrackOutput }
  |  { type: 'jobs.pause'; input: JobPauseInput; output: JobPauseOutput }
  |  { type: 'jobs.cancel'; input: JobCancelInput; output: JobCancelOutput }
  |  { type: 'indexing.start'; input: IndexInput; output: JobReceipt }
  |  { type: 'indexing.verify'; input: IndexVerifyInput; output: IndexVerifyOutput }
  |  { type: 'locations.add'; input: LocationAddInput; output: LocationAddOutput }
  |  { type: 'volumes.add_cloud'; input: VolumeAddCloudInput; output: VolumeAddCloudOutput }
  |  { type: 'volumes.speed_test'; input: VolumeSpeedTestInput; output: VolumeSpeedTestOutput }
  |  { type: 'libraries.rename'; input: LibraryRenameInput; output: LibraryRenameOutput }
  |  { type: 'volumes.remove_cloud'; input: VolumeRemoveCloudInput; output: VolumeRemoveCloudOutput }
;

export type CoreQuery =
     { type: 'core.events.list'; input: ListEventsInput; output: ListEventsOutput }
  |  { type: 'network.sync_setup.discover'; input: DiscoverRemoteLibrariesInput; output: DiscoverRemoteLibrariesOutput }
  |  { type: 'core.status'; input: Empty; output: CoreStatus }
  |  { type: 'network.status'; input: NetworkStatusQueryInput; output: NetworkStatus }
  |  { type: 'libraries.list'; input: ListLibrariesInput; output: [LibraryInfo] }
  |  { type: 'network.devices.list'; input: ListPairedDevicesInput; output: ListPairedDevicesOutput }
  |  { type: 'network.pair.status'; input: PairStatusQueryInput; output: PairStatusOutput }
;

export type LibraryQuery =
     { type: 'libraries.info'; input: LibraryInfoQueryInput; output: LibraryInfoOutput }
  |  { type: 'test.ping'; input: PingInput; output: PingOutput }
  |  { type: 'devices.list'; input: ListLibraryDevicesInput; output: [LibraryDeviceInfo] }
  |  { type: 'files.by_path'; input: FileByPathQuery; output: File }
  |  { type: 'locations.list'; input: LocationsListQueryInput; output: LocationsListOutput }
  |  { type: 'tags.search'; input: SearchTagsInput; output: SearchTagsOutput }
  |  { type: 'sync.metrics'; input: GetSyncMetricsInput; output: GetSyncMetricsOutput }
  |  { type: 'jobs.info'; input: JobInfoQueryInput; output: JobInfoOutput }
  |  { type: 'files.unique_to_location'; input: UniqueToLocationInput; output: UniqueToLocationOutput }
  |  { type: 'files.by_id'; input: FileByIdQuery; output: File }
  |  { type: 'volumes.list'; input: VolumeListQueryInput; output: VolumeListOutput }
  |  { type: 'files.directory_listing'; input: DirectoryListingInput; output: DirectoryListingOutput }
  |  { type: 'jobs.list'; input: JobListInput; output: JobListOutput }
  |  { type: 'search.files'; input: FileSearchInput; output: FileSearchOutput }
;

// ===== Wire Method Mappings =====

export const WIRE_METHODS = {
  coreActions: {
    'network.pair.cancel': 'action:network.pair.cancel.input',
    'network.device.revoke': 'action:network.device.revoke.input',
    'libraries.create': 'action:libraries.create.input',
    'network.start': 'action:network.start.input',
    'network.pair.generate': 'action:network.pair.generate.input',
    'libraries.delete': 'action:libraries.delete.input',
    'network.spacedrop.send': 'action:network.spacedrop.send.input',
    'network.sync_setup': 'action:network.sync_setup.input',
    'network.stop': 'action:network.stop.input',
    'network.pair.join': 'action:network.pair.join.input',
  },

  libraryActions: {
    'locations.rescan': 'action:locations.rescan.input',
    'jobs.resume': 'action:jobs.resume.input',
    'files.delete': 'action:files.delete.input',
    'tags.create': 'action:tags.create.input',
    'media.thumbnail': 'action:media.thumbnail.input',
    'tags.apply': 'action:tags.apply.input',
    'locations.remove': 'action:locations.remove.input',
    'files.copy': 'action:files.copy.input',
    'volumes.untrack': 'action:volumes.untrack.input',
    'libraries.export': 'action:libraries.export.input',
    'volumes.track': 'action:volumes.track.input',
    'jobs.pause': 'action:jobs.pause.input',
    'jobs.cancel': 'action:jobs.cancel.input',
    'indexing.start': 'action:indexing.start.input',
    'indexing.verify': 'action:indexing.verify.input',
    'locations.add': 'action:locations.add.input',
    'volumes.add_cloud': 'action:volumes.add_cloud.input',
    'volumes.speed_test': 'action:volumes.speed_test.input',
    'libraries.rename': 'action:libraries.rename.input',
    'volumes.remove_cloud': 'action:volumes.remove_cloud.input',
  },

  coreQueries: {
    'core.events.list': 'query:core.events.list',
    'network.sync_setup.discover': 'query:network.sync_setup.discover',
    'core.status': 'query:core.status',
    'network.status': 'query:network.status',
    'libraries.list': 'query:libraries.list',
    'network.devices.list': 'query:network.devices.list',
    'network.pair.status': 'query:network.pair.status',
  },

  libraryQueries: {
    'libraries.info': 'query:libraries.info',
    'test.ping': 'query:test.ping',
    'devices.list': 'query:devices.list',
    'files.by_path': 'query:files.by_path',
    'locations.list': 'query:locations.list',
    'tags.search': 'query:tags.search',
    'sync.metrics': 'query:sync.metrics',
    'jobs.info': 'query:jobs.info',
    'files.unique_to_location': 'query:files.unique_to_location',
    'files.by_id': 'query:files.by_id',
    'volumes.list': 'query:volumes.list',
    'files.directory_listing': 'query:files.directory_listing',
    'jobs.list': 'query:jobs.list',
    'search.files': 'query:search.files',
  },
} as const;
