// Generated by Spacedrive using Specta + rspc-inspired type extraction - DO NOT EDIT
import Foundation

public struct ApplyTagsInput: Codable {
    public let entryIds: [Int32]
    public let tagIds: [String]
    public let source: TagSource?
    public let confidence: Float?
    public let appliedContext: String?
    public let instanceAttributes: [String: JsonValue]?

    private enum CodingKeys: String, CodingKey {
        case entryIds = "entry_ids"
        case tagIds = "tag_ids"
        case source = "source"
        case confidence = "confidence"
        case appliedContext = "applied_context"
        case instanceAttributes = "instance_attributes"
    }
}

public struct ApplyTagsOutput: Codable {
    public let entriesAffected: UInt
    public let tagsApplied: UInt
    public let appliedTagIds: [String]
    public let taggedEntryIds: [Int32]
    public let warnings: [String]
    public let message: String

    private enum CodingKeys: String, CodingKey {
        case entriesAffected = "entries_affected"
        case tagsApplied = "tags_applied"
        case appliedTagIds = "applied_tag_ids"
        case taggedEntryIds = "tagged_entry_ids"
        case warnings = "warnings"
        case message = "message"
    }
}

/// Operators for combining tag attributes
public enum CompositionOperator: Codable {
    case and
    case or
    case with
    case without
}

/// Rules for composing attributes from multiple tags
public struct CompositionRule: Codable {
    public let operator: CompositionOperator
    public let operands: [String]
    public let resultAttribute: String

    private enum CodingKeys: String, CodingKey {
        case operator = "operator"
        case operands = "operands"
        case resultAttribute = "result_attribute"
    }
}

/// Type of content
public enum ContentKind: String, Codable {
    case unknown = "unknown"
    case image = "image"
    case video = "video"
    case audio = "audio"
    case document = "document"
    case archive = "archive"
    case code = "code"
    case text = "text"
    case database = "database"
    case book = "book"
    case font = "font"
    case mesh = "mesh"
    case config = "config"
    case encrypted = "encrypted"
    case key = "key"
    case executable = "executable"
    case binary = "binary"
}

/// Copy method preference for file operations
public enum CopyMethod: Codable {
    case auto
    case atomic
    case streaming
}

public struct CoreStatus: Codable {
    public let version: String
    public let builtAt: String
    public let libraryCount: UInt
    public let deviceInfo: DeviceInfo
    public let libraries: [LibraryInfo]
    public let services: ServiceStatus
    public let network: NetworkStatus
    public let system: SystemInfo

    private enum CodingKeys: String, CodingKey {
        case version = "version"
        case builtAt = "built_at"
        case libraryCount = "library_count"
        case deviceInfo = "device_info"
        case libraries = "libraries"
        case services = "services"
        case network = "network"
        case system = "system"
    }
}

public struct CreateTagInput: Codable {
    public let canonicalName: String
    public let displayName: String?
    public let formalName: String?
    public let abbreviation: String?
    public let aliases: [String]
    public let namespace: String?
    public let tagType: TagType?
    public let color: String?
    public let icon: String?
    public let description: String?
    public let isOrganizationalAnchor: Bool?
    public let privacyLevel: PrivacyLevel?
    public let searchWeight: Int32?
    public let attributes: [String: JsonValue]?

    private enum CodingKeys: String, CodingKey {
        case canonicalName = "canonical_name"
        case displayName = "display_name"
        case formalName = "formal_name"
        case abbreviation = "abbreviation"
        case aliases = "aliases"
        case namespace = "namespace"
        case tagType = "tag_type"
        case color = "color"
        case icon = "icon"
        case description = "description"
        case isOrganizationalAnchor = "is_organizational_anchor"
        case privacyLevel = "privacy_level"
        case searchWeight = "search_weight"
        case attributes = "attributes"
    }
}

public struct CreateTagOutput: Codable {
    public let tagId: String
    public let canonicalName: String
    public let namespace: String?
    public let message: String

    private enum CodingKeys: String, CodingKey {
        case tagId = "tag_id"
        case canonicalName = "canonical_name"
        case namespace = "namespace"
        case message = "message"
    }
}

/// Time-based fields that can be filtered
public enum DateField: Codable {
    case createdAt
    case modifiedAt
    case accessedAt
}

/// Filter for a time-based field
public struct DateRangeFilter: Codable {
    public let field: DateField
    public let start: String?
    public let end: String?
}

public struct DeviceInfo: Codable {
    public let id: String
    public let name: String
    public let os: String
    public let hardwareModel: String?
    public let createdAt: String

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case os = "os"
        case hardwareModel = "hardware_model"
        case createdAt = "created_at"
    }
}

public struct DeviceInfoLite: Codable {
    public let id: String
    public let name: String
    public let osVersion: String
    public let appVersion: String
    public let isConnected: Bool
    public let lastSeen: String

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case osVersion = "os_version"
        case appVersion = "app_version"
        case isConnected = "is_connected"
        case lastSeen = "last_seen"
    }
}

public struct DeviceRevokeInput: Codable {
    public let deviceId: String

    private enum CodingKeys: String, CodingKey {
        case deviceId = "device_id"
    }
}

public struct DeviceRevokeOutput: Codable {
    public let revoked: Bool
}

/// Input for file duplicate detection operations
public struct DuplicateDetectionInput: Codable {
    public let paths: [String]
    public let algorithm: String
    public let threshold: Double
}

/// Represents any filesystem entry (file or directory) in the VDFS
public struct Entry: Codable {
    public let id: String
    public let sdPath: SdPathSerialized
    public let name: String
    public let kind: EntryKind
    public let size: UInt64?
    public let createdAt: String?
    public let modifiedAt: String?
    public let accessedAt: String?
    public let inode: UInt64?
    public let fileId: UInt64?
    public let parentId: String?
    public let locationId: String?
    public let metadataId: String
    public let contentId: String?
    public let firstSeenAt: String
    public let lastIndexedAt: String?

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case sdPath = "sd_path"
        case name = "name"
        case kind = "kind"
        case size = "size"
        case createdAt = "created_at"
        case modifiedAt = "modified_at"
        case accessedAt = "accessed_at"
        case inode = "inode"
        case fileId = "file_id"
        case parentId = "parent_id"
        case locationId = "location_id"
        case metadataId = "metadata_id"
        case contentId = "content_id"
        case firstSeenAt = "first_seen_at"
        case lastIndexedAt = "last_indexed_at"
    }
}

/// Type of filesystem entry
public enum EntryKind {
    case file(EntryKindFileData)
    case directory
    case symlink(EntryKindSymlinkData)
}
public struct EntryKindFileData: Codable {
    public let extension: String?
}

public struct EntryKindSymlinkData: Codable {
    public let target: String
}

// MARK: - EntryKind Codable Implementation
extension EntryKind: Codable {
    private enum CodingKeys: String, CodingKey {
        case file = "File"
        case directory = "Directory"
        case symlink = "Symlink"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .file:
            let data = try container.decode(EntryKindFileData.self, forKey: .file)
            self = .file(data)
        case .directory:
            self = .directory
        case .symlink:
            let data = try container.decode(EntryKindSymlinkData.self, forKey: .symlink)
            self = .symlink(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .file(let data):
            try container.encode(data, forKey: .file)
        case .directory:
            try container.encodeNil(forKey: .directory)
        case .symlink(let data):
            try container.encode(data, forKey: .symlink)
        }
    }
}


/// Internal enum for file conflict resolution strategies
public enum FileConflictResolution: Codable {
    case overwrite
    case autoModifyName
    case abort
}

/// Core input structure for file copy operations
/// This is the canonical interface that all external APIs (CLI, GraphQL, REST) convert to
public struct FileCopyInput: Codable {
    public let sources: SdPathBatch
    public let destination: SdPath
    public let overwrite: Bool
    public let verifyChecksum: Bool
    public let preserveTimestamps: Bool
    public let moveFiles: Bool
    public let copyMethod: CopyMethod
    public let onConflict: FileConflictResolution?

    private enum CodingKeys: String, CodingKey {
        case sources = "sources"
        case destination = "destination"
        case overwrite = "overwrite"
        case verifyChecksum = "verify_checksum"
        case preserveTimestamps = "preserve_timestamps"
        case moveFiles = "move_files"
        case copyMethod = "copy_method"
        case onConflict = "on_conflict"
    }
}

/// Input for deleting files
public struct FileDeleteInput: Codable {
    public let targets: SdPathBatch
    public let permanent: Bool
    public let recursive: Bool
}

/// Main input structure for file search operations
public struct FileSearchInput: Codable {
    public let query: String
    public let scope: SearchScope
    public let mode: SearchMode
    public let filters: SearchFilters
    public let sort: SortOptions
    public let pagination: PaginationOptions
}

/// Main output structure for file search operations
public struct FileSearchOutput: Codable {
    public let results: [FileSearchResult]
    public let totalFound: UInt64
    public let searchId: String
    public let facets: SearchFacets
    public let suggestions: [String]
    public let pagination: PaginationInfo
    public let executionTimeMs: UInt64

    private enum CodingKeys: String, CodingKey {
        case results = "results"
        case totalFound = "total_found"
        case searchId = "search_id"
        case facets = "facets"
        case suggestions = "suggestions"
        case pagination = "pagination"
        case executionTimeMs = "execution_time_ms"
    }
}

/// Individual search result
public struct FileSearchResult: Codable {
    public let entry: Entry
    public let score: Float
    public let scoreBreakdown: ScoreBreakdown
    public let highlights: [TextHighlight]
    public let matchedContent: String?

    private enum CodingKeys: String, CodingKey {
        case entry = "entry"
        case score = "score"
        case scoreBreakdown = "score_breakdown"
        case highlights = "highlights"
        case matchedContent = "matched_content"
    }
}

/// Input for file validation operations
public struct FileValidationInput: Codable {
    public let paths: [String]
    public let verifyChecksums: Bool
    public let deepScan: Bool

    private enum CodingKeys: String, CodingKey {
        case paths = "paths"
        case verifyChecksums = "verify_checksums"
        case deepScan = "deep_scan"
    }
}

/// Canonical input for indexing requests from any interface (CLI, API, etc.)
public struct IndexInput: Codable {
    public let libraryId: String
    public let paths: [String]
    public let scope: IndexScope
    public let mode: IndexMode
    public let includeHidden: Bool
    public let persistence: IndexPersistence

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case paths = "paths"
        case scope = "scope"
        case mode = "mode"
        case includeHidden = "include_hidden"
        case persistence = "persistence"
    }
}

/// Indexing mode determines the depth of indexing
public enum IndexMode: Codable {
    case shallow
    case content
    case deep
}

/// Determines whether indexing results are persisted to database or kept in memory
public enum IndexPersistence: Codable {
    case persistent
    case ephemeral
}

/// Indexing scope determines how much of the directory tree to process
public enum IndexScope: Codable {
    case current
    case recursive
}

/// Indexer settings controlling rule toggles
public struct IndexerSettings: Codable {
    public let noSystemFiles: Bool?
    public let noGit: Bool?
    public let noDevDirs: Bool?
    public let noHidden: Bool?
    public let gitignore: Bool?
    public let onlyImages: Bool?

    private enum CodingKeys: String, CodingKey {
        case noSystemFiles = "no_system_files"
        case noGit = "no_git"
        case noDevDirs = "no_dev_dirs"
        case noHidden = "no_hidden"
        case gitignore = "gitignore"
        case onlyImages = "only_images"
    }
}

public struct JobCancelInput: Codable {
    public let jobId: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
    }
}

public struct JobCancelOutput: Codable {
    public let jobId: String
    public let success: Bool

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case success = "success"
    }
}

/// Unique identifier for a job
public struct JobId: Codable {
    let value: String
}

public struct JobInfoOutput: Codable {
    public let id: String
    public let name: String
    public let status: JobStatus
    public let progress: Float
    public let startedAt: String
    public let completedAt: String?
    public let errorMessage: String?

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case status = "status"
        case progress = "progress"
        case startedAt = "started_at"
        case completedAt = "completed_at"
        case errorMessage = "error_message"
    }
}

public struct JobInfoQueryInput: Codable {
    public let jobId: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
    }
}

public struct JobListInput: Codable {
    public let status: JobStatus?
}

public struct JobListItem: Codable {
    public let id: String
    public let name: String
    public let status: JobStatus
    public let progress: Float
}

public struct JobListOutput: Codable {
    public let jobs: [JobListItem]
}

public struct JobPauseInput: Codable {
    public let jobId: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
    }
}

public struct JobPauseOutput: Codable {
    public let jobId: String
    public let success: Bool

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case success = "success"
    }
}

public struct JobReceipt: Codable {
    public let id: JobId
    public let jobName: String

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case jobName = "job_name"
    }
}

public struct JobResumeInput: Codable {
    public let jobId: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
    }
}

public struct JobResumeOutput: Codable {
    public let jobId: String
    public let success: Bool

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case success = "success"
    }
}

/// Current status of a job
public enum JobStatus: String, Codable {
    case queued = "queued"
    case running = "running"
    case paused = "paused"
    case completed = "completed"
    case failed = "failed"
    case cancelled = "cancelled"
}

public enum JsonValue: Codable {
    case null
    case bool(Bool)
    case number(    case f64(Double)
    case i64(Int64)
    case u64(UInt64)
)
    case string(String)
    case array([JsonValue])
    case object([String: JsonValue])
}

/// Input for creating a new library
public struct LibraryCreateInput: Codable {
    public let name: String
    public let path: String?
}

/// Output from library create action dispatch
public struct LibraryCreateOutput: Codable {
    public let libraryId: String
    public let name: String
    public let path: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case name = "name"
        case path = "path"
    }
}

/// Input for deleting a library
public struct LibraryDeleteInput: Codable {
    public let libraryId: String
    public let deleteData: Bool

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case deleteData = "delete_data"
    }
}

/// Output from library delete action dispatch
public struct LibraryDeleteOutput: Codable {
    public let libraryId: String
    public let name: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case name = "name"
    }
}

/// Input for exporting a library
public struct LibraryExportInput: Codable {
    public let libraryId: String
    public let exportPath: String
    public let includeThumbnails: Bool
    public let includePreviews: Bool

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case exportPath = "export_path"
        case includeThumbnails = "include_thumbnails"
        case includePreviews = "include_previews"
    }
}

public struct LibraryExportOutput: Codable {
    public let libraryId: String
    public let libraryName: String
    public let exportPath: String
    public let exportedFiles: [String]

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case libraryName = "library_name"
        case exportPath = "export_path"
        case exportedFiles = "exported_files"
    }
}

/// Information about a library for listing purposes
public struct LibraryInfo: Codable {
    public let id: String
    public let name: String
    public let path: String
    public let stats: LibraryStatistics?
}

public struct LibraryInfo: Codable {
    public let id: String
    public let name: String
    public let isActive: Bool
    public let locationCount: UInt
    public let totalEntries: UInt64?
    public let lastSync: String?

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case isActive = "is_active"
        case locationCount = "location_count"
        case totalEntries = "total_entries"
        case lastSync = "last_sync"
    }
}

/// Detailed information about a library
public struct LibraryInfoOutput: Codable {
    public let id: String
    public let name: String
    public let description: String?
    public let path: String
    public let createdAt: String
    public let updatedAt: String
    public let settings: LibrarySettings
    public let statistics: LibraryStatistics

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case description = "description"
        case path = "path"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
        case settings = "settings"
        case statistics = "statistics"
    }
}

/// Input for library info query
public struct LibraryInfoQueryInput: Codable {
Void}

public struct LibraryRenameInput: Codable {
    public let libraryId: String
    public let newName: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case newName = "new_name"
    }
}

public struct LibraryRenameOutput: Codable {
    public let libraryId: String
    public let oldName: String
    public let newName: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case oldName = "old_name"
        case newName = "new_name"
    }
}

/// Library-specific settings
public struct LibrarySettings: Codable {
    public let generateThumbnails: Bool
    public let thumbnailQuality: UInt8
    public let enableAiTagging: Bool
    public let syncEnabled: Bool
    public let encryptionEnabled: Bool
    public let thumbnailSizes: [UInt32]
    public let ignoredExtensions: [String]
    public let maxFileSize: UInt64?
    public let autoTrackSystemVolumes: Bool
    public let autoTrackExternalVolumes: Bool
    public let indexer: IndexerSettings?

    private enum CodingKeys: String, CodingKey {
        case generateThumbnails = "generate_thumbnails"
        case thumbnailQuality = "thumbnail_quality"
        case enableAiTagging = "enable_ai_tagging"
        case syncEnabled = "sync_enabled"
        case encryptionEnabled = "encryption_enabled"
        case thumbnailSizes = "thumbnail_sizes"
        case ignoredExtensions = "ignored_extensions"
        case maxFileSize = "max_file_size"
        case autoTrackSystemVolumes = "auto_track_system_volumes"
        case autoTrackExternalVolumes = "auto_track_external_volumes"
        case indexer = "indexer"
    }
}

/// Library statistics
public struct LibraryStatistics: Codable {
    public let totalFiles: UInt64
    public let totalSize: UInt64
    public let locationCount: UInt32
    public let tagCount: UInt32
    public let thumbnailCount: UInt64
    public let lastIndexed: String?
    public let updatedAt: String

    private enum CodingKeys: String, CodingKey {
        case totalFiles = "total_files"
        case totalSize = "total_size"
        case locationCount = "location_count"
        case tagCount = "tag_count"
        case thumbnailCount = "thumbnail_count"
        case lastIndexed = "last_indexed"
        case updatedAt = "updated_at"
    }
}

public struct ListDevicesInput: Codable {
    public let pairedOnly: Bool
    public let connectedOnly: Bool

    private enum CodingKeys: String, CodingKey {
        case pairedOnly = "paired_only"
        case connectedOnly = "connected_only"
    }
}

public struct ListLibrariesInput: Codable {
    public let includeStats: Bool

    private enum CodingKeys: String, CodingKey {
        case includeStats = "include_stats"
    }
}

public struct LocationAddInput: Codable {
    public let path: String
    public let name: String?
    public let mode: IndexMode
}

/// Output from location add action dispatch
public struct LocationAddOutput: Codable {
    public let locationId: String
    public let path: String
    public let name: String?
    public let jobId: String?

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
        case path = "path"
        case name = "name"
        case jobId = "job_id"
    }
}

public struct LocationInfo: Codable {
    public let id: String
    public let path: String
    public let name: String?
}

public struct LocationRemoveInput: Codable {
    public let locationId: String

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
    }
}

/// Output from location remove action dispatch
public struct LocationRemoveOutput: Codable {
    public let locationId: String
    public let path: String?

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
        case path = "path"
    }
}

public struct LocationRescanInput: Codable {
    public let locationId: String
    public let fullRescan: Bool

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
        case fullRescan = "full_rescan"
    }
}

public struct LocationRescanOutput: Codable {
    public let locationId: String
    public let locationPath: String
    public let jobId: String
    public let fullRescan: Bool

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
        case locationPath = "location_path"
        case jobId = "job_id"
        case fullRescan = "full_rescan"
    }
}

public struct LocationsListOutput: Codable {
    public let locations: [LocationInfo]
}

public struct LocationsListQueryInput: Codable {
Void}

public struct NetworkStartInput: Codable {
}

public struct NetworkStartOutput: Codable {
    public let started: Bool
}

public struct NetworkStatus: Codable {
    public let running: Bool
    public let nodeId: String?
    public let addresses: [String]
    public let pairedDevices: UInt
    public let connectedDevices: UInt
    public let version: String

    private enum CodingKeys: String, CodingKey {
        case running = "running"
        case nodeId = "node_id"
        case addresses = "addresses"
        case pairedDevices = "paired_devices"
        case connectedDevices = "connected_devices"
        case version = "version"
    }
}

public struct NetworkStatus: Codable {
    public let enabled: Bool
    public let nodeId: String?
    public let pairedDevices: [PairedDeviceInfo]
    public let activeConnections: UInt
    public let discoveryEnabled: Bool

    private enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
        case nodeId = "node_id"
        case pairedDevices = "paired_devices"
        case activeConnections = "active_connections"
        case discoveryEnabled = "discovery_enabled"
    }
}

public struct NetworkStatusQueryInput: Codable {
Void}

public struct NetworkStopInput: Codable {
}

public struct NetworkStopOutput: Codable {
    public let stopped: Bool
}

/// Pagination information
public struct PaginationInfo: Codable {
    public let currentPage: UInt32
    public let totalPages: UInt32
    public let hasNext: Bool
    public let hasPrevious: Bool
    public let limit: UInt32
    public let offset: UInt32

    private enum CodingKeys: String, CodingKey {
        case currentPage = "current_page"
        case totalPages = "total_pages"
        case hasNext = "has_next"
        case hasPrevious = "has_previous"
        case limit = "limit"
        case offset = "offset"
    }
}

/// Pagination options
public struct PaginationOptions: Codable {
    public let limit: UInt32
    public let offset: UInt32
}

public struct PairCancelInput: Codable {
    public let sessionId: String

    private enum CodingKeys: String, CodingKey {
        case sessionId = "session_id"
    }
}

public struct PairCancelOutput: Codable {
    public let cancelled: Bool
}

public struct PairGenerateInput: Codable {
    public let autoAccept: Bool

    private enum CodingKeys: String, CodingKey {
        case autoAccept = "auto_accept"
    }
}

public struct PairGenerateOutput: Codable {
    public let code: String
    public let sessionId: String
    public let expiresAt: String

    private enum CodingKeys: String, CodingKey {
        case code = "code"
        case sessionId = "session_id"
        case expiresAt = "expires_at"
    }
}

public struct PairJoinInput: Codable {
    public let code: String
}

public struct PairJoinOutput: Codable {
    public let pairedDeviceId: String
    public let deviceName: String

    private enum CodingKeys: String, CodingKey {
        case pairedDeviceId = "paired_device_id"
        case deviceName = "device_name"
    }
}

public struct PairStatusOutput: Codable {
    public let sessions: [PairingSessionSummary]
}

public struct PairStatusQueryInput: Codable {
Void}

public struct PairedDeviceInfo: Codable {
    public let id: String
    public let name: String
    public let os: String
    public let isOnline: Bool
    public let lastSeen: String
    public let pairedAt: String

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case os = "os"
        case isOnline = "is_online"
        case lastSeen = "last_seen"
        case pairedAt = "paired_at"
    }
}

public struct PairingSessionSummary: Codable {
    public let id: String
    public let state: SerializablePairingState
    public let remoteDeviceId: String?
    public let expiresAt: String?

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case state = "state"
        case remoteDeviceId = "remote_device_id"
        case expiresAt = "expires_at"
    }
}

/// Privacy levels for tag visibility control
public enum PrivacyLevel: Codable {
    case normal
    case archive
    case hidden
}

/// Detailed breakdown of how the score was calculated
public struct ScoreBreakdown: Codable {
    public let temporalScore: Float
    public let semanticScore: Float?
    public let metadataScore: Float
    public let recencyBoost: Float
    public let userPreferenceBoost: Float
    public let finalScore: Float

    private enum CodingKeys: String, CodingKey {
        case temporalScore = "temporal_score"
        case semanticScore = "semantic_score"
        case metadataScore = "metadata_score"
        case recencyBoost = "recency_boost"
        case userPreferenceBoost = "user_preference_boost"
        case finalScore = "final_score"
    }
}

/// A path within the Spacedrive Virtual Distributed File System
/// 
/// This is the core abstraction that enables cross-device operations.
/// An SdPath can represent:
/// - A physical file at a specific path on a specific device
/// - A content-addressed file that can be sourced from any device
/// 
/// This enum-based approach enables resilient file operations by allowing
/// content-based paths to be resolved to optimal physical locations at runtime.
public enum SdPath {
    case physical(SdPathPhysicalData)
    case content(SdPathContentData)
}
public struct SdPathPhysicalData: Codable {
    public let deviceId: String
    public let path: String

    private enum CodingKeys: String, CodingKey {
        case deviceId = "device_id"
        case path = "path"
    }
}

public struct SdPathContentData: Codable {
    public let contentId: String

    private enum CodingKeys: String, CodingKey {
        case contentId = "content_id"
    }
}

// MARK: - SdPath Codable Implementation
extension SdPath: Codable {
    private enum CodingKeys: String, CodingKey {
        case physical = "Physical"
        case content = "Content"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .physical:
            let data = try container.decode(SdPathPhysicalData.self, forKey: .physical)
            self = .physical(data)
        case .content:
            let data = try container.decode(SdPathContentData.self, forKey: .content)
            self = .content(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .physical(let data):
            try container.encode(data, forKey: .physical)
        case .content(let data):
            try container.encode(data, forKey: .content)
        }
    }
}


/// A batch of SdPaths, useful for operations on multiple files
public struct SdPathBatch: Codable {
    public let paths: [SdPath]
}

/// How SdPath is stored in the database
public struct SdPathSerialized: Codable {
    public let deviceId: String
    public let path: String

    private enum CodingKeys: String, CodingKey {
        case deviceId = "device_id"
        case path = "path"
    }
}

/// Search facets for filtering UI
public struct SearchFacets: Codable {
    public let fileTypes: [String: UInt64]
    public let tags: [String: UInt64]
    public let locations: [String: UInt64]
    public let dateRanges: [String: UInt64]
    public let sizeRanges: [String: UInt64]

    private enum CodingKeys: String, CodingKey {
        case fileTypes = "file_types"
        case tags = "tags"
        case locations = "locations"
        case dateRanges = "date_ranges"
        case sizeRanges = "size_ranges"
    }
}

/// Container for all structured filters
public struct SearchFilters: Codable {
    public let fileTypes: [String]?
    public let tags: TagFilter?
    public let dateRange: DateRangeFilter?
    public let sizeRange: SizeRangeFilter?
    public let locations: [String]?
    public let contentTypes: [ContentKind]?
    public let includeHidden: Bool?
    public let includeArchived: Bool?

    private enum CodingKeys: String, CodingKey {
        case fileTypes = "file_types"
        case tags = "tags"
        case dateRange = "date_range"
        case sizeRange = "size_range"
        case locations = "locations"
        case contentTypes = "content_types"
        case includeHidden = "include_hidden"
        case includeArchived = "include_archived"
    }
}

public struct SearchFilters: Codable {
    public let namespace: String?
    public let tagType: String?
    public let includeArchived: Bool
    public let limit: UInt?

    private enum CodingKeys: String, CodingKey {
        case namespace = "namespace"
        case tagType = "tag_type"
        case includeArchived = "include_archived"
        case limit = "limit"
    }
}

/// Defines the search mode and performance characteristics
public enum SearchMode: Codable {
    case fast
    case normal
    case full
}

/// Defines the scope of the filesystem to search within
public enum SearchScope {
    case library
    case location(SearchScopeLocationData)
    case path(SearchScopePathData)
}
public struct SearchScopeLocationData: Codable {
    public let locationId: String

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
    }
}

public struct SearchScopePathData: Codable {
    public let path: SdPath
}

// MARK: - SearchScope Codable Implementation
extension SearchScope: Codable {
    private enum CodingKeys: String, CodingKey {
        case library = "Library"
        case location = "Location"
        case path = "Path"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .library:
            self = .library
        case .location:
            let data = try container.decode(SearchScopeLocationData.self, forKey: .location)
            self = .location(data)
        case .path:
            let data = try container.decode(SearchScopePathData.self, forKey: .path)
            self = .path(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .library:
            try container.encodeNil(forKey: .library)
        case .location(let data):
            try container.encode(data, forKey: .location)
        case .path(let data):
            try container.encode(data, forKey: .path)
        }
    }
}


public struct SearchTagsInput: Codable {
    public let query: String
    public let namespace: String?
    public let tagType: TagType?
    public let includeArchived: Bool?
    public let limit: UInt?
    public let resolveAmbiguous: Bool?
    public let contextTagIds: [String]?

    private enum CodingKeys: String, CodingKey {
        case query = "query"
        case namespace = "namespace"
        case tagType = "tag_type"
        case includeArchived = "include_archived"
        case limit = "limit"
        case resolveAmbiguous = "resolve_ambiguous"
        case contextTagIds = "context_tag_ids"
    }
}

public struct SearchTagsOutput: Codable {
    public let tags: [TagSearchResult]
    public let totalFound: UInt
    public let disambiguated: Bool
    public let query: String
    public let filters: SearchFilters

    private enum CodingKeys: String, CodingKey {
        case tags = "tags"
        case totalFound = "total_found"
        case disambiguated = "disambiguated"
        case query = "query"
        case filters = "filters"
    }
}

public enum SerializablePairingState {
    case idle
    case generatingCode
    case broadcasting
    case scanning
    case waitingForConnection
    case connecting
    case authenticating
    case exchangingKeys
    case awaitingConfirmation
    case establishingSession
    case challengeReceived
    case responsePending
    case responseSent
    case completed
    case failed(SerializablePairingStateFailedData)
}
public struct SerializablePairingStateFailedData: Codable {
    public let reason: String
}

// MARK: - SerializablePairingState Codable Implementation
extension SerializablePairingState: Codable {
    private enum CodingKeys: String, CodingKey {
        case idle = "Idle"
        case generatingCode = "GeneratingCode"
        case broadcasting = "Broadcasting"
        case scanning = "Scanning"
        case waitingForConnection = "WaitingForConnection"
        case connecting = "Connecting"
        case authenticating = "Authenticating"
        case exchangingKeys = "ExchangingKeys"
        case awaitingConfirmation = "AwaitingConfirmation"
        case establishingSession = "EstablishingSession"
        case challengeReceived = "ChallengeReceived"
        case responsePending = "ResponsePending"
        case responseSent = "ResponseSent"
        case completed = "Completed"
        case failed = "Failed"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .idle:
            self = .idle
        case .generatingCode:
            self = .generatingCode
        case .broadcasting:
            self = .broadcasting
        case .scanning:
            self = .scanning
        case .waitingForConnection:
            self = .waitingForConnection
        case .connecting:
            self = .connecting
        case .authenticating:
            self = .authenticating
        case .exchangingKeys:
            self = .exchangingKeys
        case .awaitingConfirmation:
            self = .awaitingConfirmation
        case .establishingSession:
            self = .establishingSession
        case .challengeReceived:
            self = .challengeReceived
        case .responsePending:
            self = .responsePending
        case .responseSent:
            self = .responseSent
        case .completed:
            self = .completed
        case .failed:
            let data = try container.decode(SerializablePairingStateFailedData.self, forKey: .failed)
            self = .failed(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .idle:
            try container.encodeNil(forKey: .idle)
        case .generatingCode:
            try container.encodeNil(forKey: .generatingCode)
        case .broadcasting:
            try container.encodeNil(forKey: .broadcasting)
        case .scanning:
            try container.encodeNil(forKey: .scanning)
        case .waitingForConnection:
            try container.encodeNil(forKey: .waitingForConnection)
        case .connecting:
            try container.encodeNil(forKey: .connecting)
        case .authenticating:
            try container.encodeNil(forKey: .authenticating)
        case .exchangingKeys:
            try container.encodeNil(forKey: .exchangingKeys)
        case .awaitingConfirmation:
            try container.encodeNil(forKey: .awaitingConfirmation)
        case .establishingSession:
            try container.encodeNil(forKey: .establishingSession)
        case .challengeReceived:
            try container.encodeNil(forKey: .challengeReceived)
        case .responsePending:
            try container.encodeNil(forKey: .responsePending)
        case .responseSent:
            try container.encodeNil(forKey: .responseSent)
        case .completed:
            try container.encodeNil(forKey: .completed)
        case .failed(let data):
            try container.encode(data, forKey: .failed)
        }
    }
}


public struct ServiceState: Codable {
    public let running: Bool
    public let details: String?
}

public struct ServiceStatus: Codable {
    public let locationWatcher: ServiceState
    public let networking: ServiceState
    public let volumeMonitor: ServiceState
    public let fileSharing: ServiceState

    private enum CodingKeys: String, CodingKey {
        case locationWatcher = "location_watcher"
        case networking = "networking"
        case volumeMonitor = "volume_monitor"
        case fileSharing = "file_sharing"
    }
}

/// Filter for file size in bytes
public struct SizeRangeFilter: Codable {
    public let min: UInt64?
    public let max: UInt64?
}

/// Sort direction
public enum SortDirection: Codable {
    case asc
    case desc
}

/// Fields that can be used for sorting
public enum SortField: Codable {
    case relevance
    case name
    case size
    case modifiedAt
    case createdAt
}

/// Sorting options for search results
public struct SortOptions: Codable {
    public let field: SortField
    public let direction: SortDirection
}

public struct SpacedropSendInput: Codable {
    public let deviceId: String
    public let paths: [SdPath]
    public let sender: String?

    private enum CodingKeys: String, CodingKey {
        case deviceId = "device_id"
        case paths = "paths"
        case sender = "sender"
    }
}

public struct SpacedropSendOutput: Codable {
    public let jobId: String?
    public let sessionId: String?

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case sessionId = "session_id"
    }
}

public struct SystemInfo: Codable {
    public let uptime: UInt64?
    public let dataDirectory: String
    public let instanceName: String?
    public let currentLibrary: String?

    private enum CodingKeys: String, CodingKey {
        case uptime = "uptime"
        case dataDirectory = "data_directory"
        case instanceName = "instance_name"
        case currentLibrary = "current_library"
    }
}

/// A tag with advanced capabilities for contextual organization
public struct Tag: Codable {
    public let id: String
    public let canonicalName: String
    public let displayName: String?
    public let formalName: String?
    public let abbreviation: String?
    public let aliases: [String]
    public let namespace: String?
    public let tagType: TagType
    public let color: String?
    public let icon: String?
    public let description: String?
    public let isOrganizationalAnchor: Bool
    public let privacyLevel: PrivacyLevel
    public let searchWeight: Int32
    public let attributes: [String: JsonValue]
    public let compositionRules: [CompositionRule]
    public let createdAt: String
    public let updatedAt: String
    public let createdByDevice: String

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case canonicalName = "canonical_name"
        case displayName = "display_name"
        case formalName = "formal_name"
        case abbreviation = "abbreviation"
        case aliases = "aliases"
        case namespace = "namespace"
        case tagType = "tag_type"
        case color = "color"
        case icon = "icon"
        case description = "description"
        case isOrganizationalAnchor = "is_organizational_anchor"
        case privacyLevel = "privacy_level"
        case searchWeight = "search_weight"
        case attributes = "attributes"
        case compositionRules = "composition_rules"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
        case createdByDevice = "created_by_device"
    }
}

/// Filter for tags, supporting complex boolean logic
public struct TagFilter: Codable {
    public let include: [String]
    public let exclude: [String]
}

public struct TagSearchResult: Codable {
    public let tag: Tag
    public let relevance: Float
    public let matchedVariant: String?
    public let contextScore: Float?

    private enum CodingKeys: String, CodingKey {
        case tag = "tag"
        case relevance = "relevance"
        case matchedVariant = "matched_variant"
        case contextScore = "context_score"
    }
}

/// Source of tag application
public enum TagSource: Codable {
    case user
    case aI
    case import
    case sync
}

/// Types of semantic tags with different behaviors
public enum TagType: Codable {
    case standard
    case organizational
    case privacy
    case system
}

/// Text highlighting information
public struct TextHighlight: Codable {
    public let field: String
    public let text: String
    public let start: UInt
    public let end: UInt
}

public struct ThumbnailInput: Codable {
    public let paths: [String]
    public let size: UInt32
    public let quality: UInt8
}

/// Unique fingerprint for a storage volume
public struct VolumeFingerprint: Codable {
    let value: String
}

public struct VolumeSpeedTestInput: Codable {
    public let fingerprint: VolumeFingerprint
}

/// Output from volume speed test operation
public struct VolumeSpeedTestOutput: Codable {
    public let fingerprint: VolumeFingerprint
    public let readSpeedMbps: UInt32?
    public let writeSpeedMbps: UInt32?

    private enum CodingKeys: String, CodingKey {
        case fingerprint = "fingerprint"
        case readSpeedMbps = "read_speed_mbps"
        case writeSpeedMbps = "write_speed_mbps"
    }
}

public struct VolumeTrackInput: Codable {
    public let fingerprint: VolumeFingerprint
    public let name: String?
}

/// Output from volume track operation
public struct VolumeTrackOutput: Codable {
    public let fingerprint: VolumeFingerprint
    public let volumeName: String

    private enum CodingKeys: String, CodingKey {
        case fingerprint = "fingerprint"
        case volumeName = "volume_name"
    }
}

public struct VolumeUntrackInput: Codable {
    public let fingerprint: VolumeFingerprint
}

/// Output from volume untrack operation
public struct VolumeUntrackOutput: Codable {
    public let fingerprint: VolumeFingerprint
}

