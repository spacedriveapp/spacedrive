// Generated by Spacedrive using Specta - DO NOT EDIT
import Foundation

/// Represents an APFS container (physical storage with multiple volumes)
public struct ApfsContainer: Codable {
    public let containerId: String
    public let uuid: String
    public let physicalStore: String
    public let totalCapacity: UInt64
    public let capacityInUse: UInt64
    public let capacityFree: UInt64
    public let volumes: [ApfsVolumeInfo]
}

/// APFS volume information within a container
public struct ApfsVolumeInfo: Codable {
    public let diskId: String
    public let uuid: String
    public let role: ApfsVolumeRole
    public let name: String
    public let mountPoint: String?
    public let capacityConsumed: UInt64
    public let sealed: Bool
    public let filevault: Bool
}

/// APFS volume roles in the container
public enum ApfsVolumeRole: Codable {
    case system
    case data
    case preboot
    case recovery
    case vm
    case other(String)
}

/// Represents the type of physical storage device
public enum DiskType: Codable {
    case ssd
    case hdd
    case unknown
}

/// A central event type that represents all events that can be emitted throughout the system
public enum Event: Codable {
    case corestarted
    case coreshutdown
    case librarycreated(id: String, name: String, path: String)
    case libraryopened(id: String, name: String, path: String)
    case libraryclosed(id: String, name: String)
    case librarydeleted(id: String, name: String, deletedData: Bool)
    case entrycreated(libraryId: String, entryId: String)
    case entrymodified(libraryId: String, entryId: String)
    case entrydeleted(libraryId: String, entryId: String)
    case entrymoved(libraryId: String, entryId: String, oldPath: String, newPath: String)
    case fsrawchange(libraryId: String, kind: FsRawEventKind)
    case volumeadded(Volume)
    case volumeremoved(fingerprint: VolumeFingerprint)
    case volumeupdated(fingerprint: VolumeFingerprint, oldInfo: VolumeInfo, newInfo: VolumeInfo)
    case volumespeedtested(fingerprint: VolumeFingerprint, readSpeedMbps: UInt64, writeSpeedMbps: UInt64)
    case volumemountchanged(fingerprint: VolumeFingerprint, isMounted: Bool)
    case volumeerror(fingerprint: VolumeFingerprint, error: String)
    case jobqueued(jobId: String, jobType: String)
    case jobstarted(jobId: String, jobType: String)
    case jobprogress(jobId: String, jobType: String, progress: Double, message: String?)
    case jobcompleted(jobId: String, jobType: String, output: JobOutput)
    case jobfailed(jobId: String, jobType: String, error: String)
    case jobcancelled(jobId: String, jobType: String)
    case jobpaused(jobId: String)
    case jobresumed(jobId: String)
    case indexingstarted(locationId: String)
    case indexingprogress(locationId: String, processed: UInt64, total: UInt64?)
    case indexingcompleted(locationId: String, totalFiles: UInt64, totalDirs: UInt64)
    case indexingfailed(locationId: String, error: String)
    case deviceconnected(deviceId: String, deviceName: String)
    case devicedisconnected(deviceId: String)
    case locationadded(libraryId: String, locationId: String, path: String)
    case locationremoved(libraryId: String, locationId: String)
    case filesindexed(libraryId: String, locationId: String, count: UInt)
    case thumbnailsgenerated(libraryId: String, count: UInt)
    case fileoperationcompleted(libraryId: String, operation: FileOperation, affectedFiles: UInt)
    case filesmodified(libraryId: String, paths: [String])
    case logmessage(timestamp: String, level: String, target: String, message: String, jobId: String?, libraryId: String?)
    case custom(eventType: String)
}

/// Types of file operations
public enum FileOperation: Codable {
    case copy
    case move
    case delete
    case rename
}

/// Represents the filesystem type of the volume
public enum FileSystem: Codable {
    case ntfs
    case fat32
    case ext4
    case apfs
    case exfat
    case btrfs
    case zfs
    case refs
    case other(String)
}

/// Raw filesystem event kinds emitted by the watcher without DB resolution
public enum FsRawEventKind: Codable {
    case create(path: String)
    case modify(path: String)
    case remove(path: String)
    case rename(from: String, to: String)
}

/// Generic progress information that all job types can convert into
public struct GenericProgress: Codable {
    public let percentage: Float
    public let phase: String
    public let currentPath: SdPath?
    public let message: String
    public let completion: ProgressCompletion
    public let performance: PerformanceMetrics
}

/// Comprehensive metrics for indexing operations
public struct IndexerMetrics: Codable {
    public let totalDuration: TimeInterval
    public let discoveryDuration: TimeInterval
    public let processingDuration: TimeInterval
    public let contentDuration: TimeInterval
    public let filesPerSecond: Float
    public let bytesPerSecond: Double
    public let dirsPerSecond: Float
    public let dbWrites: UInt64
    public let dbReads: UInt64
    public let batchCount: UInt64
    public let avgBatchSize: Float
    public let totalErrors: UInt64
    public let criticalErrors: UInt64
    public let nonCriticalErrors: UInt64
    public let skippedPaths: UInt64
    public let peakMemoryBytes: UInt64?
    public let avgMemoryBytes: UInt64?
}

/// Statistics collected during indexing
public struct IndexerStats: Codable {
    public let files: UInt64
    public let dirs: UInt64
    public let bytes: UInt64
    public let symlinks: UInt64
    public let skipped: UInt64
    public let errors: UInt64
}

public struct JobListItem: Codable {
    public let id: String
    public let name: String
    public let status: JobStatus
    public let progress: Float
}

public struct JobListOutput: Codable {
    public let jobs: [JobListItem]
}

/// Output from a completed job
public enum JobOutput: Codable {
    case success
    case filecopy(copiedCount: UInt, totalBytes: UInt64)
    case indexed(stats: IndexerStats, metrics: IndexerMetrics)
    case thumbnailsgenerated(generatedCount: UInt, failedCount: UInt)
    case thumbnailgeneration(generatedCount: UInt64, skippedCount: UInt64, errorCount: UInt64, totalSizeBytes: UInt64)
    case filemove(movedCount: UInt, failedCount: UInt, totalBytes: UInt64)
    case filedelete(deletedCount: UInt, failedCount: UInt, totalBytes: UInt64)
    case duplicatedetection(duplicateGroups: UInt, totalDuplicates: UInt, potentialSavings: UInt64)
    case filevalidation(validatedCount: UInt, issuesFound: UInt, totalBytesValidated: UInt64)
}

/// Current status of a job
public enum JobStatus: String, Codable {
    case queued = "queued"
    case running = "running"
    case paused = "paused"
    case completed = "completed"
    case failed = "failed"
    case cancelled = "cancelled"
}

/// Input for creating a new library
public struct LibraryCreateInput: Codable {
    public let name: String
    public let path: String?
}

/// Output from library create action dispatch
public struct LibraryCreateOutput: Codable {
    public let libraryId: String
    public let name: String
    public let path: String
}

/// Information about a library for listing purposes
public struct LibraryInfo: Codable {
    public let id: String
    public let name: String
    public let path: String
    public let stats: LibraryStatistics?
}

/// Library statistics
public struct LibraryStatistics: Codable {
    public let totalFiles: UInt64
    public let totalSize: UInt64
    public let locationCount: UInt32
    public let tagCount: UInt32
    public let thumbnailCount: UInt64
    public let lastIndexed: String?
    public let updatedAt: String
}

/// Represents how the volume is mounted in the system
public enum MountType: Codable {
    case system
    case external
    case network
    case virtual
}

/// Path mapping for resolving virtual paths to actual storage locations
public struct PathMapping: Codable {
    public let virtualPath: String
    public let actualPath: String
}

/// Performance and timing metrics
public struct PerformanceMetrics: Codable {
    public let rate: Float
    public let estimatedRemaining: TimeInterval?
    public let elapsed: TimeInterval?
    public let errorCount: UInt64
    public let warningCount: UInt64
}

/// Progress information for a job
public enum Progress: Codable {
    case count(current: UInt, total: UInt)
    case percentage(Float)
    case indeterminate(String)
    case bytes(current: UInt64, total: UInt64)
    case generic(GenericProgress)
}

/// Progress completion information
public struct ProgressCompletion: Codable {
    public let completed: UInt64
    public let total: UInt64
    public let bytesCompleted: UInt64?
    public let totalBytes: UInt64?
}

/// A path within the Spacedrive Virtual Distributed File System
/// 
/// This is the core abstraction that enables cross-device operations.
/// An SdPath can represent:
/// - A physical file at a specific path on a specific device
/// - A content-addressed file that can be sourced from any device
/// 
/// This enum-based approach enables resilient file operations by allowing
/// content-based paths to be resolved to optimal physical locations at runtime.
public enum SdPath: Codable {
    case physical(deviceId: String, path: String)
    case content(contentId: String)
}

/// A batch of SdPaths, useful for operations on multiple files
public struct SdPathBatch: Codable {
    public let paths: [SdPath]
}

/// Represents a physical or virtual storage volume in the system
public struct Volume: Codable {
    public let fingerprint: VolumeFingerprint
    public let deviceId: String
    public let name: String
    public let mountType: MountType
    public let volumeType: VolumeType
    public let mountPoint: String
    public let mountPoints: [String]
    public let isMounted: Bool
    public let diskType: DiskType
    public let fileSystem: FileSystem
    public let readOnly: Bool
    public let hardwareId: String?
    public let errorStatus: String?
    public let apfsContainer: ApfsContainer?
    public let containerVolumeId: String?
    public let pathMappings: [PathMapping]
    public let totalBytesCapacity: UInt64
    public let totalBytesAvailable: UInt64
    public let readSpeedMbps: UInt64?
    public let writeSpeedMbps: UInt64?
    public let isUserVisible: Bool
    public let autoTrackEligible: Bool
    public let lastUpdated: String
}

/// Unique fingerprint for a storage volume
public struct VolumeFingerprint: Codable {
    public let value: String
}

/// Summary information about a volume (for updates and caching)
public struct VolumeInfo: Codable {
    public let isMounted: Bool
    public let totalBytesAvailable: UInt64
    public let readSpeedMbps: UInt64?
    public let writeSpeedMbps: UInt64?
    public let errorStatus: String?
}

/// Classification of volume types for UX and auto-tracking decisions
public enum VolumeType: Codable {
    case primary
    case userdata
    case external
    case secondary
    case system
    case network
    case unknown
}
