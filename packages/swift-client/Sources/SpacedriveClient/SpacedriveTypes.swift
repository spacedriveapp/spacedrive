// Generated by Spacedrive using Specta + rspc-inspired type extraction - DO NOT EDIT
import Foundation

// MARK: - Duration Helper
/// Helper struct to decode Rust Duration format {"secs": u64, "nanos": u32}
public struct RustDuration: Codable {
    public let secs: UInt64
    public let nanos: UInt32
    
    public var timeInterval: TimeInterval {
        return Double(secs) + Double(nanos) / 1_000_000_000.0
    }
}

// MARK: - Generated Types

/// Represents an APFS container (physical storage with multiple volumes)
public struct ApfsContainer: Codable {
    public let containerId: String
    public let uuid: String
    public let physicalStore: String
    public let totalCapacity: UInt64
    public let capacityInUse: UInt64
    public let capacityFree: UInt64
    public let volumes: [ApfsVolumeInfo]

    private enum CodingKeys: String, CodingKey {
        case containerId = "container_id"
        case uuid = "uuid"
        case physicalStore = "physical_store"
        case totalCapacity = "total_capacity"
        case capacityInUse = "capacity_in_use"
        case capacityFree = "capacity_free"
        case volumes = "volumes"
    }
}

/// APFS volume information within a container
public struct ApfsVolumeInfo: Codable {
    public let diskId: String
    public let uuid: String
    public let role: ApfsVolumeRole
    public let name: String
    public let mountPoint: String?
    public let capacityConsumed: UInt64
    public let sealed: Bool
    public let filevault: Bool

    private enum CodingKeys: String, CodingKey {
        case diskId = "disk_id"
        case uuid = "uuid"
        case role = "role"
        case name = "name"
        case mountPoint = "mount_point"
        case capacityConsumed = "capacity_consumed"
        case sealed = "sealed"
        case filevault = "filevault"
    }
}

/// APFS volume roles in the container
public enum ApfsVolumeRole: Codable {
    case system
    case data
    case preboot
    case recovery
    case vM
    case other(String)
}

public struct ApplyTagsInput: Codable {
    public let entryIds: [Int32]
    public let tagIds: [String]
    public let source: TagSource?
    public let confidence: Float?
    public let appliedContext: String?
    public let instanceAttributes: [String: JsonValue]?

    private enum CodingKeys: String, CodingKey {
        case entryIds = "entry_ids"
        case tagIds = "tag_ids"
        case source = "source"
        case confidence = "confidence"
        case appliedContext = "applied_context"
        case instanceAttributes = "instance_attributes"
    }
}

public struct ApplyTagsOutput: Codable {
    public let entriesAffected: UInt
    public let tagsApplied: UInt
    public let appliedTagIds: [String]
    public let taggedEntryIds: [Int32]
    public let warnings: [String]
    public let message: String

    private enum CodingKeys: String, CodingKey {
        case entriesAffected = "entries_affected"
        case tagsApplied = "tags_applied"
        case appliedTagIds = "applied_tag_ids"
        case taggedEntryIds = "tagged_entry_ids"
        case warnings = "warnings"
        case message = "message"
    }
}

/// Operators for combining tag attributes
public enum CompositionOperator: Codable {
    case and
    case or
    case with
    case without
}

/// Rules for composing attributes from multiple tags
public struct CompositionRule: Codable {
    public let operator: CompositionOperator
    public let operands: [String]
    public let resultAttribute: String

    private enum CodingKeys: String, CodingKey {
        case operator = "operator"
        case operands = "operands"
        case resultAttribute = "result_attribute"
    }
}

/// Type of content
public enum ContentKind: String, Codable {
    case unknown = "unknown"
    case image = "image"
    case video = "video"
    case audio = "audio"
    case document = "document"
    case archive = "archive"
    case code = "code"
    case text = "text"
    case database = "database"
    case book = "book"
    case font = "font"
    case mesh = "mesh"
    case config = "config"
    case encrypted = "encrypted"
    case key = "key"
    case executable = "executable"
    case binary = "binary"
}

/// Copy method preference for file operations
public enum CopyMethod: Codable {
    case auto
    case atomic
    case streaming
}

public struct CoreStatus: Codable {
    public let version: String
    public let builtAt: String
    public let libraryCount: UInt
    public let deviceInfo: DeviceInfo
    public let libraries: [LibraryInfo]
    public let services: ServiceStatus
    public let network: NetworkStatus
    public let system: SystemInfo

    private enum CodingKeys: String, CodingKey {
        case version = "version"
        case builtAt = "built_at"
        case libraryCount = "library_count"
        case deviceInfo = "device_info"
        case libraries = "libraries"
        case services = "services"
        case network = "network"
        case system = "system"
    }
}

public struct CreateTagInput: Codable {
    public let canonicalName: String
    public let displayName: String?
    public let formalName: String?
    public let abbreviation: String?
    public let aliases: [String]
    public let namespace: String?
    public let tagType: TagType?
    public let color: String?
    public let icon: String?
    public let description: String?
    public let isOrganizationalAnchor: Bool?
    public let privacyLevel: PrivacyLevel?
    public let searchWeight: Int32?
    public let attributes: [String: JsonValue]?

    private enum CodingKeys: String, CodingKey {
        case canonicalName = "canonical_name"
        case displayName = "display_name"
        case formalName = "formal_name"
        case abbreviation = "abbreviation"
        case aliases = "aliases"
        case namespace = "namespace"
        case tagType = "tag_type"
        case color = "color"
        case icon = "icon"
        case description = "description"
        case isOrganizationalAnchor = "is_organizational_anchor"
        case privacyLevel = "privacy_level"
        case searchWeight = "search_weight"
        case attributes = "attributes"
    }
}

public struct CreateTagOutput: Codable {
    public let tagId: String
    public let canonicalName: String
    public let namespace: String?
    public let message: String

    private enum CodingKeys: String, CodingKey {
        case tagId = "tag_id"
        case canonicalName = "canonical_name"
        case namespace = "namespace"
        case message = "message"
    }
}

/// Time-based fields that can be filtered
public enum DateField: Codable {
    case createdAt
    case modifiedAt
    case accessedAt
}

/// Filter for a time-based field
public struct DateRangeFilter: Codable {
    public let field: DateField
    public let start: String?
    public let end: String?
}

public struct DeviceInfo: Codable {
    public let id: String
    public let name: String
    public let os: String
    public let hardwareModel: String?
    public let createdAt: String

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case os = "os"
        case hardwareModel = "hardware_model"
        case createdAt = "created_at"
    }
}

public struct DeviceInfoLite: Codable {
    public let id: String
    public let name: String
    public let osVersion: String
    public let appVersion: String
    public let isConnected: Bool
    public let lastSeen: String

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case osVersion = "os_version"
        case appVersion = "app_version"
        case isConnected = "is_connected"
        case lastSeen = "last_seen"
    }
}

public struct DeviceRevokeInput: Codable {
    public let deviceId: String

    private enum CodingKeys: String, CodingKey {
        case deviceId = "device_id"
    }
}

public struct DeviceRevokeOutput: Codable {
    public let revoked: Bool
}

/// Represents the type of physical storage device
public enum DiskType: Codable {
    case sSD
    case hDD
    case unknown
}

/// Input for file duplicate detection operations
public struct DuplicateDetectionInput: Codable {
    public let paths: [String]
    public let algorithm: String
    public let threshold: Double
}

/// Represents any filesystem entry (file or directory) in the VDFS
public struct Entry: Codable {
    public let id: String
    public let sdPath: SdPathSerialized
    public let name: String
    public let kind: EntryKind
    public let size: UInt64?
    public let createdAt: String?
    public let modifiedAt: String?
    public let accessedAt: String?
    public let inode: UInt64?
    public let fileId: UInt64?
    public let parentId: String?
    public let locationId: String?
    public let metadataId: String
    public let contentId: String?
    public let firstSeenAt: String
    public let lastIndexedAt: String?

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case sdPath = "sd_path"
        case name = "name"
        case kind = "kind"
        case size = "size"
        case createdAt = "created_at"
        case modifiedAt = "modified_at"
        case accessedAt = "accessed_at"
        case inode = "inode"
        case fileId = "file_id"
        case parentId = "parent_id"
        case locationId = "location_id"
        case metadataId = "metadata_id"
        case contentId = "content_id"
        case firstSeenAt = "first_seen_at"
        case lastIndexedAt = "last_indexed_at"
    }
}

/// Type of filesystem entry
public enum EntryKind {
    case file(EntryKindFileData)
    case directory
    case symlink(EntryKindSymlinkData)
}
public struct EntryKindFileData: Codable {
    public let extension: String?
}

public struct EntryKindSymlinkData: Codable {
    public let target: String
}

// MARK: - EntryKind Codable Implementation
extension EntryKind: Codable {
    private enum CodingKeys: String, CodingKey {
        case file = "File"
        case directory = "Directory"
        case symlink = "Symlink"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .file:
            let data = try container.decode(EntryKindFileData.self, forKey: .file)
            self = .file(data)
        case .directory:
            self = .directory
        case .symlink:
            let data = try container.decode(EntryKindSymlinkData.self, forKey: .symlink)
            self = .symlink(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .file(let data):
            try container.encode(data, forKey: .file)
        case .directory:
            try container.encodeNil(forKey: .directory)
        case .symlink(let data):
            try container.encode(data, forKey: .symlink)
        }
    }
}


/// A central event type that represents all events that can be emitted throughout the system
public enum Event {
    case coreStarted
    case coreShutdown
    case libraryCreated(EventLibraryCreatedData)
    case libraryOpened(EventLibraryOpenedData)
    case libraryClosed(EventLibraryClosedData)
    case libraryDeleted(EventLibraryDeletedData)
    case entryCreated(EventEntryCreatedData)
    case entryModified(EventEntryModifiedData)
    case entryDeleted(EventEntryDeletedData)
    case entryMoved(EventEntryMovedData)
    case fsRawChange(EventFsRawChangeData)
    case volumeAdded(Volume)
    case volumeRemoved(EventVolumeRemovedData)
    case volumeUpdated(EventVolumeUpdatedData)
    case volumeSpeedTested(EventVolumeSpeedTestedData)
    case volumeMountChanged(EventVolumeMountChangedData)
    case volumeError(EventVolumeErrorData)
    case jobQueued(EventJobQueuedData)
    case jobStarted(EventJobStartedData)
    case jobProgress(EventJobProgressData)
    case jobCompleted(EventJobCompletedData)
    case jobFailed(EventJobFailedData)
    case jobCancelled(EventJobCancelledData)
    case jobPaused(EventJobPausedData)
    case jobResumed(EventJobResumedData)
    case indexingStarted(EventIndexingStartedData)
    case indexingProgress(EventIndexingProgressData)
    case indexingCompleted(EventIndexingCompletedData)
    case indexingFailed(EventIndexingFailedData)
    case deviceConnected(EventDeviceConnectedData)
    case deviceDisconnected(EventDeviceDisconnectedData)
    case locationAdded(EventLocationAddedData)
    case locationRemoved(EventLocationRemovedData)
    case filesIndexed(EventFilesIndexedData)
    case thumbnailsGenerated(EventThumbnailsGeneratedData)
    case fileOperationCompleted(EventFileOperationCompletedData)
    case filesModified(EventFilesModifiedData)
    case logMessage(EventLogMessageData)
    case custom(EventCustomData)
}
public struct EventLibraryCreatedData: Codable {
    public let id: String
    public let name: String
    public let path: String
}

public struct EventLibraryOpenedData: Codable {
    public let id: String
    public let name: String
    public let path: String
}

public struct EventLibraryClosedData: Codable {
    public let id: String
    public let name: String
}

public struct EventLibraryDeletedData: Codable {
    public let id: String
    public let name: String
    public let deletedData: Bool

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case deletedData = "deleted_data"
    }
}

public struct EventEntryCreatedData: Codable {
    public let libraryId: String
    public let entryId: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case entryId = "entry_id"
    }
}

public struct EventEntryModifiedData: Codable {
    public let libraryId: String
    public let entryId: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case entryId = "entry_id"
    }
}

public struct EventEntryDeletedData: Codable {
    public let libraryId: String
    public let entryId: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case entryId = "entry_id"
    }
}

public struct EventEntryMovedData: Codable {
    public let libraryId: String
    public let entryId: String
    public let oldPath: String
    public let newPath: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case entryId = "entry_id"
        case oldPath = "old_path"
        case newPath = "new_path"
    }
}

public struct EventFsRawChangeData: Codable {
    public let libraryId: String
    public let kind: FsRawEventKind

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case kind = "kind"
    }
}

public struct EventVolumeRemovedData: Codable {
    public let fingerprint: VolumeFingerprint
}

public struct EventVolumeUpdatedData: Codable {
    public let fingerprint: VolumeFingerprint
    public let oldInfo: VolumeInfo
    public let newInfo: VolumeInfo

    private enum CodingKeys: String, CodingKey {
        case fingerprint = "fingerprint"
        case oldInfo = "old_info"
        case newInfo = "new_info"
    }
}

public struct EventVolumeSpeedTestedData: Codable {
    public let fingerprint: VolumeFingerprint
    public let readSpeedMbps: UInt64
    public let writeSpeedMbps: UInt64

    private enum CodingKeys: String, CodingKey {
        case fingerprint = "fingerprint"
        case readSpeedMbps = "read_speed_mbps"
        case writeSpeedMbps = "write_speed_mbps"
    }
}

public struct EventVolumeMountChangedData: Codable {
    public let fingerprint: VolumeFingerprint
    public let isMounted: Bool

    private enum CodingKeys: String, CodingKey {
        case fingerprint = "fingerprint"
        case isMounted = "is_mounted"
    }
}

public struct EventVolumeErrorData: Codable {
    public let fingerprint: VolumeFingerprint
    public let error: String
}

public struct EventJobQueuedData: Codable {
    public let jobId: String
    public let jobType: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case jobType = "job_type"
    }
}

public struct EventJobStartedData: Codable {
    public let jobId: String
    public let jobType: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case jobType = "job_type"
    }
}

public struct EventJobProgressData: Codable {
    public let jobId: String
    public let jobType: String
    public let progress: Double
    public let message: String?
    public let genericProgress: GenericProgress?

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case jobType = "job_type"
        case progress = "progress"
        case message = "message"
        case genericProgress = "generic_progress"
    }
}

public struct EventJobCompletedData: Codable {
    public let jobId: String
    public let jobType: String
    public let output: JobOutput

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case jobType = "job_type"
        case output = "output"
    }
}

public struct EventJobFailedData: Codable {
    public let jobId: String
    public let jobType: String
    public let error: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case jobType = "job_type"
        case error = "error"
    }
}

public struct EventJobCancelledData: Codable {
    public let jobId: String
    public let jobType: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case jobType = "job_type"
    }
}

public struct EventJobPausedData: Codable {
    public let jobId: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
    }
}

public struct EventJobResumedData: Codable {
    public let jobId: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
    }
}

public struct EventIndexingStartedData: Codable {
    public let locationId: String

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
    }
}

public struct EventIndexingProgressData: Codable {
    public let locationId: String
    public let processed: UInt64
    public let total: UInt64?

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
        case processed = "processed"
        case total = "total"
    }
}

public struct EventIndexingCompletedData: Codable {
    public let locationId: String
    public let totalFiles: UInt64
    public let totalDirs: UInt64

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
        case totalFiles = "total_files"
        case totalDirs = "total_dirs"
    }
}

public struct EventIndexingFailedData: Codable {
    public let locationId: String
    public let error: String

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
        case error = "error"
    }
}

public struct EventDeviceConnectedData: Codable {
    public let deviceId: String
    public let deviceName: String

    private enum CodingKeys: String, CodingKey {
        case deviceId = "device_id"
        case deviceName = "device_name"
    }
}

public struct EventDeviceDisconnectedData: Codable {
    public let deviceId: String

    private enum CodingKeys: String, CodingKey {
        case deviceId = "device_id"
    }
}

public struct EventLocationAddedData: Codable {
    public let libraryId: String
    public let locationId: String
    public let path: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case locationId = "location_id"
        case path = "path"
    }
}

public struct EventLocationRemovedData: Codable {
    public let libraryId: String
    public let locationId: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case locationId = "location_id"
    }
}

public struct EventFilesIndexedData: Codable {
    public let libraryId: String
    public let locationId: String
    public let count: UInt

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case locationId = "location_id"
        case count = "count"
    }
}

public struct EventThumbnailsGeneratedData: Codable {
    public let libraryId: String
    public let count: UInt

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case count = "count"
    }
}

public struct EventFileOperationCompletedData: Codable {
    public let libraryId: String
    public let operation: FileOperation
    public let affectedFiles: UInt

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case operation = "operation"
        case affectedFiles = "affected_files"
    }
}

public struct EventFilesModifiedData: Codable {
    public let libraryId: String
    public let paths: [String]

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case paths = "paths"
    }
}

public struct EventLogMessageData: Codable {
    public let timestamp: String
    public let level: String
    public let target: String
    public let message: String
    public let jobId: String?
    public let libraryId: String?

    private enum CodingKeys: String, CodingKey {
        case timestamp = "timestamp"
        case level = "level"
        case target = "target"
        case message = "message"
        case jobId = "job_id"
        case libraryId = "library_id"
    }
}

public struct EventCustomData: Codable {
    public let eventType: String

    private enum CodingKeys: String, CodingKey {
        case eventType = "event_type"
    }
}

// MARK: - Event Codable Implementation
extension Event: Codable {
    private enum CodingKeys: String, CodingKey {
        case coreStarted = "CoreStarted"
        case coreShutdown = "CoreShutdown"
        case libraryCreated = "LibraryCreated"
        case libraryOpened = "LibraryOpened"
        case libraryClosed = "LibraryClosed"
        case libraryDeleted = "LibraryDeleted"
        case entryCreated = "EntryCreated"
        case entryModified = "EntryModified"
        case entryDeleted = "EntryDeleted"
        case entryMoved = "EntryMoved"
        case fsRawChange = "FsRawChange"
        case volumeAdded = "VolumeAdded"
        case volumeRemoved = "VolumeRemoved"
        case volumeUpdated = "VolumeUpdated"
        case volumeSpeedTested = "VolumeSpeedTested"
        case volumeMountChanged = "VolumeMountChanged"
        case volumeError = "VolumeError"
        case jobQueued = "JobQueued"
        case jobStarted = "JobStarted"
        case jobProgress = "JobProgress"
        case jobCompleted = "JobCompleted"
        case jobFailed = "JobFailed"
        case jobCancelled = "JobCancelled"
        case jobPaused = "JobPaused"
        case jobResumed = "JobResumed"
        case indexingStarted = "IndexingStarted"
        case indexingProgress = "IndexingProgress"
        case indexingCompleted = "IndexingCompleted"
        case indexingFailed = "IndexingFailed"
        case deviceConnected = "DeviceConnected"
        case deviceDisconnected = "DeviceDisconnected"
        case locationAdded = "LocationAdded"
        case locationRemoved = "LocationRemoved"
        case filesIndexed = "FilesIndexed"
        case thumbnailsGenerated = "ThumbnailsGenerated"
        case fileOperationCompleted = "FileOperationCompleted"
        case filesModified = "FilesModified"
        case logMessage = "LogMessage"
        case custom = "Custom"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .coreStarted:
            self = .coreStarted
        case .coreShutdown:
            self = .coreShutdown
        case .libraryCreated:
            let data = try container.decode(EventLibraryCreatedData.self, forKey: .libraryCreated)
            self = .libraryCreated(data)
        case .libraryOpened:
            let data = try container.decode(EventLibraryOpenedData.self, forKey: .libraryOpened)
            self = .libraryOpened(data)
        case .libraryClosed:
            let data = try container.decode(EventLibraryClosedData.self, forKey: .libraryClosed)
            self = .libraryClosed(data)
        case .libraryDeleted:
            let data = try container.decode(EventLibraryDeletedData.self, forKey: .libraryDeleted)
            self = .libraryDeleted(data)
        case .entryCreated:
            let data = try container.decode(EventEntryCreatedData.self, forKey: .entryCreated)
            self = .entryCreated(data)
        case .entryModified:
            let data = try container.decode(EventEntryModifiedData.self, forKey: .entryModified)
            self = .entryModified(data)
        case .entryDeleted:
            let data = try container.decode(EventEntryDeletedData.self, forKey: .entryDeleted)
            self = .entryDeleted(data)
        case .entryMoved:
            let data = try container.decode(EventEntryMovedData.self, forKey: .entryMoved)
            self = .entryMoved(data)
        case .fsRawChange:
            let data = try container.decode(EventFsRawChangeData.self, forKey: .fsRawChange)
            self = .fsRawChange(data)
        case .volumeAdded:
            // TODO: Implement tuple variant decoding for volumeAdded
            fatalError("Tuple variant decoding not implemented")
        case .volumeRemoved:
            let data = try container.decode(EventVolumeRemovedData.self, forKey: .volumeRemoved)
            self = .volumeRemoved(data)
        case .volumeUpdated:
            let data = try container.decode(EventVolumeUpdatedData.self, forKey: .volumeUpdated)
            self = .volumeUpdated(data)
        case .volumeSpeedTested:
            let data = try container.decode(EventVolumeSpeedTestedData.self, forKey: .volumeSpeedTested)
            self = .volumeSpeedTested(data)
        case .volumeMountChanged:
            let data = try container.decode(EventVolumeMountChangedData.self, forKey: .volumeMountChanged)
            self = .volumeMountChanged(data)
        case .volumeError:
            let data = try container.decode(EventVolumeErrorData.self, forKey: .volumeError)
            self = .volumeError(data)
        case .jobQueued:
            let data = try container.decode(EventJobQueuedData.self, forKey: .jobQueued)
            self = .jobQueued(data)
        case .jobStarted:
            let data = try container.decode(EventJobStartedData.self, forKey: .jobStarted)
            self = .jobStarted(data)
        case .jobProgress:
            let data = try container.decode(EventJobProgressData.self, forKey: .jobProgress)
            self = .jobProgress(data)
        case .jobCompleted:
            let data = try container.decode(EventJobCompletedData.self, forKey: .jobCompleted)
            self = .jobCompleted(data)
        case .jobFailed:
            let data = try container.decode(EventJobFailedData.self, forKey: .jobFailed)
            self = .jobFailed(data)
        case .jobCancelled:
            let data = try container.decode(EventJobCancelledData.self, forKey: .jobCancelled)
            self = .jobCancelled(data)
        case .jobPaused:
            let data = try container.decode(EventJobPausedData.self, forKey: .jobPaused)
            self = .jobPaused(data)
        case .jobResumed:
            let data = try container.decode(EventJobResumedData.self, forKey: .jobResumed)
            self = .jobResumed(data)
        case .indexingStarted:
            let data = try container.decode(EventIndexingStartedData.self, forKey: .indexingStarted)
            self = .indexingStarted(data)
        case .indexingProgress:
            let data = try container.decode(EventIndexingProgressData.self, forKey: .indexingProgress)
            self = .indexingProgress(data)
        case .indexingCompleted:
            let data = try container.decode(EventIndexingCompletedData.self, forKey: .indexingCompleted)
            self = .indexingCompleted(data)
        case .indexingFailed:
            let data = try container.decode(EventIndexingFailedData.self, forKey: .indexingFailed)
            self = .indexingFailed(data)
        case .deviceConnected:
            let data = try container.decode(EventDeviceConnectedData.self, forKey: .deviceConnected)
            self = .deviceConnected(data)
        case .deviceDisconnected:
            let data = try container.decode(EventDeviceDisconnectedData.self, forKey: .deviceDisconnected)
            self = .deviceDisconnected(data)
        case .locationAdded:
            let data = try container.decode(EventLocationAddedData.self, forKey: .locationAdded)
            self = .locationAdded(data)
        case .locationRemoved:
            let data = try container.decode(EventLocationRemovedData.self, forKey: .locationRemoved)
            self = .locationRemoved(data)
        case .filesIndexed:
            let data = try container.decode(EventFilesIndexedData.self, forKey: .filesIndexed)
            self = .filesIndexed(data)
        case .thumbnailsGenerated:
            let data = try container.decode(EventThumbnailsGeneratedData.self, forKey: .thumbnailsGenerated)
            self = .thumbnailsGenerated(data)
        case .fileOperationCompleted:
            let data = try container.decode(EventFileOperationCompletedData.self, forKey: .fileOperationCompleted)
            self = .fileOperationCompleted(data)
        case .filesModified:
            let data = try container.decode(EventFilesModifiedData.self, forKey: .filesModified)
            self = .filesModified(data)
        case .logMessage:
            let data = try container.decode(EventLogMessageData.self, forKey: .logMessage)
            self = .logMessage(data)
        case .custom:
            let data = try container.decode(EventCustomData.self, forKey: .custom)
            self = .custom(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .coreStarted:
            try container.encodeNil(forKey: .coreStarted)
        case .coreShutdown:
            try container.encodeNil(forKey: .coreShutdown)
        case .libraryCreated(let data):
            try container.encode(data, forKey: .libraryCreated)
        case .libraryOpened(let data):
            try container.encode(data, forKey: .libraryOpened)
        case .libraryClosed(let data):
            try container.encode(data, forKey: .libraryClosed)
        case .libraryDeleted(let data):
            try container.encode(data, forKey: .libraryDeleted)
        case .entryCreated(let data):
            try container.encode(data, forKey: .entryCreated)
        case .entryModified(let data):
            try container.encode(data, forKey: .entryModified)
        case .entryDeleted(let data):
            try container.encode(data, forKey: .entryDeleted)
        case .entryMoved(let data):
            try container.encode(data, forKey: .entryMoved)
        case .fsRawChange(let data):
            try container.encode(data, forKey: .fsRawChange)
        case .volumeAdded:
            // TODO: Implement tuple variant encoding for volumeAdded
            fatalError("Tuple variant encoding not implemented")
        case .volumeRemoved(let data):
            try container.encode(data, forKey: .volumeRemoved)
        case .volumeUpdated(let data):
            try container.encode(data, forKey: .volumeUpdated)
        case .volumeSpeedTested(let data):
            try container.encode(data, forKey: .volumeSpeedTested)
        case .volumeMountChanged(let data):
            try container.encode(data, forKey: .volumeMountChanged)
        case .volumeError(let data):
            try container.encode(data, forKey: .volumeError)
        case .jobQueued(let data):
            try container.encode(data, forKey: .jobQueued)
        case .jobStarted(let data):
            try container.encode(data, forKey: .jobStarted)
        case .jobProgress(let data):
            try container.encode(data, forKey: .jobProgress)
        case .jobCompleted(let data):
            try container.encode(data, forKey: .jobCompleted)
        case .jobFailed(let data):
            try container.encode(data, forKey: .jobFailed)
        case .jobCancelled(let data):
            try container.encode(data, forKey: .jobCancelled)
        case .jobPaused(let data):
            try container.encode(data, forKey: .jobPaused)
        case .jobResumed(let data):
            try container.encode(data, forKey: .jobResumed)
        case .indexingStarted(let data):
            try container.encode(data, forKey: .indexingStarted)
        case .indexingProgress(let data):
            try container.encode(data, forKey: .indexingProgress)
        case .indexingCompleted(let data):
            try container.encode(data, forKey: .indexingCompleted)
        case .indexingFailed(let data):
            try container.encode(data, forKey: .indexingFailed)
        case .deviceConnected(let data):
            try container.encode(data, forKey: .deviceConnected)
        case .deviceDisconnected(let data):
            try container.encode(data, forKey: .deviceDisconnected)
        case .locationAdded(let data):
            try container.encode(data, forKey: .locationAdded)
        case .locationRemoved(let data):
            try container.encode(data, forKey: .locationRemoved)
        case .filesIndexed(let data):
            try container.encode(data, forKey: .filesIndexed)
        case .thumbnailsGenerated(let data):
            try container.encode(data, forKey: .thumbnailsGenerated)
        case .fileOperationCompleted(let data):
            try container.encode(data, forKey: .fileOperationCompleted)
        case .filesModified(let data):
            try container.encode(data, forKey: .filesModified)
        case .logMessage(let data):
            try container.encode(data, forKey: .logMessage)
        case .custom(let data):
            try container.encode(data, forKey: .custom)
        }
    }
}


/// Internal enum for file conflict resolution strategies
public enum FileConflictResolution: Codable {
    case overwrite
    case autoModifyName
    case abort
}

/// Core input structure for file copy operations
/// This is the canonical interface that all external APIs (CLI, GraphQL, REST) convert to
public struct FileCopyInput: Codable {
    public let sources: SdPathBatch
    public let destination: SdPath
    public let overwrite: Bool
    public let verifyChecksum: Bool
    public let preserveTimestamps: Bool
    public let moveFiles: Bool
    public let copyMethod: CopyMethod
    public let onConflict: FileConflictResolution?

    private enum CodingKeys: String, CodingKey {
        case sources = "sources"
        case destination = "destination"
        case overwrite = "overwrite"
        case verifyChecksum = "verify_checksum"
        case preserveTimestamps = "preserve_timestamps"
        case moveFiles = "move_files"
        case copyMethod = "copy_method"
        case onConflict = "on_conflict"
    }
}

/// Input for deleting files
public struct FileDeleteInput: Codable {
    public let targets: SdPathBatch
    public let permanent: Bool
    public let recursive: Bool
}

/// Types of file operations
public enum FileOperation: Codable {
    case copy
    case move
    case delete
    case rename
}

/// Main input structure for file search operations
public struct FileSearchInput: Codable {
    public let query: String
    public let scope: SearchScope
    public let mode: SearchMode
    public let filters: SearchFilters
    public let sort: SortOptions
    public let pagination: PaginationOptions
}

/// Main output structure for file search operations
public struct FileSearchOutput: Codable {
    public let results: [FileSearchResult]
    public let totalFound: UInt64
    public let searchId: String
    public let facets: SearchFacets
    public let suggestions: [String]
    public let pagination: PaginationInfo
    public let executionTimeMs: UInt64

    private enum CodingKeys: String, CodingKey {
        case results = "results"
        case totalFound = "total_found"
        case searchId = "search_id"
        case facets = "facets"
        case suggestions = "suggestions"
        case pagination = "pagination"
        case executionTimeMs = "execution_time_ms"
    }
}

/// Individual search result
public struct FileSearchResult: Codable {
    public let entry: Entry
    public let score: Float
    public let scoreBreakdown: ScoreBreakdown
    public let highlights: [TextHighlight]
    public let matchedContent: String?

    private enum CodingKeys: String, CodingKey {
        case entry = "entry"
        case score = "score"
        case scoreBreakdown = "score_breakdown"
        case highlights = "highlights"
        case matchedContent = "matched_content"
    }
}

/// Represents the filesystem type of the volume
public enum FileSystem: Codable {
    case nTFS
    case fAT32
    case eXT4
    case aPFS
    case exFAT
    case btrfs
    case zFS
    case reFS
    case other(String)
}

/// Input for file validation operations
public struct FileValidationInput: Codable {
    public let paths: [String]
    public let verifyChecksums: Bool
    public let deepScan: Bool

    private enum CodingKeys: String, CodingKey {
        case paths = "paths"
        case verifyChecksums = "verify_checksums"
        case deepScan = "deep_scan"
    }
}

/// Raw filesystem event kinds emitted by the watcher without DB resolution
public enum FsRawEventKind {
    case create(FsRawEventKindCreateData)
    case modify(FsRawEventKindModifyData)
    case remove(FsRawEventKindRemoveData)
    case rename(FsRawEventKindRenameData)
}
public struct FsRawEventKindCreateData: Codable {
    public let path: String
}

public struct FsRawEventKindModifyData: Codable {
    public let path: String
}

public struct FsRawEventKindRemoveData: Codable {
    public let path: String
}

public struct FsRawEventKindRenameData: Codable {
    public let from: String
    public let to: String
}

// MARK: - FsRawEventKind Codable Implementation
extension FsRawEventKind: Codable {
    private enum CodingKeys: String, CodingKey {
        case create = "Create"
        case modify = "Modify"
        case remove = "Remove"
        case rename = "Rename"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .create:
            let data = try container.decode(FsRawEventKindCreateData.self, forKey: .create)
            self = .create(data)
        case .modify:
            let data = try container.decode(FsRawEventKindModifyData.self, forKey: .modify)
            self = .modify(data)
        case .remove:
            let data = try container.decode(FsRawEventKindRemoveData.self, forKey: .remove)
            self = .remove(data)
        case .rename:
            let data = try container.decode(FsRawEventKindRenameData.self, forKey: .rename)
            self = .rename(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .create(let data):
            try container.encode(data, forKey: .create)
        case .modify(let data):
            try container.encode(data, forKey: .modify)
        case .remove(let data):
            try container.encode(data, forKey: .remove)
        case .rename(let data):
            try container.encode(data, forKey: .rename)
        }
    }
}


/// Generic progress information that all job types can convert into
public struct GenericProgress: Codable {
    public let percentage: Float
    public let phase: String
    public let currentPath: SdPath?
    public let message: String
    public let completion: ProgressCompletion
    public let performance: PerformanceMetrics

    private enum CodingKeys: String, CodingKey {
        case percentage = "percentage"
        case phase = "phase"
        case currentPath = "current_path"
        case message = "message"
        case completion = "completion"
        case performance = "performance"
    }
}

/// Canonical input for indexing requests from any interface (CLI, API, etc.)
public struct IndexInput: Codable {
    public let libraryId: String
    public let paths: [String]
    public let scope: IndexScope
    public let mode: IndexMode
    public let includeHidden: Bool
    public let persistence: IndexPersistence

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case paths = "paths"
        case scope = "scope"
        case mode = "mode"
        case includeHidden = "include_hidden"
        case persistence = "persistence"
    }
}

/// Indexing mode determines the depth of indexing
public enum IndexMode: Codable {
    case shallow
    case content
    case deep
}

/// Determines whether indexing results are persisted to database or kept in memory
public enum IndexPersistence: Codable {
    case persistent
    case ephemeral
}

/// Indexing scope determines how much of the directory tree to process
public enum IndexScope: Codable {
    case current
    case recursive
}

/// Comprehensive metrics for indexing operations
public struct IndexerMetrics: Codable {
    public let totalDuration: RustDuration
    public let discoveryDuration: RustDuration
    public let processingDuration: RustDuration
    public let contentDuration: RustDuration
    public let filesPerSecond: Float
    public let bytesPerSecond: Double
    public let dirsPerSecond: Float
    public let dbWrites: UInt64
    public let dbReads: UInt64
    public let batchCount: UInt64
    public let avgBatchSize: Float
    public let totalErrors: UInt64
    public let criticalErrors: UInt64
    public let nonCriticalErrors: UInt64
    public let skippedPaths: UInt64
    public let peakMemoryBytes: UInt64?
    public let avgMemoryBytes: UInt64?

    private enum CodingKeys: String, CodingKey {
        case totalDuration = "total_duration"
        case discoveryDuration = "discovery_duration"
        case processingDuration = "processing_duration"
        case contentDuration = "content_duration"
        case filesPerSecond = "files_per_second"
        case bytesPerSecond = "bytes_per_second"
        case dirsPerSecond = "dirs_per_second"
        case dbWrites = "db_writes"
        case dbReads = "db_reads"
        case batchCount = "batch_count"
        case avgBatchSize = "avg_batch_size"
        case totalErrors = "total_errors"
        case criticalErrors = "critical_errors"
        case nonCriticalErrors = "non_critical_errors"
        case skippedPaths = "skipped_paths"
        case peakMemoryBytes = "peak_memory_bytes"
        case avgMemoryBytes = "avg_memory_bytes"
    }
}

/// Indexer settings controlling rule toggles
public struct IndexerSettings: Codable {
    public let noSystemFiles: Bool?
    public let noGit: Bool?
    public let noDevDirs: Bool?
    public let noHidden: Bool?
    public let gitignore: Bool?
    public let onlyImages: Bool?

    private enum CodingKeys: String, CodingKey {
        case noSystemFiles = "no_system_files"
        case noGit = "no_git"
        case noDevDirs = "no_dev_dirs"
        case noHidden = "no_hidden"
        case gitignore = "gitignore"
        case onlyImages = "only_images"
    }
}

/// Statistics collected during indexing
public struct IndexerStats: Codable {
    public let files: UInt64
    public let dirs: UInt64
    public let bytes: UInt64
    public let symlinks: UInt64
    public let skipped: UInt64
    public let errors: UInt64
}

public struct JobCancelInput: Codable {
    public let jobId: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
    }
}

public struct JobCancelOutput: Codable {
    public let jobId: String
    public let success: Bool

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case success = "success"
    }
}

/// Unique identifier for a job
public struct JobId: Codable {
    let value: String
}

public struct JobInfoOutput: Codable {
    public let id: String
    public let name: String
    public let status: JobStatus
    public let progress: Float
    public let startedAt: String
    public let completedAt: String?
    public let errorMessage: String?

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case status = "status"
        case progress = "progress"
        case startedAt = "started_at"
        case completedAt = "completed_at"
        case errorMessage = "error_message"
    }
}

public struct JobInfoQueryInput: Codable {
    public let jobId: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
    }
}

public struct JobListInput: Codable {
    public let status: JobStatus?
}

public struct JobListItem: Codable {
    public let id: String
    public let name: String
    public let status: JobStatus
    public let progress: Float
}

public struct JobListOutput: Codable {
    public let jobs: [JobListItem]
}

/// Output from a completed job
public enum JobOutput {
    case success
    case fileCopy(JobOutputFileCopyData)
    case indexed(JobOutputIndexedData)
    case thumbnailsGenerated(JobOutputThumbnailsGeneratedData)
    case thumbnailGeneration(JobOutputThumbnailGenerationData)
    case fileMove(JobOutputFileMoveData)
    case fileDelete(JobOutputFileDeleteData)
    case duplicateDetection(JobOutputDuplicateDetectionData)
    case fileValidation(JobOutputFileValidationData)
}
public struct JobOutputFileCopyData: Codable {
    public let copiedCount: UInt
    public let totalBytes: UInt64

    private enum CodingKeys: String, CodingKey {
        case copiedCount = "copied_count"
        case totalBytes = "total_bytes"
    }
}

public struct JobOutputIndexedData: Codable {
    public let stats: IndexerStats
    public let metrics: IndexerMetrics
}

public struct JobOutputThumbnailsGeneratedData: Codable {
    public let generatedCount: UInt
    public let failedCount: UInt

    private enum CodingKeys: String, CodingKey {
        case generatedCount = "generated_count"
        case failedCount = "failed_count"
    }
}

public struct JobOutputThumbnailGenerationData: Codable {
    public let generatedCount: UInt64
    public let skippedCount: UInt64
    public let errorCount: UInt64
    public let totalSizeBytes: UInt64

    private enum CodingKeys: String, CodingKey {
        case generatedCount = "generated_count"
        case skippedCount = "skipped_count"
        case errorCount = "error_count"
        case totalSizeBytes = "total_size_bytes"
    }
}

public struct JobOutputFileMoveData: Codable {
    public let movedCount: UInt
    public let failedCount: UInt
    public let totalBytes: UInt64

    private enum CodingKeys: String, CodingKey {
        case movedCount = "moved_count"
        case failedCount = "failed_count"
        case totalBytes = "total_bytes"
    }
}

public struct JobOutputFileDeleteData: Codable {
    public let deletedCount: UInt
    public let failedCount: UInt
    public let totalBytes: UInt64

    private enum CodingKeys: String, CodingKey {
        case deletedCount = "deleted_count"
        case failedCount = "failed_count"
        case totalBytes = "total_bytes"
    }
}

public struct JobOutputDuplicateDetectionData: Codable {
    public let duplicateGroups: UInt
    public let totalDuplicates: UInt
    public let potentialSavings: UInt64

    private enum CodingKeys: String, CodingKey {
        case duplicateGroups = "duplicate_groups"
        case totalDuplicates = "total_duplicates"
        case potentialSavings = "potential_savings"
    }
}

public struct JobOutputFileValidationData: Codable {
    public let validatedCount: UInt
    public let issuesFound: UInt
    public let totalBytesValidated: UInt64

    private enum CodingKeys: String, CodingKey {
        case validatedCount = "validated_count"
        case issuesFound = "issues_found"
        case totalBytesValidated = "total_bytes_validated"
    }
}

// MARK: - JobOutput Adjacently Tagged Codable Implementation
extension JobOutput: Codable {
    private enum TypeKeys: String, CodingKey {
        case tag = "type"
        case content = "data"
    }

    private enum VariantType: String, Codable {
        case success = "Success"
        case fileCopy = "FileCopy"
        case indexed = "Indexed"
        case thumbnailsGenerated = "ThumbnailsGenerated"
        case thumbnailGeneration = "ThumbnailGeneration"
        case fileMove = "FileMove"
        case fileDelete = "FileDelete"
        case duplicateDetection = "DuplicateDetection"
        case fileValidation = "FileValidation"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: TypeKeys.self)
        let variantType = try container.decode(VariantType.self, forKey: .tag)
        
        switch variantType {
        case .success:
            self = .success
        case .fileCopy:
            let data = try container.decode(JobOutputFileCopyData.self, forKey: .content)
            self = .fileCopy(data)
        case .indexed:
            let data = try container.decode(JobOutputIndexedData.self, forKey: .content)
            self = .indexed(data)
        case .thumbnailsGenerated:
            let data = try container.decode(JobOutputThumbnailsGeneratedData.self, forKey: .content)
            self = .thumbnailsGenerated(data)
        case .thumbnailGeneration:
            let data = try container.decode(JobOutputThumbnailGenerationData.self, forKey: .content)
            self = .thumbnailGeneration(data)
        case .fileMove:
            let data = try container.decode(JobOutputFileMoveData.self, forKey: .content)
            self = .fileMove(data)
        case .fileDelete:
            let data = try container.decode(JobOutputFileDeleteData.self, forKey: .content)
            self = .fileDelete(data)
        case .duplicateDetection:
            let data = try container.decode(JobOutputDuplicateDetectionData.self, forKey: .content)
            self = .duplicateDetection(data)
        case .fileValidation:
            let data = try container.decode(JobOutputFileValidationData.self, forKey: .content)
            self = .fileValidation(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: TypeKeys.self)
        
        switch self {
        case .success:
            try container.encode(VariantType.success, forKey: .tag)
        case .fileCopy(let data):
            try container.encode(VariantType.fileCopy, forKey: .tag)
            try container.encode(data, forKey: .content)
        case .indexed(let data):
            try container.encode(VariantType.indexed, forKey: .tag)
            try container.encode(data, forKey: .content)
        case .thumbnailsGenerated(let data):
            try container.encode(VariantType.thumbnailsGenerated, forKey: .tag)
            try container.encode(data, forKey: .content)
        case .thumbnailGeneration(let data):
            try container.encode(VariantType.thumbnailGeneration, forKey: .tag)
            try container.encode(data, forKey: .content)
        case .fileMove(let data):
            try container.encode(VariantType.fileMove, forKey: .tag)
            try container.encode(data, forKey: .content)
        case .fileDelete(let data):
            try container.encode(VariantType.fileDelete, forKey: .tag)
            try container.encode(data, forKey: .content)
        case .duplicateDetection(let data):
            try container.encode(VariantType.duplicateDetection, forKey: .tag)
            try container.encode(data, forKey: .content)
        case .fileValidation(let data):
            try container.encode(VariantType.fileValidation, forKey: .tag)
            try container.encode(data, forKey: .content)
        }
    }
}


public struct JobPauseInput: Codable {
    public let jobId: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
    }
}

public struct JobPauseOutput: Codable {
    public let jobId: String
    public let success: Bool

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case success = "success"
    }
}

public struct JobReceipt: Codable {
    public let id: JobId
    public let jobName: String

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case jobName = "job_name"
    }
}

public struct JobResumeInput: Codable {
    public let jobId: String

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
    }
}

public struct JobResumeOutput: Codable {
    public let jobId: String
    public let success: Bool

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case success = "success"
    }
}

/// Current status of a job
public enum JobStatus: String, Codable {
    case queued = "queued"
    case running = "running"
    case paused = "paused"
    case completed = "completed"
    case failed = "failed"
    case cancelled = "cancelled"
}

public enum JsonValue: Codable {
    case null
    case bool(Bool)
    case number(JsonValue)
    case string(String)
    case array([JsonValue])
    case object([String: JsonValue])
}

/// Input for creating a new library
public struct LibraryCreateInput: Codable {
    public let name: String
    public let path: String?
}

/// Output from library create action dispatch
public struct LibraryCreateOutput: Codable {
    public let libraryId: String
    public let name: String
    public let path: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case name = "name"
        case path = "path"
    }
}

/// Input for deleting a library
public struct LibraryDeleteInput: Codable {
    public let libraryId: String
    public let deleteData: Bool

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case deleteData = "delete_data"
    }
}

/// Output from library delete action dispatch
public struct LibraryDeleteOutput: Codable {
    public let libraryId: String
    public let name: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case name = "name"
    }
}

/// Input for exporting a library
public struct LibraryExportInput: Codable {
    public let libraryId: String
    public let exportPath: String
    public let includeThumbnails: Bool
    public let includePreviews: Bool

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case exportPath = "export_path"
        case includeThumbnails = "include_thumbnails"
        case includePreviews = "include_previews"
    }
}

public struct LibraryExportOutput: Codable {
    public let libraryId: String
    public let libraryName: String
    public let exportPath: String
    public let exportedFiles: [String]

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case libraryName = "library_name"
        case exportPath = "export_path"
        case exportedFiles = "exported_files"
    }
}

/// Information about a library for listing purposes
public struct LibraryInfo: Codable {
    public let id: String
    public let name: String
    public let path: String
    public let stats: LibraryStatistics?
}

/// Detailed information about a library
public struct LibraryInfoOutput: Codable {
    public let id: String
    public let name: String
    public let description: String?
    public let path: String
    public let createdAt: String
    public let updatedAt: String
    public let settings: LibrarySettings
    public let statistics: LibraryStatistics

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case description = "description"
        case path = "path"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
        case settings = "settings"
        case statistics = "statistics"
    }
}

/// Input for library info query
public struct LibraryInfoQueryInput: Codable {
Void}

public struct LibraryRenameInput: Codable {
    public let libraryId: String
    public let newName: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case newName = "new_name"
    }
}

public struct LibraryRenameOutput: Codable {
    public let libraryId: String
    public let oldName: String
    public let newName: String

    private enum CodingKeys: String, CodingKey {
        case libraryId = "library_id"
        case oldName = "old_name"
        case newName = "new_name"
    }
}

/// Library-specific settings
public struct LibrarySettings: Codable {
    public let generateThumbnails: Bool
    public let thumbnailQuality: UInt8
    public let enableAiTagging: Bool
    public let syncEnabled: Bool
    public let encryptionEnabled: Bool
    public let thumbnailSizes: [UInt32]
    public let ignoredExtensions: [String]
    public let maxFileSize: UInt64?
    public let autoTrackSystemVolumes: Bool
    public let autoTrackExternalVolumes: Bool
    public let indexer: IndexerSettings?

    private enum CodingKeys: String, CodingKey {
        case generateThumbnails = "generate_thumbnails"
        case thumbnailQuality = "thumbnail_quality"
        case enableAiTagging = "enable_ai_tagging"
        case syncEnabled = "sync_enabled"
        case encryptionEnabled = "encryption_enabled"
        case thumbnailSizes = "thumbnail_sizes"
        case ignoredExtensions = "ignored_extensions"
        case maxFileSize = "max_file_size"
        case autoTrackSystemVolumes = "auto_track_system_volumes"
        case autoTrackExternalVolumes = "auto_track_external_volumes"
        case indexer = "indexer"
    }
}

/// Library statistics
public struct LibraryStatistics: Codable {
    public let totalFiles: UInt64
    public let totalSize: UInt64
    public let locationCount: UInt32
    public let tagCount: UInt32
    public let thumbnailCount: UInt64
    public let lastIndexed: String?
    public let updatedAt: String

    private enum CodingKeys: String, CodingKey {
        case totalFiles = "total_files"
        case totalSize = "total_size"
        case locationCount = "location_count"
        case tagCount = "tag_count"
        case thumbnailCount = "thumbnail_count"
        case lastIndexed = "last_indexed"
        case updatedAt = "updated_at"
    }
}

public struct ListDevicesInput: Codable {
    public let pairedOnly: Bool
    public let connectedOnly: Bool

    private enum CodingKeys: String, CodingKey {
        case pairedOnly = "paired_only"
        case connectedOnly = "connected_only"
    }
}

public struct ListLibrariesInput: Codable {
    public let includeStats: Bool

    private enum CodingKeys: String, CodingKey {
        case includeStats = "include_stats"
    }
}

public struct LocationAddInput: Codable {
    public let path: String
    public let name: String?
    public let mode: IndexMode
}

/// Output from location add action dispatch
public struct LocationAddOutput: Codable {
    public let locationId: String
    public let path: String
    public let name: String?
    public let jobId: String?

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
        case path = "path"
        case name = "name"
        case jobId = "job_id"
    }
}

public struct LocationInfo: Codable {
    public let id: String
    public let path: String
    public let name: String?
}

public struct LocationRemoveInput: Codable {
    public let locationId: String

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
    }
}

/// Output from location remove action dispatch
public struct LocationRemoveOutput: Codable {
    public let locationId: String
    public let path: String?

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
        case path = "path"
    }
}

public struct LocationRescanInput: Codable {
    public let locationId: String
    public let fullRescan: Bool

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
        case fullRescan = "full_rescan"
    }
}

public struct LocationRescanOutput: Codable {
    public let locationId: String
    public let locationPath: String
    public let jobId: String
    public let fullRescan: Bool

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
        case locationPath = "location_path"
        case jobId = "job_id"
        case fullRescan = "full_rescan"
    }
}

public struct LocationsListOutput: Codable {
    public let locations: [LocationInfo]
}

public struct LocationsListQueryInput: Codable {
Void}

/// Represents how the volume is mounted in the system
public enum MountType: Codable {
    case system
    case external
    case network
    case virtual
}

public struct NetworkStartInput: Codable {
}

public struct NetworkStartOutput: Codable {
    public let started: Bool
}

public struct NetworkStatus: Codable {
    public let running: Bool
    public let nodeId: String?
    public let addresses: [String]
    public let pairedDevices: UInt
    public let connectedDevices: UInt
    public let version: String

    private enum CodingKeys: String, CodingKey {
        case running = "running"
        case nodeId = "node_id"
        case addresses = "addresses"
        case pairedDevices = "paired_devices"
        case connectedDevices = "connected_devices"
        case version = "version"
    }
}

public struct NetworkStatusQueryInput: Codable {
Void}

public struct NetworkStopInput: Codable {
}

public struct NetworkStopOutput: Codable {
    public let stopped: Bool
}

/// Pagination information
public struct PaginationInfo: Codable {
    public let currentPage: UInt32
    public let totalPages: UInt32
    public let hasNext: Bool
    public let hasPrevious: Bool
    public let limit: UInt32
    public let offset: UInt32

    private enum CodingKeys: String, CodingKey {
        case currentPage = "current_page"
        case totalPages = "total_pages"
        case hasNext = "has_next"
        case hasPrevious = "has_previous"
        case limit = "limit"
        case offset = "offset"
    }
}

/// Pagination options
public struct PaginationOptions: Codable {
    public let limit: UInt32
    public let offset: UInt32
}

public struct PairCancelInput: Codable {
    public let sessionId: String

    private enum CodingKeys: String, CodingKey {
        case sessionId = "session_id"
    }
}

public struct PairCancelOutput: Codable {
    public let cancelled: Bool
}

public struct PairGenerateInput: Codable {
    public let autoAccept: Bool

    private enum CodingKeys: String, CodingKey {
        case autoAccept = "auto_accept"
    }
}

public struct PairGenerateOutput: Codable {
    public let code: String
    public let sessionId: String
    public let expiresAt: String

    private enum CodingKeys: String, CodingKey {
        case code = "code"
        case sessionId = "session_id"
        case expiresAt = "expires_at"
    }
}

public struct PairJoinInput: Codable {
    public let code: String
}

public struct PairJoinOutput: Codable {
    public let pairedDeviceId: String
    public let deviceName: String

    private enum CodingKeys: String, CodingKey {
        case pairedDeviceId = "paired_device_id"
        case deviceName = "device_name"
    }
}

public struct PairStatusOutput: Codable {
    public let sessions: [PairingSessionSummary]
}

public struct PairStatusQueryInput: Codable {
Void}

public struct PairedDeviceInfo: Codable {
    public let id: String
    public let name: String
    public let os: String
    public let isOnline: Bool
    public let lastSeen: String
    public let pairedAt: String

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case os = "os"
        case isOnline = "is_online"
        case lastSeen = "last_seen"
        case pairedAt = "paired_at"
    }
}

public struct PairingSessionSummary: Codable {
    public let id: String
    public let state: SerializablePairingState
    public let remoteDeviceId: String?
    public let expiresAt: String?

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case state = "state"
        case remoteDeviceId = "remote_device_id"
        case expiresAt = "expires_at"
    }
}

/// Path mapping for resolving virtual paths to actual storage locations
public struct PathMapping: Codable {
    public let virtualPath: String
    public let actualPath: String

    private enum CodingKeys: String, CodingKey {
        case virtualPath = "virtual_path"
        case actualPath = "actual_path"
    }
}

/// Performance and timing metrics
public struct PerformanceMetrics: Codable {
    public let rate: Float
    public let estimatedRemaining: RustDuration?
    public let elapsed: RustDuration?
    public let errorCount: UInt64
    public let warningCount: UInt64

    private enum CodingKeys: String, CodingKey {
        case rate = "rate"
        case estimatedRemaining = "estimated_remaining"
        case elapsed = "elapsed"
        case errorCount = "error_count"
        case warningCount = "warning_count"
    }
}

/// Privacy levels for tag visibility control
public enum PrivacyLevel: Codable {
    case normal
    case archive
    case hidden
}

/// Progress completion information
public struct ProgressCompletion: Codable {
    public let completed: UInt64
    public let total: UInt64
    public let bytesCompleted: UInt64?
    public let totalBytes: UInt64?

    private enum CodingKeys: String, CodingKey {
        case completed = "completed"
        case total = "total"
        case bytesCompleted = "bytes_completed"
        case totalBytes = "total_bytes"
    }
}

/// Detailed breakdown of how the score was calculated
public struct ScoreBreakdown: Codable {
    public let temporalScore: Float
    public let semanticScore: Float?
    public let metadataScore: Float
    public let recencyBoost: Float
    public let userPreferenceBoost: Float
    public let finalScore: Float

    private enum CodingKeys: String, CodingKey {
        case temporalScore = "temporal_score"
        case semanticScore = "semantic_score"
        case metadataScore = "metadata_score"
        case recencyBoost = "recency_boost"
        case userPreferenceBoost = "user_preference_boost"
        case finalScore = "final_score"
    }
}

/// A path within the Spacedrive Virtual Distributed File System
/// 
/// This is the core abstraction that enables cross-device operations.
/// An SdPath can represent:
/// - A physical file at a specific path on a specific device
/// - A content-addressed file that can be sourced from any device
/// 
/// This enum-based approach enables resilient file operations by allowing
/// content-based paths to be resolved to optimal physical locations at runtime.
public enum SdPath {
    case physical(SdPathPhysicalData)
    case content(SdPathContentData)
}
public struct SdPathPhysicalData: Codable {
    public let deviceId: String
    public let path: String

    private enum CodingKeys: String, CodingKey {
        case deviceId = "device_id"
        case path = "path"
    }
}

public struct SdPathContentData: Codable {
    public let contentId: String

    private enum CodingKeys: String, CodingKey {
        case contentId = "content_id"
    }
}

// MARK: - SdPath Codable Implementation
extension SdPath: Codable {
    private enum CodingKeys: String, CodingKey {
        case physical = "Physical"
        case content = "Content"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .physical:
            let data = try container.decode(SdPathPhysicalData.self, forKey: .physical)
            self = .physical(data)
        case .content:
            let data = try container.decode(SdPathContentData.self, forKey: .content)
            self = .content(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .physical(let data):
            try container.encode(data, forKey: .physical)
        case .content(let data):
            try container.encode(data, forKey: .content)
        }
    }
}


/// A batch of SdPaths, useful for operations on multiple files
public struct SdPathBatch: Codable {
    public let paths: [SdPath]
}

/// How SdPath is stored in the database
public struct SdPathSerialized: Codable {
    public let deviceId: String
    public let path: String

    private enum CodingKeys: String, CodingKey {
        case deviceId = "device_id"
        case path = "path"
    }
}

/// Search facets for filtering UI
public struct SearchFacets: Codable {
    public let fileTypes: [String: UInt64]
    public let tags: [String: UInt64]
    public let locations: [String: UInt64]
    public let dateRanges: [String: UInt64]
    public let sizeRanges: [String: UInt64]

    private enum CodingKeys: String, CodingKey {
        case fileTypes = "file_types"
        case tags = "tags"
        case locations = "locations"
        case dateRanges = "date_ranges"
        case sizeRanges = "size_ranges"
    }
}

/// Container for all structured filters
public struct SearchFilters: Codable {
    public let fileTypes: [String]?
    public let tags: TagFilter?
    public let dateRange: DateRangeFilter?
    public let sizeRange: SizeRangeFilter?
    public let locations: [String]?
    public let contentTypes: [ContentKind]?
    public let includeHidden: Bool?
    public let includeArchived: Bool?

    private enum CodingKeys: String, CodingKey {
        case fileTypes = "file_types"
        case tags = "tags"
        case dateRange = "date_range"
        case sizeRange = "size_range"
        case locations = "locations"
        case contentTypes = "content_types"
        case includeHidden = "include_hidden"
        case includeArchived = "include_archived"
    }
}

/// Defines the search mode and performance characteristics
public enum SearchMode: Codable {
    case fast
    case normal
    case full
}

/// Defines the scope of the filesystem to search within
public enum SearchScope {
    case library
    case location(SearchScopeLocationData)
    case path(SearchScopePathData)
}
public struct SearchScopeLocationData: Codable {
    public let locationId: String

    private enum CodingKeys: String, CodingKey {
        case locationId = "location_id"
    }
}

public struct SearchScopePathData: Codable {
    public let path: SdPath
}

// MARK: - SearchScope Codable Implementation
extension SearchScope: Codable {
    private enum CodingKeys: String, CodingKey {
        case library = "Library"
        case location = "Location"
        case path = "Path"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .library:
            self = .library
        case .location:
            let data = try container.decode(SearchScopeLocationData.self, forKey: .location)
            self = .location(data)
        case .path:
            let data = try container.decode(SearchScopePathData.self, forKey: .path)
            self = .path(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .library:
            try container.encodeNil(forKey: .library)
        case .location(let data):
            try container.encode(data, forKey: .location)
        case .path(let data):
            try container.encode(data, forKey: .path)
        }
    }
}


public struct SearchTagsInput: Codable {
    public let query: String
    public let namespace: String?
    public let tagType: TagType?
    public let includeArchived: Bool?
    public let limit: UInt?
    public let resolveAmbiguous: Bool?
    public let contextTagIds: [String]?

    private enum CodingKeys: String, CodingKey {
        case query = "query"
        case namespace = "namespace"
        case tagType = "tag_type"
        case includeArchived = "include_archived"
        case limit = "limit"
        case resolveAmbiguous = "resolve_ambiguous"
        case contextTagIds = "context_tag_ids"
    }
}

public struct SearchTagsOutput: Codable {
    public let tags: [TagSearchResult]
    public let totalFound: UInt
    public let disambiguated: Bool
    public let query: String
    public let filters: SearchFilters

    private enum CodingKeys: String, CodingKey {
        case tags = "tags"
        case totalFound = "total_found"
        case disambiguated = "disambiguated"
        case query = "query"
        case filters = "filters"
    }
}

public enum SerializablePairingState {
    case idle
    case generatingCode
    case broadcasting
    case scanning
    case waitingForConnection
    case connecting
    case authenticating
    case exchangingKeys
    case awaitingConfirmation
    case establishingSession
    case challengeReceived
    case responsePending
    case responseSent
    case completed
    case failed(SerializablePairingStateFailedData)
}
public struct SerializablePairingStateFailedData: Codable {
    public let reason: String
}

// MARK: - SerializablePairingState Codable Implementation
extension SerializablePairingState: Codable {
    private enum CodingKeys: String, CodingKey {
        case idle = "Idle"
        case generatingCode = "GeneratingCode"
        case broadcasting = "Broadcasting"
        case scanning = "Scanning"
        case waitingForConnection = "WaitingForConnection"
        case connecting = "Connecting"
        case authenticating = "Authenticating"
        case exchangingKeys = "ExchangingKeys"
        case awaitingConfirmation = "AwaitingConfirmation"
        case establishingSession = "EstablishingSession"
        case challengeReceived = "ChallengeReceived"
        case responsePending = "ResponsePending"
        case responseSent = "ResponseSent"
        case completed = "Completed"
        case failed = "Failed"
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        if container.allKeys.count != 1 {
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid number of keys found, expected one.")
            )
        }

        let key = container.allKeys.first!
        switch key {
        case .idle:
            self = .idle
        case .generatingCode:
            self = .generatingCode
        case .broadcasting:
            self = .broadcasting
        case .scanning:
            self = .scanning
        case .waitingForConnection:
            self = .waitingForConnection
        case .connecting:
            self = .connecting
        case .authenticating:
            self = .authenticating
        case .exchangingKeys:
            self = .exchangingKeys
        case .awaitingConfirmation:
            self = .awaitingConfirmation
        case .establishingSession:
            self = .establishingSession
        case .challengeReceived:
            self = .challengeReceived
        case .responsePending:
            self = .responsePending
        case .responseSent:
            self = .responseSent
        case .completed:
            self = .completed
        case .failed:
            let data = try container.decode(SerializablePairingStateFailedData.self, forKey: .failed)
            self = .failed(data)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        switch self {
        case .idle:
            try container.encodeNil(forKey: .idle)
        case .generatingCode:
            try container.encodeNil(forKey: .generatingCode)
        case .broadcasting:
            try container.encodeNil(forKey: .broadcasting)
        case .scanning:
            try container.encodeNil(forKey: .scanning)
        case .waitingForConnection:
            try container.encodeNil(forKey: .waitingForConnection)
        case .connecting:
            try container.encodeNil(forKey: .connecting)
        case .authenticating:
            try container.encodeNil(forKey: .authenticating)
        case .exchangingKeys:
            try container.encodeNil(forKey: .exchangingKeys)
        case .awaitingConfirmation:
            try container.encodeNil(forKey: .awaitingConfirmation)
        case .establishingSession:
            try container.encodeNil(forKey: .establishingSession)
        case .challengeReceived:
            try container.encodeNil(forKey: .challengeReceived)
        case .responsePending:
            try container.encodeNil(forKey: .responsePending)
        case .responseSent:
            try container.encodeNil(forKey: .responseSent)
        case .completed:
            try container.encodeNil(forKey: .completed)
        case .failed(let data):
            try container.encode(data, forKey: .failed)
        }
    }
}


public struct ServiceState: Codable {
    public let running: Bool
    public let details: String?
}

public struct ServiceStatus: Codable {
    public let locationWatcher: ServiceState
    public let networking: ServiceState
    public let volumeMonitor: ServiceState
    public let fileSharing: ServiceState

    private enum CodingKeys: String, CodingKey {
        case locationWatcher = "location_watcher"
        case networking = "networking"
        case volumeMonitor = "volume_monitor"
        case fileSharing = "file_sharing"
    }
}

/// Filter for file size in bytes
public struct SizeRangeFilter: Codable {
    public let min: UInt64?
    public let max: UInt64?
}

/// Sort direction
public enum SortDirection: Codable {
    case asc
    case desc
}

/// Fields that can be used for sorting
public enum SortField: Codable {
    case relevance
    case name
    case size
    case modifiedAt
    case createdAt
}

/// Sorting options for search results
public struct SortOptions: Codable {
    public let field: SortField
    public let direction: SortDirection
}

public struct SpacedropSendInput: Codable {
    public let deviceId: String
    public let paths: [SdPath]
    public let sender: String?

    private enum CodingKeys: String, CodingKey {
        case deviceId = "device_id"
        case paths = "paths"
        case sender = "sender"
    }
}

public struct SpacedropSendOutput: Codable {
    public let jobId: String?
    public let sessionId: String?

    private enum CodingKeys: String, CodingKey {
        case jobId = "job_id"
        case sessionId = "session_id"
    }
}

public struct SystemInfo: Codable {
    public let uptime: UInt64?
    public let dataDirectory: String
    public let instanceName: String?
    public let currentLibrary: String?

    private enum CodingKeys: String, CodingKey {
        case uptime = "uptime"
        case dataDirectory = "data_directory"
        case instanceName = "instance_name"
        case currentLibrary = "current_library"
    }
}

/// A tag with advanced capabilities for contextual organization
public struct Tag: Codable {
    public let id: String
    public let canonicalName: String
    public let displayName: String?
    public let formalName: String?
    public let abbreviation: String?
    public let aliases: [String]
    public let namespace: String?
    public let tagType: TagType
    public let color: String?
    public let icon: String?
    public let description: String?
    public let isOrganizationalAnchor: Bool
    public let privacyLevel: PrivacyLevel
    public let searchWeight: Int32
    public let attributes: [String: JsonValue]
    public let compositionRules: [CompositionRule]
    public let createdAt: String
    public let updatedAt: String
    public let createdByDevice: String

    private enum CodingKeys: String, CodingKey {
        case id = "id"
        case canonicalName = "canonical_name"
        case displayName = "display_name"
        case formalName = "formal_name"
        case abbreviation = "abbreviation"
        case aliases = "aliases"
        case namespace = "namespace"
        case tagType = "tag_type"
        case color = "color"
        case icon = "icon"
        case description = "description"
        case isOrganizationalAnchor = "is_organizational_anchor"
        case privacyLevel = "privacy_level"
        case searchWeight = "search_weight"
        case attributes = "attributes"
        case compositionRules = "composition_rules"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
        case createdByDevice = "created_by_device"
    }
}

/// Filter for tags, supporting complex boolean logic
public struct TagFilter: Codable {
    public let include: [String]
    public let exclude: [String]
}

public struct TagSearchResult: Codable {
    public let tag: Tag
    public let relevance: Float
    public let matchedVariant: String?
    public let contextScore: Float?

    private enum CodingKeys: String, CodingKey {
        case tag = "tag"
        case relevance = "relevance"
        case matchedVariant = "matched_variant"
        case contextScore = "context_score"
    }
}

/// Source of tag application
public enum TagSource: Codable {
    case user
    case aI
    case import
    case sync
}

/// Types of semantic tags with different behaviors
public enum TagType: Codable {
    case standard
    case organizational
    case privacy
    case system
}

/// Text highlighting information
public struct TextHighlight: Codable {
    public let field: String
    public let text: String
    public let start: UInt
    public let end: UInt
}

public struct ThumbnailInput: Codable {
    public let paths: [String]
    public let size: UInt32
    public let quality: UInt8
}

/// Represents a physical or virtual storage volume in the system
public struct Volume: Codable {
    public let fingerprint: VolumeFingerprint
    public let deviceId: String
    public let name: String
    public let mountType: MountType
    public let volumeType: VolumeType
    public let mountPoint: String
    public let mountPoints: [String]
    public let isMounted: Bool
    public let diskType: DiskType
    public let fileSystem: FileSystem
    public let readOnly: Bool
    public let hardwareId: String?
    public let errorStatus: String?
    public let apfsContainer: ApfsContainer?
    public let containerVolumeId: String?
    public let pathMappings: [PathMapping]
    public let totalBytesCapacity: UInt64
    public let totalBytesAvailable: UInt64
    public let readSpeedMbps: UInt64?
    public let writeSpeedMbps: UInt64?
    public let isUserVisible: Bool
    public let autoTrackEligible: Bool
    public let lastUpdated: String

    private enum CodingKeys: String, CodingKey {
        case fingerprint = "fingerprint"
        case deviceId = "device_id"
        case name = "name"
        case mountType = "mount_type"
        case volumeType = "volume_type"
        case mountPoint = "mount_point"
        case mountPoints = "mount_points"
        case isMounted = "is_mounted"
        case diskType = "disk_type"
        case fileSystem = "file_system"
        case readOnly = "read_only"
        case hardwareId = "hardware_id"
        case errorStatus = "error_status"
        case apfsContainer = "apfs_container"
        case containerVolumeId = "container_volume_id"
        case pathMappings = "path_mappings"
        case totalBytesCapacity = "total_bytes_capacity"
        case totalBytesAvailable = "total_bytes_available"
        case readSpeedMbps = "read_speed_mbps"
        case writeSpeedMbps = "write_speed_mbps"
        case isUserVisible = "is_user_visible"
        case autoTrackEligible = "auto_track_eligible"
        case lastUpdated = "last_updated"
    }
}

/// Unique fingerprint for a storage volume
public struct VolumeFingerprint: Codable {
    let value: String
}

/// Summary information about a volume (for updates and caching)
public struct VolumeInfo: Codable {
    public let isMounted: Bool
    public let totalBytesAvailable: UInt64
    public let readSpeedMbps: UInt64?
    public let writeSpeedMbps: UInt64?
    public let errorStatus: String?

    private enum CodingKeys: String, CodingKey {
        case isMounted = "is_mounted"
        case totalBytesAvailable = "total_bytes_available"
        case readSpeedMbps = "read_speed_mbps"
        case writeSpeedMbps = "write_speed_mbps"
        case errorStatus = "error_status"
    }
}

public struct VolumeSpeedTestInput: Codable {
    public let fingerprint: VolumeFingerprint
}

/// Output from volume speed test operation
public struct VolumeSpeedTestOutput: Codable {
    public let fingerprint: VolumeFingerprint
    public let readSpeedMbps: UInt32?
    public let writeSpeedMbps: UInt32?

    private enum CodingKeys: String, CodingKey {
        case fingerprint = "fingerprint"
        case readSpeedMbps = "read_speed_mbps"
        case writeSpeedMbps = "write_speed_mbps"
    }
}

public struct VolumeTrackInput: Codable {
    public let fingerprint: VolumeFingerprint
    public let name: String?
}

/// Output from volume track operation
public struct VolumeTrackOutput: Codable {
    public let fingerprint: VolumeFingerprint
    public let volumeName: String

    private enum CodingKeys: String, CodingKey {
        case fingerprint = "fingerprint"
        case volumeName = "volume_name"
    }
}

/// Classification of volume types for UX and auto-tracking decisions
public enum VolumeType: Codable {
    case primary
    case userData
    case external
    case secondary
    case system
    case network
    case unknown
}

public struct VolumeUntrackInput: Codable {
    public let fingerprint: VolumeFingerprint
}

/// Output from volume untrack operation
public struct VolumeUntrackOutput: Codable {
    public let fingerprint: VolumeFingerprint
}


/// Complete Spacedrive API structure
public enum SpacedriveApi {
    case CoreAction(CoreAction)
    case LibraryAction(LibraryAction)
    case CoreQuery(CoreQuery)
    case LibraryQuery(LibraryQuery)
}

extension SpacedriveApi: Codable {
    public var wireMethod: String {
        switch self {
        case .CoreAction: return "core_action"
        case .LibraryAction: return "library_action"
        case .CoreQuery: return "core_query"
        case .LibraryQuery: return "library_query"
        }
    }
}

/// Core-scoped actions
public enum CoreAction {
    case NetworkDeviceRevoke(input: NetworkDeviceRevokeInput, output: NetworkDeviceRevokeOutput)
    case LibrariesDelete(input: LibrariesDeleteInput, output: LibrariesDeleteOutput)
    case NetworkPairJoin(input: NetworkPairJoinInput, output: NetworkPairJoinOutput)
    case NetworkStart(input: NetworkStartInput, output: NetworkStartOutput)
    case NetworkPairGenerate(input: NetworkPairGenerateInput, output: NetworkPairGenerateOutput)
    case NetworkPairCancel(input: NetworkPairCancelInput, output: NetworkPairCancelOutput)
    case NetworkSpacedropSend(input: NetworkSpacedropSendInput, output: NetworkSpacedropSendOutput)
    case NetworkStop(input: NetworkStopInput, output: NetworkStopOutput)
    case LibrariesCreate(input: LibrariesCreateInput, output: LibrariesCreateOutput)
}

extension CoreAction: Codable {
    public var wireMethod: String {
        switch self {
        case .NetworkDeviceRevoke: return "action:network.device.revoke.input.v1"
        case .LibrariesDelete: return "action:libraries.delete.input.v1"
        case .NetworkPairJoin: return "action:network.pair.join.input.v1"
        case .NetworkStart: return "action:network.start.input.v1"
        case .NetworkPairGenerate: return "action:network.pair.generate.input.v1"
        case .NetworkPairCancel: return "action:network.pair.cancel.input.v1"
        case .NetworkSpacedropSend: return "action:network.spacedrop.send.input.v1"
        case .NetworkStop: return "action:network.stop.input.v1"
        case .LibrariesCreate: return "action:libraries.create.input.v1"
        }
    }
}

/// Library-scoped actions
public enum LibraryAction {
    case JobsPause(input: JobsPauseInput, output: JobsPauseOutput)
    case FilesCopy(input: FilesCopyInput, output: FilesCopyOutput)
    case LocationsAdd(input: LocationsAddInput, output: LocationsAddOutput)
    case IndexingStart(input: IndexingStartInput, output: IndexingStartOutput)
    case FilesValidation(input: FilesValidationInput, output: FilesValidationOutput)
    case LibrariesRename(input: LibrariesRenameInput, output: LibrariesRenameOutput)
    case VolumesUntrack(input: VolumesUntrackInput, output: VolumesUntrackOutput)
    case VolumesTrack(input: VolumesTrackInput, output: VolumesTrackOutput)
    case FilesDelete(input: FilesDeleteInput, output: FilesDeleteOutput)
    case LocationsRemove(input: LocationsRemoveInput, output: LocationsRemoveOutput)
    case JobsCancel(input: JobsCancelInput, output: JobsCancelOutput)
    case VolumesSpeed_test(input: VolumesSpeed_testInput, output: VolumesSpeed_testOutput)
    case MediaThumbnail(input: MediaThumbnailInput, output: MediaThumbnailOutput)
    case LibrariesExport(input: LibrariesExportInput, output: LibrariesExportOutput)
    case LocationsRescan(input: LocationsRescanInput, output: LocationsRescanOutput)
    case TagsApply(input: TagsApplyInput, output: TagsApplyOutput)
    case TagsCreate(input: TagsCreateInput, output: TagsCreateOutput)
    case FilesDuplicate_detection(input: FilesDuplicate_detectionInput, output: FilesDuplicate_detectionOutput)
    case JobsResume(input: JobsResumeInput, output: JobsResumeOutput)
}

extension LibraryAction: Codable {
    public var wireMethod: String {
        switch self {
        case .JobsPause: return "action:jobs.pause.input.v1"
        case .FilesCopy: return "action:files.copy.input.v1"
        case .LocationsAdd: return "action:locations.add.input.v1"
        case .IndexingStart: return "action:indexing.start.input.v1"
        case .FilesValidation: return "action:files.validation.input.v1"
        case .LibrariesRename: return "action:libraries.rename.input.v1"
        case .VolumesUntrack: return "action:volumes.untrack.input.v1"
        case .VolumesTrack: return "action:volumes.track.input.v1"
        case .FilesDelete: return "action:files.delete.input.v1"
        case .LocationsRemove: return "action:locations.remove.input.v1"
        case .JobsCancel: return "action:jobs.cancel.input.v1"
        case .VolumesSpeed_test: return "action:volumes.speed_test.input.v1"
        case .MediaThumbnail: return "action:media.thumbnail.input.v1"
        case .LibrariesExport: return "action:libraries.export.input.v1"
        case .LocationsRescan: return "action:locations.rescan.input.v1"
        case .TagsApply: return "action:tags.apply.input.v1"
        case .TagsCreate: return "action:tags.create.input.v1"
        case .FilesDuplicate_detection: return "action:files.duplicate_detection.input.v1"
        case .JobsResume: return "action:jobs.resume.input.v1"
        }
    }
}

/// Core-scoped queries
public enum CoreQuery {
    case NetworkDevices(input: NetworkDevicesQueryInput, output: NetworkDevicesOutput)
    case NetworkStatus(input: NetworkStatusQueryInput, output: NetworkStatusOutput)
    case NetworkPairStatus(input: NetworkPairStatusQueryInput, output: NetworkPairStatusOutput)
    case CoreStatus(input: CoreStatusQueryInput, output: CoreStatusOutput)
    case LibrariesList(input: LibrariesListQueryInput, output: LibrariesListOutput)
}

extension CoreQuery: Codable {
    public var wireMethod: String {
        switch self {
        case .NetworkDevices: return "query:network.devices.v1"
        case .NetworkStatus: return "query:network.status.v1"
        case .NetworkPairStatus: return "query:network.pair.status.v1"
        case .CoreStatus: return "query:core.status.v1"
        case .LibrariesList: return "query:libraries.list.v1"
        }
    }
}

/// Library-scoped queries
public enum LibraryQuery {
    case LibrariesInfo(input: LibrariesInfoQueryInput, output: LibrariesInfoOutput)
    case JobsInfo(input: JobsInfoQueryInput, output: JobsInfoOutput)
    case SearchFiles(input: SearchFilesQueryInput, output: SearchFilesOutput)
    case JobsList(input: JobsListQueryInput, output: JobsListOutput)
    case TagsSearch(input: TagsSearchQueryInput, output: TagsSearchOutput)
    case LocationsList(input: LocationsListQueryInput, output: LocationsListOutput)
}

extension LibraryQuery: Codable {
    public var wireMethod: String {
        switch self {
        case .LibrariesInfo: return "query:libraries.info.v1"
        case .JobsInfo: return "query:jobs.info.v1"
        case .SearchFiles: return "query:search.files.v1"
        case .JobsList: return "query:jobs.list.v1"
        case .TagsSearch: return "query:tags.search.v1"
        case .LocationsList: return "query:locations.list.v1"
        }
    }
}
