# Entity Refactor Design: Library-Scoped ContentIdentity & Hierarchical Metadata

## Overview

This document outlines refactoring the Spacedrive entity system to support global ContentIdentity management and dual-level tagging (file-specific vs content-universal). The design builds on the existing hybrid ID system and content-addressed storage while adding cross-library content discovery and flexible tagging options.

## Current State Analysis

### Strengths of Current Architecture

- **Hybrid ID System**: Already uses both `i32` (performance) and `Uuid` (sync) IDs
- **Content Addressing**: CAS system with `content_hash` provides reliable content fingerprinting
- **Device Awareness**: Solid foundation with device management and network discovery
- **Flexible Metadata**: UserMetadata system supports rich tagging already
- **Sync Foundation**: UUIDs throughout enable cross-device synchronization

### Current Limitations

- **Library-Bound Content**: ContentIdentity not shared across libraries
- **Manual Metadata**: UserMetadata only created when user explicitly adds tags
- **No Global Content APIs**: No way to query "all instances of this content"

## Refactor Goals

1. **Global ContentIdentity**: Make ContentIdentity truly global and discoverable across libraries
2. **Hierarchical Metadata System**: Support both Entry-scoped and ContentIdentity-scoped metadata with hierarchy display
3. **Flexible Metadata Scoping**: UserMetadata can target either Entry or ContentIdentity with hierarchy resolution
4. **Cross-Library Operations**: Enable content discovery and operations across library boundaries
5. **Sync Integration**: Connect tagging operations to the sync system

## Design Changes

### 1. Global ContentIdentity Management

#### Current ContentIdentity

```rust
ContentIdentity {
    id: i32,                    // Auto-increment per library
    uuid: Uuid,                 // Random per library instance
    content_hash: String,       // Content hash
    kind_id: i32,               // Content type
    entry_count: i32,           // References in this library
    total_size: i64,            // Size in this library
    // ...
}
```

#### Proposed: ContentIdentity with UUID-Optional Sync Readiness (Library-Scoped)

```rust
// Enhanced: Library-scoped content identity with sync-ready UUID assignment
ContentIdentity {
    id: i32,                    // Auto-increment per library (local optimization)
    uuid: Option<Uuid>,         // DETERMINISTIC from content_hash (assigned during content identification phase)
    integrity_hash: Option<String>, // Full hash for file validation (generated by validate job)
    content_hash: String,       // Fast sampled hash for deduplication (generated during content identification)
    mime_type_id: Option<i32>,  // MIME type foreign key (unchanged)
    kind_id: i32,               // ContentKind foreign key (unchanged)
    media_data: Option<Json>,   // MediaData as JSON (unchanged)
    total_size: i64,            // Size of one instance of this content (renamed from old field)
    entry_count: i32,           // Entries in THIS library only (unchanged)
    first_seen_at: DateTime<Utc>,    // When first discovered (unchanged)
    last_verified_at: DateTime<Utc>, // When last verified (unchanged)
}

impl ContentIdentity {
    /// Generate deterministic UUID from content_hash for sync consistency within library
    /// Note: ContentIdentity UUIDs are deterministic from content_hash + library_id
    /// This ensures same content in different libraries has different UUIDs
    /// Maintains library isolation while enabling deterministic sync
    pub fn deterministic_uuid(content_hash: &str, library_id: Uuid) -> Uuid {
        let namespace = Uuid::new_v5(&LIBRARY_NAMESPACE, library_id.as_bytes());
        Uuid::new_v5(&namespace, content_hash.as_bytes())
    }

    /// Calculate combined size on-demand (no need to cache entry_count * total_size)
    pub fn combined_size(&self) -> i64 {
        self.entry_count as i64 * self.total_size
    }

    /// Find or create content identity during content identification phase
    pub async fn find_or_create(
        content_hash: String,
        kind_id: i32,
        total_size: i64,
        mime_type_id: Option<i32>,
        library_id: Uuid,
        library_db: &DatabaseConnection,
    ) -> Result<Self> {
        // Check if content identity already exists by content_hash
        if let Some(existing) = Self::find_by_content_hash(&content_hash, library_db).await? {
            // Update entry count for existing content
            existing.increment_entry_count().await?;
            Ok(existing)
        } else {
            // Create new content identity with deterministic UUID (ready for sync)
            let deterministic_uuid = Self::deterministic_uuid(&content_hash, library_id);
            
            let new_identity = ContentIdentityActiveModel {
                uuid: Set(Some(deterministic_uuid)),
                integrity_hash: Set(None), // Generated later by validate job
                content_hash: Set(content_hash),
                mime_type_id: Set(mime_type_id),
                kind_id: Set(kind_id),
                media_data: Set(None), // Set during media analysis
                total_size: Set(total_size),
                entry_count: Set(1),
                first_seen_at: Set(Utc::now()),
                last_verified_at: Set(Utc::now()),
            };
            Ok(new_identity.insert(library_db).await?)
        }
    }
}
```

### 2. Unified UserMetadata with Hierarchical Scoping

#### Current Tagging

```rust
// Current: Tags linked through UserMetadata
UserMetadata {
    id: i32,
    uuid: Uuid,                 // Matches Entry.metadata_id (optional)
    notes: Option<String>,
    favorite: bool,
    hidden: bool,
    custom_data: Option<Value>,
}

// Current: Only Entry-level tags via junction table
metadata_tags: (metadata_id, tag_id)
```

#### Proposed: Scoped UserMetadata with Hierarchy Display

```rust
// UserMetadata can target either Entry OR ContentIdentity (mutual exclusivity)
UserMetadata {
    id: i32,
    uuid: Uuid,
    
    // Exactly one of these is set - defines the scope
    entry_uuid: Option<Uuid>,           // File-specific metadata (higher priority in hierarchy)
    content_identity_uuid: Option<Uuid>, // Content-universal metadata (lower priority in hierarchy)
    
    // All metadata types benefit from scope flexibility
    notes: Option<String>,
    favorite: bool,
    hidden: bool,
    custom_data: Option<Value>,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
}

// Tags remain linked through UserMetadata (existing junction table)
user_metadata_tags {
    user_metadata_id: i32,      // Reference to UserMetadata
    tag_uuid: Uuid,             // Reference to Tag
    created_at: DateTime<Utc>,
    device_uuid: Uuid,          // Which device applied this tag
    PRIMARY KEY (user_metadata_id, tag_uuid)
}
```

#### Hierarchy Display Logic

```rust
pub struct MetadataDisplay {
    pub notes: Vec<MetadataNote>,        // Both entry and content notes shown
    pub tags: Vec<MetadataTag>,          // Both entry and content tags shown
    pub favorite: bool,                  // Entry-level overrides content-level
    pub hidden: bool,                    // Entry-level overrides content-level
    pub custom_data: Option<Value>,      // Entry-level overrides content-level
}

pub struct MetadataNote {
    pub content: String,
    pub scope: MetadataScope,
    pub created_at: DateTime<Utc>,
}

pub struct MetadataTag {
    pub tag: Tag,
    pub scope: MetadataScope,
    pub created_at: DateTime<Utc>,
}

pub enum MetadataScope {
    Entry,          // File-specific (higher priority)
    Content,        // Content-universal (lower priority)
}
```

### 3. Enhanced Entry Processing

#### Current Entry Creation

```rust
// Current: Metadata created on-demand
Entry {
    metadata_id: Option<Uuid>,  // Only set when user adds tags
    content_id: Option<i32>,    // Only set during content indexing
    // ...
}
```

#### Proposed: Phased Entry Processing

```rust
// Entry processing happens in phases - ContentIdentity created later
Entry {
    id: i32,                    // Auto-increment for local queries (unchanged)
    uuid: Option<Uuid>,         // None until content identification phase complete (sync readiness indicator)
    metadata_id: Option<Uuid>,  // Created when user adds metadata
    content_id: Option<i32>,    // None initially, set during content identification phase
    // ... other fields unchanged
}

impl Entry {
    /// Create entry during processing phase (no ContentIdentity yet)
    pub async fn create(
        location_id: i32,
        path: &SdPath,
        file_info: &FileInfo,
        library_db: &DatabaseConnection,
    ) -> Result<Self> {
        let entry = EntryActiveModel {
            uuid: Set(None),        // No UUID until content identification phase
            metadata_id: Set(None), // No metadata initially
            content_id: Set(None),  // ContentIdentity created later in content identification phase
            location_id: Set(location_id),
            relative_path: Set(path.relative_path()),
            name: Set(path.name()),
            // ... other fields from file_info
        }.insert(library_db).await?;

        Ok(entry)
    }

    /// Create UserMetadata when user adds tags/metadata
    pub async fn ensure_metadata(&mut self, library_db: &DatabaseConnection) -> Result<UserMetadata> {
        if let Some(metadata_id) = self.metadata_id {
            // Metadata already exists
            UserMetadata::find_by_uuid(metadata_id, library_db).await?
                .ok_or(Error::MetadataNotFound)
        } else {
            // Create new metadata
            let metadata_uuid = Uuid::new_v4();
            let user_metadata = UserMetadataActiveModel {
                uuid: Set(metadata_uuid),
                entry_uuid: Set(self.uuid),     // Entry-scoped UserMetadata
                content_identity_uuid: Set(None), // Mutually exclusive with entry_uuid
                created_at: Set(Utc::now()),
                updated_at: Set(Utc::now()),
                // ... other fields with defaults
            }.insert(library_db).await?;

            // Update entry to reference new metadata
            self.metadata_id = Some(metadata_uuid);
            self.update(library_db).await?;

            Ok(user_metadata)
        }
    }

    /// Link to content identity during content identification phase and assign UUID for sync readiness
    pub async fn link_to_content_identity(
        &mut self,
        content_hash: String,
        kind_id: i32,
        total_size: i64,
        mime_type_id: Option<i32>,
        library_id: Uuid,
        library_db: &DatabaseConnection,
    ) -> Result<ContentIdentity> {
        // Find or create content identity during content identification phase
        let content_identity = ContentIdentity::find_or_create(
            content_hash, kind_id, total_size, mime_type_id, library_id, library_db
        ).await?;

        // Update Entry with content_id AND assign UUID (now ready for sync)
        self.content_id = Some(content_identity.id);
        self.uuid = Some(Uuid::new_v4()); // Entry now ready for sync
        self.update(library_db).await?;

        // Note: UserMetadata targeting remains entry-scoped (entry_uuid)
        // Content-scoped UserMetadata created separately via "Apply to all instances" promotion
        // integrity_hash will be generated later by separate validate job

        Ok(content_identity)
    }
    
    /// UUID Assignment Rules:
    /// - Directories: Assign UUID immediately (no content to identify)
    /// - Empty files: Assign UUID immediately (size = 0, no content to hash)
    /// - Regular files: Assign UUID after content identification completes
    pub async fn should_assign_uuid_immediately(&self) -> bool {
        self.kind == EntryKind::Directory || self.size == 0
    }
}
```

### 4. Hierarchical Metadata Operations

```rust
pub enum MetadataTarget {
    /// Metadata for this specific file instance (syncs with Index domain)
    Entry(Uuid),
    /// Metadata for all instances of this content within library (syncs with UserMetadata domain)
    Content(Uuid),
}

pub struct MetadataService {
    library_db: Arc<DatabaseConnection>,
    current_device_uuid: Uuid,
}

impl MetadataService {
    /// Add metadata (notes, tags, favorites) with flexible targeting
    pub async fn add_metadata(
        &self,
        target: MetadataTarget,
        metadata_update: MetadataUpdate,
    ) -> Result<UserMetadata> {
        match target {
            MetadataTarget::Entry(entry_uuid) => {
                // File-specific metadata - create entry-scoped UserMetadata
                let user_metadata = UserMetadataActiveModel {
                    uuid: Set(Uuid::new_v4()),
                    entry_uuid: Set(Some(entry_uuid)),
                    content_identity_uuid: Set(None), // Mutually exclusive
                    notes: Set(metadata_update.notes),
                    favorite: Set(metadata_update.favorite.unwrap_or(false)),
                    hidden: Set(metadata_update.hidden.unwrap_or(false)),
                    custom_data: Set(metadata_update.custom_data),
                    created_at: Set(Utc::now()),
                    updated_at: Set(Utc::now()),
                }.insert(&self.library_db).await?;

                // Add tags if provided
                if let Some(tag_uuids) = metadata_update.tag_uuids {
                    self.add_tags_to_metadata(user_metadata.id, tag_uuids).await?;
                }

                Ok(user_metadata)
            }

            MetadataTarget::Content(content_identity_uuid) => {
                // Content-universal metadata - create content-scoped UserMetadata
                let user_metadata = UserMetadataActiveModel {
                    uuid: Set(Uuid::new_v4()),
                    entry_uuid: Set(None), // Mutually exclusive
                    content_identity_uuid: Set(Some(content_identity_uuid)),
                    notes: Set(metadata_update.notes),
                    favorite: Set(metadata_update.favorite.unwrap_or(false)),
                    hidden: Set(metadata_update.hidden.unwrap_or(false)),
                    custom_data: Set(metadata_update.custom_data),
                    created_at: Set(Utc::now()),
                    updated_at: Set(Utc::now()),
                }.insert(&self.library_db).await?;

                // Add tags if provided
                if let Some(tag_uuids) = metadata_update.tag_uuids {
                    self.add_tags_to_metadata(user_metadata.id, tag_uuids).await?;
                }

                Ok(user_metadata)
            }
        }
    }

    /// Get hierarchical metadata display for an entry (both entry and content metadata shown)
    pub async fn get_entry_metadata_display(&self, entry_uuid: Uuid) -> Result<MetadataDisplay> {
        let mut display = MetadataDisplay {
            notes: Vec::new(),
            tags: Vec::new(),
            favorite: false,
            hidden: false,
            custom_data: None,
        };

        // Get entry-specific metadata
        let entry_metadata = UserMetadata::find()
            .filter(user_metadata::Column::EntryUuid.eq(entry_uuid))
            .find_with_related(Tag)
            .all(&self.library_db)
            .await?;

        for (metadata, tags) in entry_metadata {
            // Notes - show both levels
            if let Some(notes) = metadata.notes {
                display.notes.push(MetadataNote {
                    content: notes,
                    scope: MetadataScope::Entry,
                    created_at: metadata.created_at,
                });
            }

            // Tags - show both levels
            for tag in tags {
                display.tags.push(MetadataTag {
                    tag,
                    scope: MetadataScope::Entry,
                    created_at: metadata.created_at,
                });
            }

            // Favorites/Hidden - entry overrides (higher priority)
            display.favorite = metadata.favorite;
            display.hidden = metadata.hidden;
            display.custom_data = metadata.custom_data;
        }

        // Get content-level metadata if entry has content identity
        if let Some(entry) = Entry::find_by_uuid(entry_uuid, &self.library_db).await? {
            if let Some(content_id) = entry.content_id {
                if let Some(content_identity) = ContentIdentity::find_by_id(content_id, &self.library_db).await? {
                    if let Some(content_uuid) = content_identity.uuid {
                        let content_metadata = UserMetadata::find()
                            .filter(user_metadata::Column::ContentIdentityUuid.eq(content_uuid))
                            .find_with_related(Tag)
                            .all(&self.library_db)
                            .await?;

                        for (metadata, tags) in content_metadata {
                            // Notes - show both levels
                            if let Some(notes) = metadata.notes {
                                display.notes.push(MetadataNote {
                                    content: notes,
                                    scope: MetadataScope::Content,
                                    created_at: metadata.created_at,
                                });
                            }

                            // Tags - show both levels
                            for tag in tags {
                                display.tags.push(MetadataTag {
                                    tag,
                                    scope: MetadataScope::Content,
                                    created_at: metadata.created_at,
                                });
                            }

                            // Favorites/Hidden - only use if no entry-level override
                            if display.favorite == false && metadata.favorite {
                                display.favorite = true;
                            }
                            if display.hidden == false && metadata.hidden {
                                display.hidden = true;
                            }
                            if display.custom_data.is_none() {
                                display.custom_data = metadata.custom_data;
                            }
                        }
                    }
                }
            }
        }

        Ok(display)
    }

    /// Promote entry-level metadata to content-level ("Apply to all instances")
    pub async fn promote_to_content(
        &self,
        entry_metadata_id: i32,
        content_identity_uuid: Uuid,
    ) -> Result<UserMetadata> {
        // Get existing entry-level metadata
        let entry_metadata = UserMetadata::find_by_id(entry_metadata_id)
            .one(&self.library_db)
            .await?
            .ok_or(Error::MetadataNotFound)?;

        // Create new content-level metadata (entry-level remains for hierarchy)
        let content_metadata = UserMetadataActiveModel {
            uuid: Set(Uuid::new_v4()),
            entry_uuid: Set(None),
            content_identity_uuid: Set(Some(content_identity_uuid)),
            notes: Set(entry_metadata.notes.clone()),
            favorite: Set(entry_metadata.favorite),
            hidden: Set(entry_metadata.hidden),
            custom_data: Set(entry_metadata.custom_data.clone()),
            created_at: Set(Utc::now()),
            updated_at: Set(Utc::now()),
        }.insert(&self.library_db).await?;

        // Copy tags to new content-level metadata
        let entry_tags = UserMetadataTag::find()
            .filter(user_metadata_tag::Column::UserMetadataId.eq(entry_metadata_id))
            .all(&self.library_db)
            .await?;

        for entry_tag in entry_tags {
            UserMetadataTagActiveModel {
                user_metadata_id: Set(content_metadata.id),
                tag_uuid: Set(entry_tag.tag_uuid),
                created_at: Set(Utc::now()),
                device_uuid: Set(self.current_device_uuid),
            }.insert(&self.library_db).await?;
        }

        Ok(content_metadata)
    }

    async fn add_tags_to_metadata(&self, metadata_id: i32, tag_uuids: Vec<Uuid>) -> Result<()> {
        for tag_uuid in tag_uuids {
            UserMetadataTagActiveModel {
                user_metadata_id: Set(metadata_id),
                tag_uuid: Set(tag_uuid),
                created_at: Set(Utc::now()),
                device_uuid: Set(self.current_device_uuid),
            }.insert(&self.library_db).await?;
        }
        Ok(())
    }
}

pub struct MetadataUpdate {
    pub notes: Option<String>,
    pub favorite: Option<bool>,
    pub hidden: Option<bool>,
    pub custom_data: Option<Value>,
    pub tag_uuids: Option<Vec<Uuid>>,
}
```

### 5. Library-Scoped Content Operations

```rust
pub struct ContentService {
    library_db: Arc<DatabaseConnection>,
}

impl ContentService {
    /// Find all instances of content within this library only
    pub async fn find_content_instances(
        &self,
        content_identity_uuid: Uuid,
    ) -> Result<Vec<ContentInstance>> {
        let entries = Entry::find_by_content_identity_uuid(
            content_identity_uuid,
            &self.library_db,
        ).await?;

        let mut instances = Vec::new();
        for entry in entries {
            instances.push(ContentInstance {
                entry_uuid: entry.uuid,
                path: entry.materialize_path(&self.library_db).await?,
                device_uuid: entry.get_device_uuid(&self.library_db).await?,
                size: entry.size,
                modified_at: entry.date_modified,
            });
        }

        Ok(instances)
    }

    /// Get content statistics within this library
    pub async fn get_content_stats(
        &self,
        content_identity_uuid: Uuid,
    ) -> Result<LibraryContentStats> {
        let content_identity = ContentIdentity::find_by_uuid(
            content_identity_uuid,
            &self.library_db,
        ).await?
        .ok_or(Error::ContentNotFound)?;

        Ok(LibraryContentStats {
            entry_count: content_identity.entry_count,
            size: content_identity.size,
            combined_size: content_identity.combined_size(),
            first_discovered: content_identity.first_discovered_at,
            last_verified: content_identity.last_verified_at,
        })
    }
}

pub struct ContentInstance {
    pub entry_uuid: Uuid,
    pub path: SdPath,
    pub device_uuid: Uuid,
    pub size: i64,
    pub modified_at: Option<DateTime<Utc>>,
}

pub struct LibraryContentStats {
    pub entry_count: i32,
    pub total_size: i64,     // Size of one instance
    pub combined_size: i64,  // Calculated on-demand (entry_count * total_size)
    pub integrity_hash: Option<String>,
    pub content_hash: String,
    pub mime_type_id: Option<i32>,
    pub kind_id: i32,
    pub has_media_data: bool,
    pub first_seen: DateTime<Utc>,
    pub last_verified: DateTime<Utc>,
}
```

## Migration Strategy

### Phase 1: Foundation Changes

1. **Add deterministic UUID generation** to ContentIdentity (content identification phase)
2. **Add integrity_hash field** to ContentIdentity schema
3. **Enhance UserMetadata** with scoped targeting (entry_uuid OR content_identity_uuid)
4. **Update indexing phases** to defer ContentIdentity creation until content identification

### Phase 2: Enhanced Metadata Linking

1. **Keep current behavior** - UserMetadata created on-demand when users add tags
2. **Update UserMetadata schema** to include content_identity_uuid field
3. **Update indexer** to link UserMetadata to ContentIdentity when both exist

### Phase 3: Hierarchical Metadata APIs

1. **Implement MetadataService** with flexible targeting
2. **Update UI** to offer entry vs content metadata choices with hierarchy display
3. **Migrate existing metadata** to entry-scoped by default

### Phase 4: File Change Handling Integration

1. **Implement content change detection** based on original Spacedrive's proven methods
2. **Add Entry unlinking logic** for content identification phase
3. **Update indexer phases** to handle metadata preservation
4. **Implement ContentService** for library-scoped content operations

### Phase 5: Sync Integration

1. **Connect tagging operations** to sync system
2. **Implement conflict resolution** for content-level tags
3. **Add cross-device tag propagation**

## Database Schema Updates

```sql
-- ContentIdentity enhancements (UUID optional until content identification phase)
ALTER TABLE content_identities
ALTER COLUMN uuid DROP NOT NULL; -- Allow NULL until content identification phase assigns deterministic UUID
ALTER COLUMN full_hash RENAME TO integrity_hash; -- Rename for clarity of purpose
ALTER TABLE content_identities DROP COLUMN cas_version; -- Deprecated, use app version for regeneration if needed

-- Entry UUIDs optional until content identification phase
ALTER TABLE entries
ALTER COLUMN uuid DROP NOT NULL; -- Allow NULL until content identification phase complete

-- UserMetadata enhancements for hierarchical scoping
ALTER TABLE user_metadata
ADD COLUMN entry_uuid TEXT REFERENCES entries(uuid) ON DELETE CASCADE,
ADD COLUMN content_identity_uuid TEXT REFERENCES content_identities(uuid) ON DELETE CASCADE,
ADD COLUMN created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
ADD COLUMN updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP;

-- Ensure mutual exclusivity: exactly one of entry_uuid OR content_identity_uuid is set
ALTER TABLE user_metadata
ADD CONSTRAINT check_metadata_scope 
CHECK ((entry_uuid IS NOT NULL AND content_identity_uuid IS NULL) OR 
       (entry_uuid IS NULL AND content_identity_uuid IS NOT NULL));

-- NOTE: For sync compatibility, entry.metadata_id should be nullable
-- to avoid circular dependency during sync (Entry -> UserMetadata -> Entry)
ALTER TABLE entries
ALTER COLUMN metadata_id DROP NOT NULL; -- Allow NULL during sync resolution

-- Rename existing junction table for clarity
ALTER TABLE metadata_tags RENAME TO user_metadata_tags;
ALTER TABLE user_metadata_tags RENAME COLUMN metadata_id TO user_metadata_id;
ALTER TABLE user_metadata_tags ADD COLUMN device_uuid TEXT NOT NULL REFERENCES devices(uuid);

-- Indexes for performance
CREATE INDEX idx_user_metadata_entry ON user_metadata(entry_uuid);
CREATE INDEX idx_user_metadata_content ON user_metadata(content_identity_uuid);
CREATE INDEX idx_user_metadata_tags_metadata ON user_metadata_tags(user_metadata_id);
CREATE INDEX idx_user_metadata_tags_tag ON user_metadata_tags(tag_uuid);
```

## Benefits

### For Users

- **Flexible Tagging**: Choose between file-specific and content-universal tags
- **Library Content View**: See all instances of content within the current library
- **Intelligent Deduplication**: Better understanding of storage usage within each library
- **Consistent Metadata**: Content tags follow the content everywhere within the library

### For Developers

- **Clean Separation**: Entry-level vs content-level concerns clearly separated
- **Sync-Friendly**: Deterministic ContentIdentity enables consistent sync within libraries
- **Performance**: Hybrid ID system maintains database performance, no redundant cached calculations
- **Library Isolation**: Maintains Spacedrive's zero-knowledge principle between libraries
- **Extensibility**: Foundation for advanced content management features within each library

### For Sync System

- **Sync Readiness Indicator**: `uuid: None` prevents premature syncing until content identification complete
- **Deterministic References**: ContentIdentity UUIDs are consistent across devices within the same library
- **Race Condition Prevention**: No sync operations until both Entry and ContentIdentity are fully processed
- **Clear Domains**: Entry tags sync with index, content tags sync as user metadata
- **Conflict Resolution**: Content-level tags can use union merge strategies
- **Library-Scoped Sync**: Content tags sync within library boundaries, maintaining isolation

## Implementation Notes

1. **Backward Compatibility**: All changes maintain compatibility with existing data and behaviors
2. **UserMetadata Preservation**: Keeps current on-demand creation - only created when users add tags/metadata
3. **Migration Safety**: Each phase can be deployed independently with rollback capability
4. **Performance Impact**: Minimal - mostly adds new tables and optional fields
5. **Sync Integration**: Designed to work seamlessly with the job-based sync system using UUID-optional approach
6. **UI Impact**: New tagging options require UI updates but don't break existing flows
7. **Indexer Compatibility**: Works with existing change detection and content identification flows
8. **Sync Safety**: UUID assignment during content identification prevents race conditions and incomplete data sync
9. **Automatic Sync Integration**: SeaORM hooks with in-memory queuing ensure all database changes are captured for sync
10. **Transaction Safety**: Sync queue flushing at transaction boundaries prevents data loss
11. **Dependency-Aware Sync**: Entry.metadata_id made nullable to resolve circular dependencies during sync
12. **Phased Sync Support**: Database schema supports multi-phase sync to respect foreign key constraints

## File Change Handling

Building on the proven approach from original Spacedrive, our system handles filesystem changes with these principles:

### Core Principle: **"Preserve Entry, Unlink and Re-identify Content"**

Inspired by original Spacedrive's `file_path` → `object` unlinking strategy, adapted for our Entry → ContentIdentity architecture.

### Content Changes (new content_hash)

**Detection Method** (from original Spacedrive):
- Inode comparison for primary detection
- Modification time comparison with millisecond tolerance
- Content hash verification during content identification phase

**Handling Strategy**:
```rust
// When content change detected during indexing
pub async fn handle_content_change(
    entry: &mut Entry,
    old_content_hash: Option<String>,
    new_content_hash: String,
) -> Result<()> {
    // 1. Unlink from old ContentIdentity (like original's object unlinking)
    entry.content_id = None;
    // entry.uuid preserved - same file, maintain sync continuity
    
    // 2. Preserve all Entry data (like original's file_path preservation)
    // - Entry record stays intact
    // - Entry UUID preserved (sync continuity)
    // - Entry-scoped UserMetadata preserved
    // - Filesystem metadata preserved
    
    // 3. Queue for content identification phase
    // - Will generate new content_hash
    // - Will create/link to appropriate ContentIdentity
    // - Entry remains sync-ready throughout process
}
```

**What Happens**:
- **Entry record**: Preserved (same file, same location)
- **Entry UUID**: Preserved (maintains sync continuity for same file)
- **Entry-scoped UserMetadata**: Preserved (follows the file like original)
- **Filesystem metadata**: Preserved (path, timestamps, size)
- **Sync readiness**: Maintained (Entry UUID present, syncs normally)
- **Automatic sync capture**: SeaORM hooks automatically queue sync changes for Entry updates
- **ContentIdentity link**: Unlinked (`content_id = None`)
- **Content-scoped UserMetadata**: Lost (was for old content)
- **Re-identification**: Queued for content identification phase

### File Moves/Renames (same content)

**Detection Method**:
- Same inode, different path
- Modification time unchanged
- Content hash unchanged (when verified)

**Handling Strategy**:
```rust
// Efficient path-only update (like original Spacedrive)
pub async fn handle_file_move(
    entry: &mut Entry,
    new_path: &SdPath,
) -> Result<()> {
    // Only update path-related fields
    entry.relative_path = new_path.relative_path();
    entry.name = new_path.name();
    
    // Everything else preserved:
    // - Entry UUID preserved
    // - ContentIdentity link preserved  
    // - All UserMetadata preserved (both scopes)
}
```

**What Happens**:
- **Entry UUID**: Preserved
- **Entry-scoped UserMetadata**: Preserved
- **ContentIdentity link**: Preserved (`content_id` unchanged)
- **Content-scoped UserMetadata**: Preserved
- **Path update**: Only location fields updated

### Real-time vs Batch Detection

**Real-time Watcher** (when available):
- Immediate detection of file system events
- Content change handling as files are modified
- Efficient move detection via filesystem events

**Batch Indexing** (offline changes):
- Inode + timestamp comparison like original Spacedrive
- Bulk processing of detected changes
- Same preservation principles applied

### Key Improvements Over Original

1. **Hierarchical Metadata**: Both entry and content scopes preserved when appropriate
2. **Sync Readiness**: UUID assignment prevents incomplete sync
3. **Deterministic Content UUIDs**: Enable consistent cross-device content identity
4. **Unified Metadata Model**: All metadata types use same scoping system

### Proven Principles Retained

1. **Never delete Entry records** due to content changes
2. **Preserve user-important data** with the filesystem entry
3. **Unlink and re-identify** rather than delete and recreate
4. **Content-derived data** regenerated as needed
5. **Efficient move handling** for path-only changes

## Metadata Migration Rules

During the indexing process when content changes are detected:

### Automatic Migration Scenarios

1. **Entry-level metadata** → Always preserved (stays with file)
2. **Content-level metadata** → Lost (was for old content)
3. **Hybrid approach** → Future: prompt user for high-value content metadata

### Implementation in Indexer

```rust
// During content change detection in indexer
pub async fn handle_content_change_with_metadata(
    entry: &mut Entry,
    old_content_id: Option<i32>,
    new_content_hash: String,
    db: &DatabaseConnection,
) -> Result<()> {
    // 1. Check if valuable content metadata exists
    if let Some(old_id) = old_content_id {
        let content_metadata_count = UserMetadata::find()
            .filter(user_metadata::Column::ContentIdentityUuid.eq(old_id))
            .count(db)
            .await?;
            
        if content_metadata_count > 0 {
            // Log for future user notification system
            log::info!(
                "Content change for entry {} orphaned {} content metadata items",
                entry.uuid, content_metadata_count
            );
        }
    }
    
    // 2. Proceed with unlinking
    entry.content_id = None;
    entry.update(db).await?;
    
    // 3. Queue for content identification
    // ... existing logic
}
```

## Sync Behavior

### Entry-Scoped UserMetadata (Index Domain)

```rust
impl Syncable for user_metadata::ActiveModel {
    const SYNC_DOMAIN: SyncDomain = SyncDomain::Index; // When entry_uuid is set
    
    fn should_sync(&self) -> bool {
        // Only sync entry-scoped metadata (entry_uuid is not null)
        self.entry_uuid.as_ref().is_some()
    }
}
```

### Content-Scoped UserMetadata (UserMetadata Domain)

```rust
impl Syncable for user_metadata::ActiveModel {
    const SYNC_DOMAIN: SyncDomain = SyncDomain::UserMetadata; // When content_identity_uuid is set
    
    fn should_sync(&self) -> bool {
        // Only sync content-scoped metadata (content_identity_uuid is not null)
        self.content_identity_uuid.as_ref().is_some()
    }

    fn merge_user_metadata(local: Self::Model, remote: Self::Model) -> MergeResult<Self::Model> {
        // Intelligent merge for content-scoped metadata
        // Notes: keep both (displayed in hierarchy)
        // Tags: union merge via junction table
        // Favorites/Hidden: OR logic (true if either is true)
        MergeResult::Merged(Self::Model {
            favorite: local.favorite || remote.favorite,
            hidden: local.hidden || remote.hidden,
            notes: merge_notes(local.notes, remote.notes), // Keep both with timestamps
            custom_data: merge_custom_data(local.custom_data, remote.custom_data),
            updated_at: std::cmp::max(local.updated_at, remote.updated_at),
            ..local
        })
    }
}
```

### Sync Examples

**Entry-Scoped Metadata:**

```
Device A: Adds notes "work draft" and tags ["urgent"] to "report.pdf" (Entry-scoped)
Device B: Syncs and sees notes and tags on report.pdf at its local path
Result: Metadata appears on Device B's report.pdf (same Entry UUID synced)
```

**Content-Scoped Metadata:**

```
Device A: Adds notes "important document" and tags ["legal"] to content (Content-scoped)
Device B: Has same content at "/backup/report.pdf" (different path, same content)
Result: Metadata appears on Device B's file too (same ContentIdentity UUID)
```

**Hierarchy Display:**

```
File has both entry-scoped and content-scoped metadata:
- Notes: "work draft" (Entry) + "important document" (Content) - both shown
- Tags: ["urgent"] (Entry) + ["legal"] (Content) - both shown  
- Favorite: true (Entry overrides false from Content)
```

**Content Change:**

```
Device A: User adds metadata to "photo.jpg" (Entry-scoped)
Device A: User edits photo.jpg (new content → new ContentIdentity UUID)
Device B: Syncs the changes
Result: Entry-scoped metadata stays with the file, content-scoped metadata is lost
```

**Promotion Example:**

```
User adds tags ["vacation", "family"] to "beach.jpg" (Entry-scoped)
User clicks "Apply to all instances"
System creates Content-scoped metadata with same tags
Now all instances of this content show these tags (hierarchy: both levels displayed)
```

This refactor provides the foundation for a much more powerful and flexible content management system while maintaining the performance, reliability, and UX patterns of the existing architecture.
