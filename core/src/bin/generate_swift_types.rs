//! Generate Swift types using Specta and our rspc-inspired type extraction system
//!
//! This binary automatically discovers all registered operations and queries
//! and generates comprehensive Swift types for the complete Spacedrive API.

use specta::TypeCollection;
use specta_swift::Swift;
use std::path::Path;

// Import our type extraction system
use sd_core::ops::type_extraction::{create_spacedrive_api_structure, generate_spacedrive_api};

fn main() -> Result<(), Box<dyn std::error::Error>> {
	println!("ğŸ¦€â¡ï¸ğŸ Generating Swift types using Specta + rspc-inspired type extraction...");

	// Use our automatic type extraction system to discover all operations and queries
	let (operations, queries, types) = generate_spacedrive_api();

	println!(
		"ğŸ” Discovered {} operations and {} queries",
		operations.len(),
		queries.len()
	);

	// Create the API structure
	let api_structure = create_spacedrive_api_structure(&operations, &queries);

	println!("ğŸ“Š API Structure Summary:");
	println!("  â€¢ Core Actions: {}", api_structure.core_actions.len());
	println!(
		"  â€¢ Library Actions: {}",
		api_structure.library_actions.len()
	);
	println!("  â€¢ Core Queries: {}", api_structure.core_queries.len());
	println!(
		"  â€¢ Library Queries: {}",
		api_structure.library_queries.len()
	);

	// Generate Swift code directly from the API structure (like rspc does for TypeScript)
	let generated_content = generate_swift_api_code(&api_structure, &types)?;

	// Export to the Swift client package
	let output_path =
		Path::new("packages/swift-client/Sources/SpacedriveClient/SpacedriveTypes.swift");
	std::fs::write(output_path, &generated_content)?;

	println!("âœ… Generated Swift types to: {}", output_path.display());

	// Generate API code using our new functions
	let functions = sd_core::ops::type_extraction::extract_api_functions(&operations, &queries);
	let api_code = sd_core::ops::type_extraction::generate_swift_api_code(&functions);

	// Write API code to a separate file
	let api_output_path =
		Path::new("packages/swift-client/Sources/SpacedriveClient/SpacedriveAPI.swift");
	std::fs::write(api_output_path, &api_code)?;

	println!(
		"âœ… Generated Swift API code to: {}",
		api_output_path.display()
	);
	println!("ğŸ‰ Specta Swift generation completed!");
	println!(
		"ğŸš€ All {} operations and {} queries automatically discovered and exported!",
		operations.len(),
		queries.len()
	);

	// Print a sample of the generated content for inspection
	let lines: Vec<&str> = generated_content.lines().collect();
	let sample_size = std::cmp::min(50, lines.len());
	println!(
		"\nğŸ“„ Sample of generated Swift code (first {} lines):",
		sample_size
	);
	for line in lines.iter().take(sample_size) {
		println!("{}", line);
	}
	if lines.len() > sample_size {
		println!("... ({} more lines)", lines.len() - sample_size);
	}

	Ok(())
}

/// Generate Swift code directly from the API structure (similar to rspc's TypeScript generation)
fn generate_swift_api_code(
	api_structure: &sd_core::ops::type_extraction::SpacedriveApiStructure,
	types: &specta::TypeCollection,
) -> Result<String, Box<dyn std::error::Error>> {
	let mut swift_code = String::new();

	// Header
	swift_code.push_str(
		"// Generated by Spacedrive using Specta + rspc-inspired type extraction - DO NOT EDIT\n",
	);

	// Generate all types using Specta Swift (single export call with deduplication)
	let mut swift = specta_swift::Swift::new()
		.header("")
		.naming(specta_swift::NamingConvention::PascalCase)
		.optionals(specta_swift::OptionalStyle::QuestionMark);

	// Enable initializer generation for structs
	swift.generate_initializers = true;

	let mut individual_types = swift.export(types)?;

	// Fix JsonValue recursive definition issue
	individual_types = individual_types.replace("case number(JsonValue)", "case number(Double)");

	// Replace JsonValue and RawJson with JSONValue for better JSON handling
	individual_types = individual_types.replace("JsonValue", "JSONValue");
	individual_types = individual_types.replace("RawJson", "JSONValue");

	// Make actionInput and context optional in ActionContextInfo
	individual_types = individual_types.replace(
		"public let actionInput: JSONValue",
		"public let actionInput: JSONValue?",
	);
	individual_types = individual_types.replace(
		"public let context: JSONValue",
		"public let context: JSONValue?",
	);

	// Fix the initializer to use optional parameters
	individual_types = individual_types.replace(
		"public init(actionType: String, initiatedAt: String, initiatedBy: String?, actionInput: JSONValue, context: JSONValue)",
		"public init(actionType: String, initiatedAt: String, initiatedBy: String?, actionInput: JSONValue?, context: JSONValue?)",
	);

	// Remove duplicate JSONValue struct (the old RawJson struct)
	individual_types = individual_types.replace(
		"public struct JSONValue: Codable {\n    let value: JSONValue\n}",
		"",
	);

	// Add custom Codable implementation for JSONValue to serialize as raw JSON
	let jsonvalue_codable_impl = r#"
extension JSONValue: Codable {
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()

        if container.decodeNil() {
            self = .null
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let int = try? container.decode(Int.self) {
            self = .number(Double(int))
        } else if let double = try? container.decode(Double.self) {
            self = .number(double)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let array = try? container.decode([JSONValue].self) {
            self = .array(array)
        } else if let object = try? container.decode([String: JSONValue].self) {
            self = .object(object)
        } else {
            throw DecodingError.typeMismatch(JSONValue.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Invalid JSONValue"))
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()

        switch self {
        case .null:
            try container.encodeNil()
        case .bool(let bool):
            try container.encode(bool)
        case .number(let double):
            try container.encode(double)
        case .string(let string):
            try container.encode(string)
        case .array(let array):
            try container.encode(array)
        case .object(let object):
            try container.encode(object)
        }
    }
}
"#;

	// Remove Codable conformance from enum declaration and add custom implementation
	individual_types = individual_types.replace(
		"public indirect enum JSONValue: Codable {\n    case null\n    case bool(Bool)\n    case number(Double)\n    case string(String)\n    case array([JSONValue])\n    case object([String: JSONValue])\n}",
		&format!("public indirect enum JSONValue {{\n    case null\n    case bool(Bool)\n    case number(Double)\n    case string(String)\n    case array([JSONValue])\n    case object([String: JSONValue])\n}}{}", jsonvalue_codable_impl),
	);

	swift_code.push_str(&individual_types);
	swift_code.push_str("\n");

	// Generate the main API enum
	swift_code.push_str("/// Complete Spacedrive API structure\n");
	swift_code.push_str("public enum SpacedriveApi {\n");
	swift_code.push_str("    case CoreAction(CoreAction)\n");
	swift_code.push_str("    case LibraryAction(LibraryAction)\n");
	swift_code.push_str("    case CoreQuery(CoreQuery)\n");
	swift_code.push_str("    case LibraryQuery(LibraryQuery)\n");
	swift_code.push_str("}\n\n");

	// Add Codable conformance for SpacedriveApi
	swift_code.push_str("extension SpacedriveApi: Codable {\n");
	swift_code.push_str("    public var wireMethod: String {\n");
	swift_code.push_str("        switch self {\n");
	swift_code.push_str("        case .CoreAction: return \"core_action\"\n");
	swift_code.push_str("        case .LibraryAction: return \"library_action\"\n");
	swift_code.push_str("        case .CoreQuery: return \"core_query\"\n");
	swift_code.push_str("        case .LibraryQuery: return \"library_query\"\n");
	swift_code.push_str("        }\n");
	swift_code.push_str("    }\n");
	swift_code.push_str("}\n\n");

	// Generate CoreAction enum
	swift_code.push_str("/// Core-scoped actions\n");
	swift_code.push_str("public enum CoreAction {\n");
	for action in &api_structure.core_actions {
		let variant_name = to_pascal_case(&action.identifier);
		swift_code.push_str(&format!(
			"    case {}(input: {}, output: {})\n",
			variant_name, action.input_type_name, action.output_type_name
		));
	}
	swift_code.push_str("}\n\n");

	// Add Codable conformance for CoreAction
	swift_code.push_str("extension CoreAction: Codable {\n");
	swift_code.push_str("    public var wireMethod: String {\n");
	swift_code.push_str("        switch self {\n");
	for action in &api_structure.core_actions {
		let variant_name = to_pascal_case(&action.identifier);
		swift_code.push_str(&format!(
			"        case .{}: return \"{}\"\n",
			variant_name, action.wire_method
		));
	}
	swift_code.push_str("        }\n");
	swift_code.push_str("    }\n");
	swift_code.push_str("}\n\n");

	// Generate LibraryAction enum
	swift_code.push_str("/// Library-scoped actions\n");
	swift_code.push_str("public enum LibraryAction {\n");
	for action in &api_structure.library_actions {
		let variant_name = to_pascal_case(&action.identifier);
		swift_code.push_str(&format!(
			"    case {}(input: {}, output: {})\n",
			variant_name, action.input_type_name, action.output_type_name
		));
	}
	swift_code.push_str("}\n\n");

	// Add Codable conformance for LibraryAction
	swift_code.push_str("extension LibraryAction: Codable {\n");
	swift_code.push_str("    public var wireMethod: String {\n");
	swift_code.push_str("        switch self {\n");
	for action in &api_structure.library_actions {
		let variant_name = to_pascal_case(&action.identifier);
		swift_code.push_str(&format!(
			"        case .{}: return \"{}\"\n",
			variant_name, action.wire_method
		));
	}
	swift_code.push_str("        }\n");
	swift_code.push_str("    }\n");
	swift_code.push_str("}\n\n");

	// Generate CoreQuery enum
	swift_code.push_str("/// Core-scoped queries\n");
	swift_code.push_str("public enum CoreQuery {\n");
	for query in &api_structure.core_queries {
		let variant_name = to_pascal_case(&query.identifier);
		swift_code.push_str(&format!(
			"    case {}(input: {}, output: {})\n",
			variant_name, query.input_type_name, query.output_type_name
		));
	}
	swift_code.push_str("}\n\n");

	// Add Codable conformance for CoreQuery
	swift_code.push_str("extension CoreQuery: Codable {\n");
	swift_code.push_str("    public var wireMethod: String {\n");
	swift_code.push_str("        switch self {\n");
	for query in &api_structure.core_queries {
		let variant_name = to_pascal_case(&query.identifier);
		swift_code.push_str(&format!(
			"        case .{}: return \"{}\"\n",
			variant_name, query.wire_method
		));
	}
	swift_code.push_str("        }\n");
	swift_code.push_str("    }\n");
	swift_code.push_str("}\n\n");

	// Generate LibraryQuery enum
	swift_code.push_str("/// Library-scoped queries\n");
	swift_code.push_str("public enum LibraryQuery {\n");
	for query in &api_structure.library_queries {
		let variant_name = to_pascal_case(&query.identifier);
		swift_code.push_str(&format!(
			"    case {}(input: {}, output: {})\n",
			variant_name, query.input_type_name, query.output_type_name
		));
	}
	swift_code.push_str("}\n\n");

	// Add Codable conformance for LibraryQuery
	swift_code.push_str("extension LibraryQuery: Codable {\n");
	swift_code.push_str("    public var wireMethod: String {\n");
	swift_code.push_str("        switch self {\n");
	for query in &api_structure.library_queries {
		let variant_name = to_pascal_case(&query.identifier);
		swift_code.push_str(&format!(
			"        case .{}: return \"{}\"\n",
			variant_name, query.wire_method
		));
	}
	swift_code.push_str("        }\n");
	swift_code.push_str("    }\n");
	swift_code.push_str("}\n");

	Ok(swift_code)
}

/// Convert snake_case to PascalCase
fn to_pascal_case(s: &str) -> String {
	s.split('.')
		.map(|part| {
			// Split each part on underscores and convert to PascalCase
			part.split('_')
				.map(|subpart| {
					let mut chars = subpart.chars();
					match chars.next() {
						None => String::new(),
						Some(first) => first.to_uppercase().collect::<String>() + &chars.as_str(),
					}
				})
				.collect::<String>()
		})
		.collect::<Vec<_>>()
		.join("")
}
