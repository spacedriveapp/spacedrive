datasource db {
  provider = "sqlite"
  url      = "file:dev.db"
}

generator client {
  provider      = "cargo prisma"
  output        = "../../crates/prisma/src/prisma"
  module_path   = "prisma"
  client_format = "folder"
}

generator sync {
  provider      = "cargo prisma-sync"
  output        = "../../crates/prisma/src/prisma_sync"
  client_format = "folder"
}

/// @local
model CRDTOperation {
  id Int @id @default(autoincrement())

  timestamp BigInt
  model     Int

  record_id Bytes
  // Enum: ??
  kind      String
  data      Bytes

  instance_id Int
  instance    Instance @relation(fields: [instance_id], references: [id])

  @@map("crdt_operation")
}

/// @local
model CloudCRDTOperation {
  id Int @id @default(autoincrement())

  timestamp BigInt
  model     Int

  record_id Bytes
  // Enum: ??
  kind      String
  data      Bytes

  instance_id Int
  instance    Instance @relation(fields: [instance_id], references: [id])

  @@map("cloud_crdt_operation")
}

/// @deprecated: This model has to exist solely for backwards compatibility.
/// @local
model Node {
  id           Int      @id @default(autoincrement())
  pub_id       Bytes    @unique
  name         String
  // Enum: sd_core::node::Platform
  platform     Int
  date_created DateTime
  identity     Bytes? // TODO: Change to required field in future

  @@map("node")
}

// represents a single `.db` file (SQLite DB) that is paired to the current library.
// A `LibraryInstance` is always owned by a single `Node` but it's possible for that node to change (or two to be owned by a single node).
/// @local
model Instance {
  id              Int    @id @default(autoincrement()) // This is is NOT globally unique
  pub_id          Bytes  @unique // This UUID is meaningless and exists soley cause the `uhlc::ID` must be 16-bit. Really this should be derived from the `identity` field.
  // Enum: sd_p2p::Identity (or sd_core::p2p::IdentityOrRemoteIdentity in early versions)
  identity        Bytes?
  // Enum: sd_core::node::RemoteIdentity
  remote_identity Bytes

  node_id  Bytes
  metadata Bytes? // TODO: This should not be optional

  last_seen    DateTime // Time core started for owner, last P2P message for P2P node
  date_created DateTime

  // clock timestamp for sync
  timestamp BigInt?

  locations          Location[]
  CRDTOperation      CRDTOperation[]
  CloudCRDTOperation CloudCRDTOperation[]

  @@map("instance")
}

/// @local
model Statistics {
  id                   Int      @id @default(autoincrement())
  date_captured        DateTime @default(now())
  total_object_count   Int      @default(0)
  library_db_size      String   @default("0")
  total_bytes_used     String   @default("0")
  total_bytes_capacity String   @default("0")
  total_unique_bytes   String   @default("0")
  total_bytes_free     String   @default("0")
  preview_media_bytes  String   @default("0")

  @@map("statistics")
}

/// @local
model Volume {
  id                    Int      @id @default(autoincrement())
  name                  String
  mount_point           String
  total_bytes_capacity  String   @default("0")
  total_bytes_available String   @default("0")
  disk_type             String?
  filesystem            String?
  is_system             Boolean  @default(false)
  date_modified         DateTime @default(now())

  @@unique([mount_point, name])
  @@map("volume")
}

/// @shared(id: pub_id, modelId: 1)
model Location {
  id     Int   @id @default(autoincrement())
  pub_id Bytes @unique

  name                   String?
  path                   String?
  total_capacity         Int?
  available_capacity     Int?
  size_in_bytes          Bytes?
  is_archived            Boolean?
  generate_preview_media Boolean?
  sync_preview_media     Boolean?
  hidden                 Boolean?
  date_created           DateTime?

  scan_state Int @default(0) // Enum: sd_core::location::ScanState

  /// @local
  // this is just a client side cache which is annoying but oh well (@brendan)
  instance_id Int?
  instance    Instance? @relation(fields: [instance_id], references: [id], onDelete: SetNull)

  file_paths    FilePath[]
  indexer_rules IndexerRulesInLocation[]

  @@map("location")
}

/// @shared(id: pub_id, modelId: 2)
model FilePath {
  id     Int   @id @default(autoincrement())
  pub_id Bytes @unique

  is_dir Boolean?

  // content addressable storage id - blake3 sampled checksum
  cas_id             String?
  // full byte contents digested into blake3 checksum
  integrity_checksum String?

  // location that owns this path
  location_id Int?
  location    Location? @relation(fields: [location_id], references: [id], onDelete: SetNull)

  // the path of the file relative to its location
  materialized_path String?

  // the name and extension, MUST have 'COLLATE NOCASE' in migration
  name      String?
  extension String?
  hidden    Boolean?

  size_in_bytes       String? // deprecated
  size_in_bytes_bytes Bytes?

  inode Bytes? // This is actually an unsigned 64 bit integer, but we don't have this type in SQLite

  // the unique Object for this file path
  object_id Int?
  object    Object? @relation(fields: [object_id], references: [id], onDelete: SetNull)

  key_id Int? // replacement for encryption
  // permissions       String?

  date_created  DateTime?
  date_modified DateTime?
  date_indexed  DateTime?

  media_info    MediaInfo? @relation(fields: [media_info_id], references: [id], onDelete: SetNull)
  media_info_id Int?

  // key Key? @relation(fields: [key_id], references: [id])

  @@unique([location_id, materialized_path, name, extension])
  @@unique([location_id, inode])
  @@index([location_id])
  @@index([location_id, materialized_path])
  @@map("file_path")
}

/// @shared(id: pub_id, modelId: 3)
model Object {
  id     Int   @id @default(autoincrement())
  pub_id Bytes @unique
  // Enum: sd_file_ext::kind::ObjectKind
  kind   Int?

  key_id        Int?
  // handy ways to mark an object
  hidden        Boolean?
  favorite      Boolean?
  important     Boolean?
  // if we have generated preview media for this object on at least one Node
  // commented out for now by @brendonovich since they they're irrelevant to the sync system
  // has_thumbnail     Boolean?
  // has_thumbstrip    Boolean?
  // has_video_preview Boolean?
  // TODO: change above to:
  // has_generated_thumbnail     Boolean  @default(false)
  // has_generated_thumbstrip    Boolean  @default(false)
  // has_generated_video_preview Boolean  @default(false)
  // integration with ipfs
  // ipfs_id           String?
  // plain text note
  note          String?
  // the original known creation date of this object
  date_created  DateTime?
  date_accessed DateTime?

  tags       TagOnObject[]
  labels     LabelOnObject[]
  albums     ObjectInAlbum[]
  spaces     ObjectInSpace[]
  file_paths FilePath[]
  // comments   Comment[]
  exif_data  ExifData?

  // key Key? @relation(fields: [key_id], references: [id])

  @@map("object")
}

/// @shared(id: object, modelId: 4)
model ExifData {
  id Int @id @default(autoincrement())

  resolution     Bytes?
  media_date     Bytes?
  media_location Bytes?
  camera_data    Bytes?
  artist         String?
  description    String?
  copyright      String?
  exif_version   String?

  // purely for sorting/ordering, never sent to the frontend as they'd be useless
  // these are also usually one-way, and not reversible
  // (e.g. we can't get `MediaDate::Utc(2023-09-26T22:04:37+01:00)` from `1695758677` as we don't store the TZ)
  epoch_time BigInt? // time since unix epoch

  // video-specific
  // duration Int?
  // fps      Int?
  // streams  Int?
  // video_codec   String? // eg: "h264, h265, av1"
  // audio_codec String? // eg: "opus"

  object_id Int    @unique
  object    Object @relation(fields: [object_id], references: [id], onDelete: Cascade)

  @@map("exif_data")
}

model MediaInfo {
  id Int @id @default(autoincrement())

  // Internal FFmpeg properties
  formats    String?
  duration   BigInt?
  start_time BigInt?
  bitrate    BigInt?

  chapters MediaChapter[]
  programs MediaProgram[]

  metadata    MediaMetadata @relation(fields: [metadata_id], references: [id], onDelete: Cascade)
  metadata_id Int           @unique

  files FilePath[]

  @@map("media_info")
}

model MediaChapter {
  chapter_id Int

  start BigInt?
  end   BigInt?

  metadata    MediaMetadata @relation(fields: [metadata_id], references: [id], onDelete: Cascade)
  metadata_id Int           @unique

  media_info    MediaInfo @relation(fields: [media_info_id], references: [id], onDelete: Cascade)
  media_info_id Int

  @@id(name: "likeId", [media_info_id, chapter_id])
  @@map("media_chapter")
}

model MediaProgram {
  program_id Int

  name    String?
  streams MediaStream[]

  metadata    MediaMetadata @relation(fields: [metadata_id], references: [id], onDelete: Cascade)
  metadata_id Int           @unique

  media_info    MediaInfo @relation(fields: [media_info_id], references: [id], onDelete: Cascade)
  media_info_id Int

  @@id(name: "likeId", [media_info_id, program_id])
  @@map("media_program")
}

model MediaStream {
  stream_id Int

  name                  String?
  codec                 MediaCodec?
  aspect_ratio_num      Int?
  aspect_ratio_den      Int?
  frames_per_second_num Int?
  frames_per_second_den Int?
  time_base_real_den    Int?
  time_base_real_num    Int?
  dispositions          String?

  metadata    MediaMetadata @relation(fields: [metadata_id], references: [id], onDelete: Cascade)
  metadata_id Int           @unique

  program       MediaProgram @relation(fields: [media_info_id, program_id], references: [media_info_id, program_id], onDelete: Cascade)
  program_id    Int
  media_info_id Int

  @@id(name: "likeId", [media_info_id, program_id, stream_id])
  @@unique([media_info_id, program_id])
  @@map("media_stream")
}

model MediaCodec {
  id Int @id @default(autoincrement())

  type     String?
  tag      String?
  name     String?
  profile  String?
  bit_rate BigInt?

  video_props    MediaVideoProps?
  audio_props    MediaAudioProps?
  subtitle_props MediaSubtitleProps?

  codec         MediaStream @relation(fields: [media_info_id, program_id, stream_id], references: [media_info_id, program_id, stream_id], onDelete: Cascade)
  stream_id     Int
  program_id    Int
  media_info_id Int

  @@unique([media_info_id, program_id, stream_id])
  @@map("media_codec")
}

model MediaVideoProps {
  id Int @id @default(autoincrement())

  pixel_format     String?
  color_range      String?
  bits_per_channel Int?
  color_space      String?
  color_primaries  String?
  color_transfer   String?
  field_order      String?
  chroma_location  String?
  coded_width      Int?
  coded_height     Int?
  aspect_ratio_num Int?
  aspect_ratio_Den Int?
  properties       String

  codec    MediaCodec @relation(fields: [codec_id], references: [id], onDelete: Cascade)
  codec_id Int        @unique

  @@map("media_video_props")
}

model MediaAudioProps {
  id Int @id @default(autoincrement())

  delay          Int?
  padding        Int?
  sample_rate    Int?
  sample_format  String?
  bit_per_sample Int?
  channel_layout String?

  codec    MediaCodec @relation(fields: [codec_id], references: [id], onDelete: Cascade)
  codec_id Int        @unique

  @@map("media_audio_props")
}

model MediaSubtitleProps {
  id Int @id @default(autoincrement())

  width  Int?
  height Int?

  codec    MediaCodec @relation(fields: [codec_id], references: [id], onDelete: Cascade)
  codec_id Int        @unique

  @@map("media_subtitle_props")
}

model MediaMetadata {
  id Int @id @default(autoincrement())

  // FFmpeg Metadata API
  // https://ffmpeg.org/doxygen/trunk/group__metadata__api.html
  album            String? // -- name of the set this work belongs to
  album_artist     String? // -- main creator of the set/album, if different from artist.
  //                             e.g. "Various Artists" for compilation albums.
  artist           String? // -- main creator of the work
  comment          String? // -- any additional description of the file.
  composer         String? // -- who composed the work, if different from artist.
  copyright        String? // -- name of copyright holder.
  creation_time    DateTime? // -- date when the file was created, preferably in ISO 8601.
  date             DateTime? // -- date when the work was created, preferably in ISO 8601.
  disc             Int? // -- number of a subset, e.g. disc in a multi-disc collection.
  encoder          String? // -- name/settings of the software/hardware that produced the file.
  encoded_by       String? // -- person/group who created the file.
  filename         String? // -- original name of the file.
  genre            String?
  language         String? // -- main language in which the work is performed, preferably
  //                             in ISO 639-2 format. Multiple languages can be specified by
  //                             separating them with commas.
  performer        String? // -- artist who performed the work, if different from artist.
  //                             E.g for "Also sprach Zarathustra", artist would be "Richard
  //                             Strauss" and performer "London Philharmonic Orchestra".
  publisher        String? // -- name of the label/publisher.
  service_name     String? // -- name of the service in broadcasting (channel name).
  service_provider String? // -- name of the service provider in broadcasting.
  title            String? // -- name of the work.
  track            Int? // -- number of this work in the set, can be in form current/total.
  variant_bitrate  Int? // -- the total bitrate of the bitrate variant that the current stream is part of

  custom CustomMetadata[]

  media_info    MediaInfo?
  media_chapter MediaChapter?
  media_program MediaProgram?
  media_stream  MediaStream?

  @@map("media_metadata")
}

model CustomMetadata {
  id Int @id @default(autoincrement())

  key   String?
  value String?

  media_metadata    MediaMetadata @relation(fields: [media_metadata_id], references: [id], onDelete: Cascade)
  media_metadata_id Int           @unique

  @@map("custom_metadata")
}

//// Tag ////

/// @shared(id: pub_id, modelId: 5)
model Tag {
  id     Int     @id @default(autoincrement())
  pub_id Bytes   @unique
  name   String?
  color  String?

  is_hidden Boolean? // user hidden entire tag

  date_created  DateTime?
  date_modified DateTime?

  tag_objects TagOnObject[]

  @@map("tag")
}

/// @relation(item: object, group: tag, modelId: 6)
model TagOnObject {
  object_id Int
  object    Object @relation(fields: [object_id], references: [id], onDelete: Restrict)

  tag_id Int
  tag    Tag @relation(fields: [tag_id], references: [id], onDelete: Restrict)

  date_created DateTime?

  @@id([tag_id, object_id])
  @@map("tag_on_object")
}

//// Label ////

/// @shared(id: name, modelId: 7)
model Label {
  id            Int       @id @default(autoincrement())
  name          String    @unique
  date_created  DateTime?
  date_modified DateTime?

  label_objects LabelOnObject[]

  @@map("label")
}

/// @relation(item: object, group: label, modelId: 8)
model LabelOnObject {
  date_created DateTime @default(now())

  object_id Int
  object    Object @relation(fields: [object_id], references: [id], onDelete: Restrict)

  label_id Int
  label    Label @relation(fields: [label_id], references: [id], onDelete: Restrict)

  @@id([label_id, object_id])
  @@map("label_on_object")
}

//// Space ////

model Space {
  id            Int       @id @default(autoincrement())
  pub_id        Bytes     @unique
  name          String?
  description   String?
  date_created  DateTime?
  date_modified DateTime?

  objects ObjectInSpace[]

  @@map("space")
}

model ObjectInSpace {
  space_id Int
  space    Space @relation(fields: [space_id], references: [id], onDelete: Restrict)

  object_id Int
  object    Object @relation(fields: [object_id], references: [id], onDelete: Restrict)

  @@id([space_id, object_id])
  @@map("object_in_space")
}

//// Job ////

model Job {
  id Bytes @id

  name   String?
  action String? // Will be composed of "{action_description}(-{children_order})*"

  // Enum: sd_core::job::job_manager:JobStatus
  status Int? // 0 = Queued

  // List of errors, separated by "\n\n" in case of failed jobs or completed with errors
  errors_text         String? // Deprecated, use `critical_error` or `non_critical_errors` instead
  critical_error      String? // Serialized error field with info about the failed job after completion
  non_critical_errors Bytes? // Serialized non-critical errors field with info about the completed job with errors after completion

  data     Bytes? // Deprecated
  metadata Bytes? // Serialized metadata field with info about the job after completion

  parent_id Bytes?

  task_count                Int?
  completed_task_count      Int?
  date_estimated_completion DateTime? // Estimated timestamp that the job will be complete at

  date_created   DateTime?
  date_started   DateTime? // Started execution
  date_completed DateTime? // Finished execution

  parent   Job?  @relation("jobs_dependency", fields: [parent_id], references: [id], onDelete: SetNull)
  children Job[] @relation("jobs_dependency")

  @@map("job")
}

//// Album ////

model Album {
  id        Int      @id
  pub_id    Bytes    @unique
  name      String?
  is_hidden Boolean?

  date_created  DateTime?
  date_modified DateTime?

  objects ObjectInAlbum[]

  @@map("album")
}

model ObjectInAlbum {
  date_created DateTime?
  album_id     Int
  album        Album     @relation(fields: [album_id], references: [id], onDelete: NoAction)

  object_id Int
  object    Object @relation(fields: [object_id], references: [id], onDelete: NoAction)

  @@id([album_id, object_id])
  @@map("object_in_album")
}

//// Indexer Rules ////

model IndexerRule {
  id     Int   @id @default(autoincrement())
  pub_id Bytes @unique

  name           String?
  default        Boolean?
  rules_per_kind Bytes?
  date_created   DateTime?
  date_modified  DateTime?

  locations IndexerRulesInLocation[]

  @@map("indexer_rule")
}

model IndexerRulesInLocation {
  location_id Int
  location    Location @relation(fields: [location_id], references: [id], onDelete: Restrict)

  indexer_rule_id Int
  indexer_rule    IndexerRule @relation(fields: [indexer_rule_id], references: [id], onDelete: Restrict)

  @@id([location_id, indexer_rule_id])
  @@map("indexer_rule_in_location")
}

/// @shared(id: key, modelId: 9)
model Preference {
  key   String @id
  value Bytes?

  @@map("preference")
}

model Notification {
  id         Int       @id @default(autoincrement())
  read       Boolean   @default(false)
  // Enum: crate::api::notifications::NotificationData
  data       Bytes
  expires_at DateTime?

  @@map("notification")
}

/// @shared(id: pub_id, modelId: 10)
model SavedSearch {
  id     Int   @id @default(autoincrement())
  pub_id Bytes @unique

  // enum: crate::api::search::saved::SearchTarget
  target  String?
  search  String?
  filters String?

  name        String?
  icon        String?
  description String?
  // order         Int? // Add this line to include ordering

  date_created  DateTime?
  date_modified DateTime?

  @@map("saved_search")
}
